{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SuperComputa\u00e7\u00e3o","text":"<p>Bem-vindo ao curso de SuperComputa\u00e7\u00e3o 2025/1!</p> <p>Essa p\u00e1gina cont\u00e9m os materiais de apoio para o curso de SuperComputa\u00e7\u00e3o do Insper.</p>"},{"location":"#horario-das-aulas","title":"Hor\u00e1rio das Aulas","text":"<p>Hor\u00e1rio das Aulas</p> <p>Turma A - Ter\u00e7a: 09h45 - Sexta: 13h30</p> <p>Turma B - Quarta: 13h30 - Sexta: 07h30</p>"},{"location":"#estrutura-do-curso","title":"Estrutura do Curso","text":"<p>O curso \u00e9 estruturado em tr\u00eas unidades principais, e um projeto:</p> <p>Estrutura do Curso</p> <ol> <li>Programando de forma eficiente computacionalmente</li> <li>Infraestrutura de HPC</li> <li>Programa\u00e7\u00e3o paralela e distribu\u00edda</li> <li>Projeto</li> </ol>"},{"location":"#material","title":"Material","text":"<p>Para alinhar o que esperamos de voc\u00ea, definimos um objetivo e uma entrega para cada aula. Voc\u00ea pode verificar os objetivos e as entregas para cada aula aqui</p>"},{"location":"#notas","title":"Notas","text":"<ul> <li> <p>A somat\u00f3ria de todas as entregas v\u00e1lidas atribui at\u00e9 20% da nota final.</p> </li> <li> <p>O Projeto vale 30%</p> </li> <li>A PI vale 20%</li> <li>A PF vale 30%</li> </ul> <p>Aten\u00e7\u00e3o!</p> <p>A entrega s\u00f3 poder\u00e1 ser realizada at\u00e9 as 23h59 do dia da respectiva aula. </p> <p>Condi\u00e7\u00f5es de barreira</p> <ul> <li>M\u00e9dia de provas &gt;= 4,5</li> <li>PI, PF &gt;= 4,0</li> <li>Projeto &gt;= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados)</li> </ul>"},{"location":"#equipe","title":"Equipe","text":"<p>Equipe atual</p> <ul> <li> Michel Fornaciali Professor</li> <li> L\u00edcia Sales Prof. Auxiliar</li> <li> Tiago Demay T\u00e9cnico do lab.</li> </ul>"},{"location":"index_old/","title":"SuperComputa\u00e7\u00e3o","text":"<p>Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2024/2 </p> <ul> <li> <p>Equipe: </p> <ul> <li>Michel Fornaciali</li> </ul> </li> <li> <p>Hor\u00e1rio das aulas:</p> <ul> <li>Turma 1 - Ter\u00e7a - 09h45, Sexta - 13h30</li> <li>Turma 2 - Quarta - 13h30, Sexta - 07h30</li> </ul> </li> </ul>"},{"location":"index_old/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos:</p> <ul> <li>Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova;</li> <li>O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. </li> </ul> <p>A m\u00e9dia final \u00e9 dada por </p> <ul> <li>55% Projeto</li> <li>45% m\u00e9dia de Provas</li> </ul> <p>Condi\u00e7\u00f5es de barreira</p> <ul> <li>M\u00e9dia de provas &gt;= 4,5</li> <li>PI, PF &gt;= 4,0</li> <li>Projeto &gt;= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados)</li> </ul> <p>Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01</p> <p>Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.</p>"},{"location":"sobre/","title":"Burocracias","text":"<ul> <li>Hor\u00e1rios: <ul> <li>Turma A - Prof. Andr\u00e9 Filipe:  Quarta - 13h30, Sexta - 07h30</li> <li>Turma B - Prof. Luciano Silva:  Ter\u00e7a - 09h45, Sexta - 13h30</li> </ul> </li> </ul> Plano de aulas - Turma A Data Quest\u00e3o/Problema Conte\u00fado/Atividade 08/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 10/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 15/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 17/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 24/02/23 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 01/03/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 03/03/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 08/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 15/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 17/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 22/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 29/03/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 31/03/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 05/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 12/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 14/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 19/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 26/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 28/04/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 03/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 05/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 10/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 12/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 17/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 19/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 24/05/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/06/23 Prova Final Prova Final 07/06/23 Prova Final Prova Final Plano de aulas - Turma B Data Quest\u00e3o/Problema Conte\u00fado/Atividade 07/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 10/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 14/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 17/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 24/02/23 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 28/02/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 03/03/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 07/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 14/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 17/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 21/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 31/03/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 04/04/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 11/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 14/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 18/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 25/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 28/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 02/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 05/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 10/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 12/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 17/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 19/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 23/05/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/06/23 Prova Final Prova Final 07/06/23 Prova Final Prova Final"},{"location":"Teoria/","title":"Materiais e Guias para estudo","text":"<p>Material Te\u00f3rico para estudo</p> <p>Contextualizando HPC</p> <p>Cluster Franky</p> <p>SLURM</p> <p>Conceitos B\u00e1sicos de HW</p> <p>Conceitos B\u00e1sicos de C++</p> <p>Como compilar e executar c\u00f3digos em C++</p> <p>Loops e La\u00e7os</p> <p>Passagens de par\u00e2metros (por refer\u00eancia, por ponteiro)</p> <p>Const Correctness em HPC</p> <p>Aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica</p> <p>Sobrecarga de fun\u00e7\u00f5es C++</p> <p>Classes e Objetos</p> <p>Manipula\u00e7\u00e3o de Vetores</p> <p>Flags de compila\u00e7\u00e3o</p> <p>Profiling</p>"},{"location":"Teoria/classes-e-objetos/","title":"Classes e objetos","text":"<p>Uma classe em C++ \u00e9 uma estrutura que define um conjunto de atributos (dados) e m\u00e9todos (fun\u00e7\u00f5es) que operam sobre esses dados. \u00c9 uma forma de agrupar dados e comportamentos relacionados, facilitando a modularidade e a reutiliza\u00e7\u00e3o do c\u00f3digo. Objetos s\u00e3o inst\u00e2ncias de classes. Eles representam entidades espec\u00edficas que possuem os atributos e m\u00e9todos definidos pela classe.</p>"},{"location":"Teoria/classes-e-objetos/#exemplo-pratico-problema-da-mochila","title":"Exemplo Pr\u00e1tico: Problema da Mochila","text":"<p>No exemplo do problema da mochila, criamos uma classe <code>Knapsack</code> para encapsular a l\u00f3gica do problema. Vamos detalhar cada parte do c\u00f3digo para entender como classes e objetos s\u00e3o utilizados.</p>"},{"location":"Teoria/classes-e-objetos/#declaracao-da-classe","title":"Declara\u00e7\u00e3o da Classe","text":"<p>A classe <code>Knapsack</code> \u00e9 definida com atributos e m\u00e9todos necess\u00e1rios para resolver o problema da mochila.</p> <pre><code>#include &lt;iostream&gt;\n\n// Declara\u00e7\u00e3o da classe Knapsack\nclass Knapsack {\npublic:\n    Knapsack(int capacidade, int numItens);       // Construtor que inicializa a mochila\n    ~Knapsack();                                  // Destrutor que libera a mem\u00f3ria alocada\n    void adicionaItem(int peso, int valor);       // M\u00e9todo para adicionar um item\n    int resolve();                                // M\u00e9todo para resolver o problema da mochila\n    void imprimeItens();                          // M\u00e9todo para imprimir os itens adicionados\n\nprivate:\n    int capacidade;                               // Capacidade m\u00e1xima da mochila\n    int numItens;                                 // N\u00famero total de itens\n    int* pesos;                                   // Vetor din\u00e2mico para armazenar os pesos dos itens\n    int* valores;                                 // Vetor din\u00e2mico para armazenar os valores dos itens\n    int contadorItens;                            // Contador de itens adicionados\n};\n</code></pre> <ul> <li>Atributos:<ul> <li><code>capacidade</code>: Capacidade m\u00e1xima da mochila.</li> <li><code>numItens</code>: N\u00famero total de itens.</li> <li><code>pesos</code>: Ponteiro para um vetor que armazena os pesos dos itens.</li> <li><code>valores</code>: Ponteiro para um vetor que armazena os valores dos itens.</li> <li><code>contadorItens</code>: Contador para acompanhar quantos itens foram adicionados.</li> </ul> </li> <li>M\u00e9todos:<ul> <li><code>Knapsack(int capacidade, int numItens)</code>: Construtor que inicializa os atributos e aloca mem\u00f3ria para os vetores.</li> <li><code>~Knapsack()</code>: Destrutor que libera a mem\u00f3ria alocada para os vetores.</li> <li><code>void adicionaItem(int peso, int valor)</code>: M\u00e9todo para adicionar um item \u00e0 mochila.</li> <li><code>int resolve()</code>: M\u00e9todo para resolver o problema da mochila usando programa\u00e7\u00e3o din\u00e2mica.</li> <li><code>void imprimeItens()</code>: M\u00e9todo para imprimir os itens adicionados \u00e0 mochila.</li> </ul> </li> </ul>"},{"location":"Teoria/classes-e-objetos/#implementacao-do-construtor-e-destrutor","title":"Implementa\u00e7\u00e3o do Construtor e Destrutor","text":"<p>O construtor inicializa os atributos e aloca mem\u00f3ria para os vetores de pesos e valores. O destrutor libera essa mem\u00f3ria.</p> <pre><code>// Implementa\u00e7\u00e3o do construtor\nKnapsack::Knapsack(int capacidade, int numItens)\n    : capacidade(capacidade), numItens(numItens), contadorItens(0) {\n    pesos = new int[numItens];                    // Aloca mem\u00f3ria para os pesos dos itens\n    valores = new int[numItens];                  // Aloca mem\u00f3ria para os valores dos itens\n}\n\n// Implementa\u00e7\u00e3o do destrutor\nKnapsack::~Knapsack() {\n    delete[] pesos;                               // Libera a mem\u00f3ria alocada para os pesos\n    delete[] valores;                             // Libera a mem\u00f3ria alocada para os valores\n}\n</code></pre>"},{"location":"Teoria/classes-e-objetos/#metodo-para-adicionar-itens","title":"M\u00e9todo para Adicionar Itens","text":"<p>O m\u00e9todo <code>adicionaItem</code> permite adicionar itens \u00e0 mochila, atualizando os vetores de pesos e valores.</p> <pre><code>// Implementa\u00e7\u00e3o do m\u00e9todo para adicionar um item\nvoid Knapsack::adicionaItem(int peso, int valor) {\n    if (contadorItens &lt; numItens) {\n        pesos[contadorItens] = peso;              // Adiciona o peso do item\n        valores[contadorItens] = valor;           // Adiciona o valor do item\n        contadorItens++;                          // Incrementa o contador de itens\n    } else {\n        std::cerr &lt;&lt; \"N\u00famero m\u00e1ximo de itens excedido!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"Teoria/classes-e-objetos/#metodo-para-resolver-o-problema-da-mochila","title":"M\u00e9todo para Resolver o Problema da Mochila","text":"<p>Programa\u00e7\u00e3o Din\u00e2mica (Dynamic Programming, DP) \u00e9 uma t\u00e9cnica de otimiza\u00e7\u00e3o usada para resolver problemas complexos dividindo-os em subproblemas mais simples. Ela \u00e9 especialmente eficaz para problemas que podem ser divididos em subproblemas menores, onde os resultados de subproblemas anteriores podem ser reutilizados para resolver subproblemas maiores.</p> <p>No problema da mochila, a programa\u00e7\u00e3o din\u00e2mica \u00e9 usada para encontrar a combina\u00e7\u00e3o de itens que maximiza o valor total sem exceder a capacidade da mochila. Construindo uma tabela que armazena os valores m\u00e1ximos poss\u00edveis para diferentes capacidades e conjuntos de itens.</p> <p>A tabela de DP (K) \u00e9 constru\u00edda de forma que cada entrada K[i][w] representa o valor m\u00e1ximo que pode ser obtido usando os primeiros i itens com uma capacidade m\u00e1xima de w.</p>"},{"location":"Teoria/classes-e-objetos/#metodo-resolve","title":"M\u00e9todo resolve","text":"<ol> <li> <p>Inicializa\u00e7\u00e3o da Tabela de DP:</p> <pre><code>int** K = new int*[numItens + 1];             // Aloca mem\u00f3ria para a tabela de DP\nfor (int i = 0; i &lt;= numItens; ++i) {\n    K[i] = new int[capacidade + 1];           // Aloca mem\u00f3ria para cada linha da tabela de DP\n}\n</code></pre> <ul> <li>Alocamos uma tabela <code>K</code> com <code>numItens + 1</code> linhas e <code>capacidade + 1</code> colunas. Cada entrada <code>K[i][w]</code> armazenar\u00e1 o valor m\u00e1ximo poss\u00edvel para a submochila com capacidade <code>w</code> usando os primeiros <code>i</code> itens.</li> <li>Preenchimento da Tabela de DP:</li> </ul> <pre><code>for (int i = 0; i &lt;= numItens; ++i) {\n    for (int w = 0; w &lt;= capacidade; ++w) {\n        if (i == 0 || w == 0) {\n            K[i][w] = 0;                      // Caso base: capacidade 0 ou nenhum item\n        } else if (pesos[i - 1] &lt;= w) {\n            // Escolhe o m\u00e1ximo entre incluir ou n\u00e3o o item atual\n            K[i][w] = std::max(valores[i - 1] + K[i - 1][w - pesos[i - 1]], K[i - 1][w]);\n        } else {\n            K[i][w] = K[i - 1][w];            // N\u00e3o inclui o item atual\n        }\n    }\n}\n</code></pre> <ul> <li>Usamos um loop duplo para preencher a tabela.</li> <li>Caso Base: Se n\u00e3o h\u00e1 itens (<code>i == 0</code>) ou a capacidade \u00e9 zero (<code>w == 0</code>), o valor m\u00e1ximo \u00e9 0.</li> <li>Decis\u00e3o: Para cada item, verificamos se ele pode ser inclu\u00eddo na submochila (<code>pesos[i - 1] &lt;= w</code>). Se puder, escolhemos o m\u00e1ximo entre incluir o item (somando seu valor com o valor da submochila restante) e n\u00e3o inclu\u00ed-lo.</li> <li>Exclus\u00e3o do Item: Se o item n\u00e3o puder ser inclu\u00eddo, simplesmente copiamos o valor da submochila sem ele.</li> <li>Resultado Final:</li> </ul> <pre><code>int resultado = K[numItens][capacidade];      // Resultado final da DP\n</code></pre> <ul> <li>O valor m\u00e1ximo poss\u00edvel para a mochila completa \u00e9 encontrado em <code>K[numItens][capacidade]</code>.</li> <li>Libera\u00e7\u00e3o da Mem\u00f3ria:</li> </ul> <pre><code>for (int i = 0; i &lt;= numItens; ++i) {\n    delete[] K[i];                            // Libera mem\u00f3ria para cada linha\n}\ndelete[] K;                                   // Libera mem\u00f3ria para o vetor de ponteiros\n</code></pre> <ul> <li>Ap\u00f3s o c\u00e1lculo, liberamos a mem\u00f3ria alocada dinamicamente para a tabela <code>K</code>.</li> </ul> </li> </ol> <p>Neste contexto, a programa\u00e7\u00e3o din\u00e2mica (DP) \u00e9 usada para resolver o problema da mochila de maneira eficiente, evitando recomputa\u00e7\u00f5es de subproblemas ao armazenar os resultados intermedi\u00e1rios em uma tabela. A classe <code>Knapsack</code> encapsula a l\u00f3gica do problema, tornando o c\u00f3digo modular e f\u00e1cil de manter. A aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria permite a flexibilidade de lidar com diferentes tamanhos de problemas sem desperdi\u00e7ar mem\u00f3ria.</p>"},{"location":"Teoria/classes-e-objetos/#metodo-para-imprimir-itens","title":"M\u00e9todo para Imprimir Itens","text":"<p>O m\u00e9todo <code>imprimeItens</code> imprime os itens adicionados \u00e0 mochila.</p> <pre><code>// Implementa\u00e7\u00e3o do m\u00e9todo para imprimir os itens adicionados\nvoid Knapsack::imprimeItens() {\n    std::cout &lt;&lt; \"Itens adicionados (peso, valor):\" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; contadorItens; ++i) {\n        std::cout &lt;&lt; \"(\" &lt;&lt; pesos[i] &lt;&lt; \", \" &lt;&lt; valores[i] &lt;&lt; \")\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"Teoria/classes-e-objetos/#funcao-main","title":"Fun\u00e7\u00e3o <code>main</code>","text":"<p>A fun\u00e7\u00e3o <code>main</code> cria um objeto <code>Knapsack</code>, adiciona itens \u00e0 mochila, imprime os itens adicionados e resolve o problema da mochila.</p> <pre><code>int main() {\n    int capacidade = 50;                           // Capacidade da mochila\n    int numItens = 3;                              // N\u00famero de itens dispon\u00edveis\n\n    Knapsack mochila(capacidade, numItens);\n\n    mochila.adicionaItem(10, 60);                  // Adiciona item (peso, valor)\n    mochila.adicionaItem(20, 100);                 // Adiciona item (peso, valor)\n    mochila.adicionaItem(30, 120);                 // Adiciona item (peso, valor)\n\n    mochila.imprimeItens();                        // Imprime os itens adicionados\n\n    int valorMaximo = mochila.resolve();           // Resolve o problema da mochila\n\n    std::cout &lt;&lt; \"Valor m\u00e1ximo que pode ser levado: \" &lt;&lt; valorMaximo &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, a classe <code>Knapsack</code> encapsula todos os dados e m\u00e9todos necess\u00e1rios para resolver o problema da mochila. Usamos aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria para gerenciar os vetores de pesos, valores dos itens, e a tabela de programa\u00e7\u00e3o din\u00e2mica utilizada na solu\u00e7\u00e3o do problema.</p>"},{"location":"Teoria/comandos-ssh/","title":"Transfer\u00eancia de Arquivos entre sua m\u00e1quina e o Cluster Franky","text":"<p>O comando <code>scp</code> (Secure Copy Protocol) \u00e9 uma ferramenta segura e eficiente para transferir arquivos entre sua m\u00e1quina local e um servidor remoto, como o cluster Franky. Ele utiliza o protocolo SSH para realizar a transfer\u00eancia de arquivos, garantindo a seguran\u00e7a dos dados durante o processo.</p>"},{"location":"Teoria/comandos-ssh/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Antes de come\u00e7ar, certifique-se de que: - Voc\u00ea tenha acesso ao cluster Franky via SSH. - O comando <code>scp</code> esteja instalado em sua m\u00e1quina (a maioria dos sistemas operacionais baseados em Unix/Linux j\u00e1 possuem o <code>scp</code> por padr\u00e3o).</p>"},{"location":"Teoria/comandos-ssh/#transferindo-um-arquivo-da-sua-maquina-para-o-cluster-franky","title":"Transferindo um Arquivo da Sua M\u00e1quina para o Cluster Franky","text":"<p>Para transferir um arquivo do seu computador para o cluster Franky, voc\u00ea pode usar o seguinte comando:</p> <p><pre><code>scp /caminho/local/do/arquivo.txt usuario@ip_do_cluster:/caminho/remoto/destino/\n</code></pre> Este comando copia o arquivo <code>meu_arquivo.txt</code> do diret\u00f3rio local <code>/home/user/</code> para o diret\u00f3rio <code>/home/usuario/destino/</code> no cluster Franky.</p>"},{"location":"Teoria/comandos-ssh/#explicacao-dos-parametros","title":"Explica\u00e7\u00e3o dos Par\u00e2metros:","text":"<ul> <li><code>/caminho/local/do/arquivo.txt</code>: Caminho completo do arquivo na sua m\u00e1quina local que voc\u00ea deseja transferir.</li> <li><code>usuario@ip_do_cluster</code>: Seu nome de usu\u00e1rio e o endere\u00e7o de ip do cluster Franky.</li> <li><code>/caminho/remoto/destino/</code>: O diret\u00f3rio de destino no cluster Franky onde voc\u00ea deseja salvar o arquivo.</li> </ul>"},{"location":"Teoria/comandos-ssh/#transferindo-um-arquivo-do-cluster-franky-para-sua-maquina","title":"Transferindo um Arquivo do Cluster Franky para sua M\u00e1quina","text":"<p>Para copiar um arquivo do cluster Franky para a sua m\u00e1quina local, use o seguinte comando no seu terminal:</p> <p><pre><code>scp usuario@ip_do_cluster:/caminho/remoto/do/arquivo.txt /caminho/local/destino/\n</code></pre> Este comando copia o arquivo <code>arquivo_remoto.txt</code> do diret\u00f3rio <code>/home/usuario/</code> no cluster Franky para o diret\u00f3rio <code>/home/user/destino_local/</code> na sua m\u00e1quina.</p>"},{"location":"Teoria/comandos-ssh/#explicacao-dos-parametros_1","title":"Explica\u00e7\u00e3o dos Par\u00e2metros:","text":"<ul> <li><code>usuario@franky.cluster:/caminho/remoto/do/arquivo.txt</code>: O caminho completo do arquivo no cluster Franky que voc\u00ea deseja transferir para sua m\u00e1quina local.</li> <li> <p><code>/caminho/local/destino/</code>: O diret\u00f3rio de destino na sua m\u00e1quina local onde voc\u00ea deseja salvar o arquivo.</p> </li> <li> <p>Transfer\u00eancia Recursiva: Para transferir diret\u00f3rios inteiros (incluindo subdiret\u00f3rios e arquivos), use a op\u00e7\u00e3o <code>-r</code>:</p> </li> </ul> <pre><code>scp -r /caminho/local/do/diretorio/ usuario@ip_do_cluster:/caminho/remoto/destino/\n</code></pre> <p>O comando <code>scp</code> \u00e9 uma ferramenta poderosa para transferir arquivos entre sua m\u00e1quina e o cluster Franky de forma segura e eficiente. Com as instru\u00e7\u00f5es e exemplos fornecidos neste guia, voc\u00ea deve ser capaz de realizar transfer\u00eancias de arquivos com facilidade.</p>"},{"location":"Teoria/compilar-executar-C%2B%2B/","title":"Compilar/Executar C\u00f3digos C++","text":"<p>Pr\u00e9-requisitos:</p> <ul> <li>Visual Studio Code (VSCode) instalado</li> </ul>"},{"location":"Teoria/compilar-executar-C%2B%2B/#passos-para-windows","title":"Passos para Windows","text":"<ol> <li> <p>Instalar o Compilador Siga este tutorial</p> </li> <li> <p>Instalar Extens\u00f5es Necess\u00e1rias no VSCode:</p> <ul> <li>Abra o VSCode.</li> <li>V\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo).</li> <li>Pesquise e instale a extens\u00e3o:<ul> <li>C/C++ (Microsoft)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Teoria/compilar-executar-C%2B%2B/#passos-para-linux","title":"Passos para Linux","text":"<ol> <li> <p>Instalar o Compilador G++:</p> <ul> <li>N\u00e3o precisa, j\u00e1 vem instalado &lt;3</li> </ul> </li> <li> <p>Instalar Extens\u00f5es Necess\u00e1rias no VSCode:</p> <ul> <li>Abra o VSCode.</li> <li>V\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo).</li> <li>Pesquise e instale as seguintes extens\u00e3o:<ul> <li>C/C++ (Microsoft)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Teoria/compilar-executar-C%2B%2B/#passos-para-macos","title":"Passos para macOS","text":"<ol> <li> <p>Instalar o compilador:</p> <ul> <li>N\u00e3o precisa, j\u00e1 vem instalado &lt;3</li> <li>Mas se quiser saber mais detalhes sobre o Clang, sugiro este material</li> </ul> </li> <li> <p>Instalar Extens\u00f5es Necess\u00e1rias no VSCode:</p> <ul> <li>Abra o VSCode.</li> <li>V\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo).</li> <li>Pesquise e instale a extens\u00f5es:<ul> <li>C/C++ (Microsoft)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Teoria/compilar-executar-C%2B%2B/#compilando-um-exemplo-em-c-para-testar","title":"Compilando um Exemplo em C++ para Testar","text":"<p>Crie um arquivo <code>main.cpp</code> com o seguinte conte\u00fado:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/compilar-executar-C%2B%2B/#windows-compilar-e-executar","title":"Windows \u2192 Compilar e Executar","text":"<pre><code>g++ main.cpp -o main.exe\n./main.exe\n</code></pre>"},{"location":"Teoria/compilar-executar-C%2B%2B/#linux-compilar-e-executar","title":"Linux \u2192 Compilar e Executar:","text":"<pre><code>g++ main.cpp -o main\n./main\n</code></pre>"},{"location":"Teoria/compilar-executar-C%2B%2B/#macos-compilar-e-executar","title":"MacOS \u2192 Compilar e Executar","text":"<pre><code>clang++ main.cpp -o main\n./main\n</code></pre> <p>Seguindo esses passos, voc\u00ea deve ser capaz de compilar e executar programas C++ em Windows, Linux ou macOS usando o VSCode.</p>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/","title":"Conceitos b\u00e1sicos de C++","text":"<p>Esses s\u00e3o os tipos de vari\u00e1veis e seus respectivos tamanhos em C++ </p> Tipo de Dados Tamanho (em bytes) Valor M\u00ednimo Valor M\u00e1ximo bool 1 false true char 1 -128 127 unsigned char 1 0 255 short 2 -32,768 32,767 unsigned short 2 0 65,535 int 4 -2,147,483,648 2,147,483,647 unsigned int 4 0 4,294,967,295 long 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 unsigned long 8 0 18,446,744,073,709,551,615 float 4 1.2E-38 3.4E+38 double 8 2.3E-308 1.7E+308 long double 16 3.4E-4932 1.1E+4932 wchar_t 4 0 4,294,967,295  \u26a0\ufe0f Esses tamanhos podem variar dependendo da arquitetura do sistema. Esta tabela assume um sistema de 64 bits."},{"location":"Teoria/conceitos-basicos-C%2B%2B/#o-que-e-um-namespace","title":"O que \u00e9 um Namespace?","text":"<p>Um namespace \u00e9 uma forma de agrupar identificadores (nomes de fun\u00e7\u00f5es, classes, objetos, etc.) sob um nome comum, evitando conflitos de nome entre diferentes partes de um programa ou entre diferentes bibliotecas.</p>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/#exemplo-simples-de-namespace","title":"Exemplo Simples de Namespace","text":"<p>Imagine duas bibliotecas diferentes que ambas definem uma fun\u00e7\u00e3o chamada <code>print()</code>. Se voc\u00ea incluir ambas as bibliotecas em seu programa, o compilador n\u00e3o saber\u00e1 qual <code>print()</code> usar. Para resolver isso, cada biblioteca pode colocar sua fun\u00e7\u00e3o <code>print()</code> em seu pr\u00f3prio namespace:</p> <pre><code>// Biblioteca A\nnamespace A {\n    void print() {\n        std::cout &lt;&lt; \"Imprimindo da biblioteca A\" &lt;&lt; std::endl;\n    }\n}\n\n// Biblioteca B\nnamespace B {\n    void print() {\n        std::cout &lt;&lt; \"Imprimindo da biblioteca B\" &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n    A::print(); // Chama a fun\u00e7\u00e3o print() da biblioteca A\n    B::print(); // Chama a fun\u00e7\u00e3o print() da biblioteca B\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/#usando-namespaces","title":"Usando Namespaces","text":"<p>Existem v\u00e1rias maneiras de usar namespaces em C++:</p> <ol> <li> <p>Usar o nome completo do namespace (qualifica\u00e7\u00e3o total):</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; // Usa std::cout e std::endl\n    return 0;\n}\n</code></pre> </li> <li> <p>Usar a declara\u00e7\u00e3o <code>using</code> para trazer membros espec\u00edficos do namespace para o escopo atual:</p> <pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // Usa cout e endl sem o prefixo std::\n    return 0;\n}\n</code></pre> </li> <li> <p>Usar a diretiva <code>using</code> para trazer todos os membros do namespace para o escopo atual:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // Usa cout e endl sem o prefixo std::\n    return 0;\n}\n</code></pre> </li> </ol>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/#o-que-e-std","title":"O que \u00e9 <code>std</code>?","text":"<p><code>std</code> \u00e9 o namespace padr\u00e3o da biblioteca padr\u00e3o C++ (Standard Library). Ele cont\u00e9m a maior parte das fun\u00e7\u00f5es, objetos, tipos e classes fornecidos pela biblioteca padr\u00e3o do C++. Quando voc\u00ea usa recursos da biblioteca padr\u00e3o, como <code>std::vector</code>, <code>std::cout</code>, <code>std::string</code>, etc., voc\u00ea est\u00e1 acessando esses elementos do namespace <code>std</code>.</p> <p>Por exemplo:</p> <ul> <li><code>std::cout</code> \u00e9 o objeto de fluxo de sa\u00edda padr\u00e3o usado para imprimir dados na tela.</li> <li><code>std::vector</code> \u00e9 uma classe de cont\u00eainer que representa um array din\u00e2mico.</li> </ul>"},{"location":"Teoria/flags-compilacao/","title":"Flags de compila\u00e7\u00e3o (-O1, -O2, -O3, -Ofast).","text":"<p>As flags de compila\u00e7\u00e3o s\u00e3o op\u00e7\u00f5es fornecidas ao compilador para controlar o n\u00edvel de otimiza\u00e7\u00e3o aplicada ao c\u00f3digo durante o processo de compila\u00e7\u00e3o. Diferentes n\u00edveis de otimiza\u00e7\u00e3o podem influenciar o desempenho e o tamanho do c\u00f3digo resultante. Vamos explorar as principais flags de otimiza\u00e7\u00e3o usadas com o compilador GCC (GNU Compiler Collection): <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, e <code>-Ofast</code>.</p>"},{"location":"Teoria/flags-compilacao/#1-flag-o1","title":"1. Flag <code>O1</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel B\u00e1sico de Otimiza\u00e7\u00e3o: Aplica otimiza\u00e7\u00f5es que melhoram o desempenho do c\u00f3digo sem aumentar significativamente o tempo de compila\u00e7\u00e3o.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Remo\u00e7\u00e3o de c\u00f3digo morto.</li> <li>Simplifica\u00e7\u00e3o de express\u00f5es.</li> <li>Inlining b\u00e1sico de fun\u00e7\u00f5es.</li> </ul> <p>Quando Usar:</p> <ul> <li>Quando o tempo de compila\u00e7\u00e3o \u00e9 uma preocupa\u00e7\u00e3o, mas algum n\u00edvel de otimiza\u00e7\u00e3o \u00e9 desejado.</li> </ul> <pre><code>g++ -O1 -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#2-flag-o2","title":"2. Flag <code>O2</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel Moderado de Otimiza\u00e7\u00e3o: Aplica um conjunto mais agressivo de otimiza\u00e7\u00f5es que melhoram ainda mais o desempenho do c\u00f3digo.</li> <li>Maior tempo de compila\u00e7\u00e3o comparado ao <code>O1</code>, mas melhor desempenho do c\u00f3digo.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Inclui todas as otimiza\u00e7\u00f5es do <code>O1</code>.</li> <li>Otimiza\u00e7\u00f5es de loop (desenrolamento, fus\u00e3o de loops).</li> <li>Melhorias na aloca\u00e7\u00e3o de registradores.</li> <li>Otimiza\u00e7\u00f5es de fluxo de controle.</li> </ul> <p>Quando Usar:</p> <ul> <li>Para a maioria dos casos onde o desempenho \u00e9 mais cr\u00edtico do que o tempo de compila\u00e7\u00e3o.</li> <li>Quando se quer um bom desempenho na performance do c\u00f3digo.</li> </ul> <pre><code>g++ -O2 -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#3-flag-o3","title":"3. Flag <code>O3</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel Alto de Otimiza\u00e7\u00e3o: Aplica otimiza\u00e7\u00f5es muito agressivas que podem aumentar significativamente o tempo de compila\u00e7\u00e3o e o uso de mem\u00f3ria.</li> <li>Foco em maximizar o desempenho do c\u00f3digo, mesmo que isso aumente o tempo de compila\u00e7\u00e3o.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Inclui todas as otimiza\u00e7\u00f5es do <code>O2</code>.</li> <li>Inlining mais agressivo de fun\u00e7\u00f5es.</li> <li>Vetoriza\u00e7\u00e3o (uso de SIMD).</li> <li>Transforma\u00e7\u00f5es mais avan\u00e7adas de loop.</li> </ul> <p>Quando Usar:</p> <ul> <li>Quando o desempenho m\u00e1ximo do c\u00f3digo \u00e9 crucial e o tempo de compila\u00e7\u00e3o \u00e9 menos importante.</li> <li>Em aplica\u00e7\u00f5es onde cada gota de desempenho \u00e9 necess\u00e1ria.</li> </ul> <pre><code>g++ -O3 -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#4-flag-ofast","title":"4. Flag <code>Ofast</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel M\u00e1ximo de Otimiza\u00e7\u00e3o: Aplica todas as otimiza\u00e7\u00f5es do <code>O3</code> e desconsidera a conformidade estrita com os padr\u00f5es, o que pode levar a um desempenho ainda maior.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Inclui todas as otimiza\u00e7\u00f5es do <code>O3</code>.</li> <li>Otimiza\u00e7\u00f5es de matem\u00e1tica r\u00e1pida (por exemplo, assume que n\u00e3o h\u00e1 overflow de ponto flutuante).</li> <li>Desconsidera o padr\u00e3o IEEE para opera\u00e7\u00f5es de ponto flutuante.</li> </ul> <p>Quando Usar:</p> <ul> <li>Quando o desempenho \u00e9 a \u00fanica prioridade e a conformidade estrita com os padr\u00f5es n\u00e3o \u00e9 uma preocupa\u00e7\u00e3o.</li> <li>Em cen\u00e1rios de HPC onde a precis\u00e3o pode ser ligeiramente sacrificada por ganhos de desempenho.</li> </ul> <pre><code>g++ -Ofast -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-dos-niveis-de-otimizacao","title":"Compara\u00e7\u00e3o dos N\u00edveis de Otimiza\u00e7\u00e3o","text":"Flag Tempo de Compila\u00e7\u00e3o Desempenho Seguran\u00e7a e Conformidade -O1 Baixo Moderado Alta -O2 Moderado Alto Alta -O3 Alto Muito Alto Alta -Ofast Muito Alto M\u00e1ximo M\u00e9dia/Baixa <p>As flags de otimiza\u00e7\u00e3o s\u00e3o ferramentas poderosas que podem ajudar a melhorar significativamente o desempenho do seu c\u00f3digo C++. Entender como e quando us\u00e1-las \u00e9 essencial para aproveitar ao m\u00e1ximo os recursos de seu ambiente de compila\u00e7\u00e3o e execu\u00e7\u00e3o.</p>"},{"location":"Teoria/flags-compilacao/#exemplos-de-compilacao-com-diferentes-flags-de-otimizacao","title":"Exemplos de Compila\u00e7\u00e3o com Diferentes Flags de Otimiza\u00e7\u00e3o","text":"<p>Para demonstrar os efeitos das diferentes flags de otimiza\u00e7\u00e3o (<code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Ofast</code>) no desempenho de c\u00f3digos C++, vamos utilizar tr\u00eas exemplos representativos de HPC.</p>"},{"location":"Teoria/flags-compilacao/#exemplo-1-multiplicacao-de-matrizes","title":"Exemplo 1: Multiplica\u00e7\u00e3o de Matrizes","text":"<p>A multiplica\u00e7\u00e3o de matrizes \u00e9 uma opera\u00e7\u00e3o computacionalmente intensiva com muitas aplica\u00e7\u00f5es em HPC.</p>"},{"location":"Teoria/flags-compilacao/#codigo-base","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nvoid multiplyMatrices(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;double&gt;&gt;&amp; C, int N) {\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            C[i][j] = 0;\n            for (int k = 0; k &lt; N; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    const int N = 1000;\n    std::vector&lt;std::vector&lt;double&gt;&gt; A(N, std::vector&lt;double&gt;(N, 1.0));\n    std::vector&lt;std::vector&lt;double&gt;&gt; B(N, std::vector&lt;double&gt;(N, 1.0));\n    std::vector&lt;std::vector&lt;double&gt;&gt; C(N, std::vector&lt;double&gt;(N, 0.0));\n\n    auto start = std::chrono::high_resolution_clock::now();\n    multiplyMatrices(A, B, C, N);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    std::cout &lt;&lt; \"Duration: \" &lt;&lt; duration.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/flags-compilacao/#compilacao-e-execucao","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<ol> <li>Compila\u00e7\u00e3o com <code>O1</code>:</li> </ol> <pre><code>g++ -O1 -o matrix_multiplication_O1 matrix_multiplication.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O2</code>:</li> </ol> <pre><code>g++ -O2 -o matrix_multiplication_O2 matrix_multiplication.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O3</code>:</li> </ol> <pre><code>g++ -O3 -o matrix_multiplication_O3 matrix_multiplication.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>Ofast</code>:</li> </ol> <pre><code>g++ -Ofast -o matrix_multiplication_Ofast matrix_multiplication.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho","title":"Compara\u00e7\u00e3o de Desempenho","text":"<p>Execute cada vers\u00e3o do programa compilado e compare a dura\u00e7\u00e3o relatada:</p> <pre><code>time ./matrix_multiplication_O1\ntime ./matrix_multiplication_O2\ntime ./matrix_multiplication_O3\ntime ./matrix_multiplication_Ofast\n</code></pre>"},{"location":"Teoria/flags-compilacao/#explicando-o-output-do-time","title":"Explicando o Output do <code>time</code>","text":"<p>Quando voc\u00ea usa o comando <code>time</code> para medir o tempo de execu\u00e7\u00e3o de um programa, ele fornece tr\u00eas valores principais no output: real, user, e sys. Esses valores representam diferentes aspectos do tempo de execu\u00e7\u00e3o do programa.</p>"},{"location":"Teoria/flags-compilacao/#exemplo-de-output-do-time","title":"Exemplo de Output do <code>time</code>","text":"<pre><code>real    0m10.123s\nuser    0m8.456s\nsys     0m1.234s\n</code></pre>"},{"location":"Teoria/flags-compilacao/#o-que-cada-valor-representa","title":"O Que Cada Valor Representa","text":""},{"location":"Teoria/flags-compilacao/#1-real","title":"1. real","text":"<ul> <li>Tempo Real: Representa o tempo total que passou desde o in\u00edcio at\u00e9 o fim da execu\u00e7\u00e3o do comando. Esse valor inclui todo o tempo de espera do programa, como I/O (input/output), troca de contexto, e tempo de espera por recursos.</li> </ul> <p>Se voc\u00ea iniciar o programa e cronometra-lo com um cron\u00f4metro, o valor real \u00e9 o que voc\u00ea veria no cron\u00f4metro.</p> <p>Fatores que Afetam:</p> <ul> <li>Tempo gasto aguardando acesso ao disco.</li> <li>Tempo de espera na fila da CPU.</li> <li>Troca de contexto e outros tempos de espera.</li> </ul>"},{"location":"Teoria/flags-compilacao/#2-user","title":"2. user","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>Tempo de Usu\u00e1rio: Representa a quantidade de tempo que a CPU gastou executando o c\u00f3digo do programa em modo usu\u00e1rio. Esse tempo n\u00e3o inclui o tempo gasto em chamadas de sistema (system calls) ou o tempo gasto aguardando opera\u00e7\u00f5es de I/O.</li> </ul> <p>Medida de quanto tempo de CPU foi usado para executar as instru\u00e7\u00f5es do seu programa.</p> <p>Fatores que Afetam:</p> <ul> <li>Processamento computacional pesado.</li> <li>C\u00e1lculos matem\u00e1ticos e loops intensivos.</li> </ul>"},{"location":"Teoria/flags-compilacao/#3-sys","title":"3. sys","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>Tempo de Sistema: Representa a quantidade de tempo que a CPU gastou executando o c\u00f3digo do kernel em nome do seu programa. Isso inclui o tempo gasto em chamadas de sistema, como opera\u00e7\u00f5es de I/O, gerenciamento de mem\u00f3ria, e outras opera\u00e7\u00f5es de kernel.</li> </ul> <p>Tempo de CPU gasto para executar fun\u00e7\u00f5es de sistema solicitadas pelo seu programa.</p> <p>Fatores que Afetam:</p> <ul> <li>Opera\u00e7\u00f5es de leitura/escrita de disco.</li> <li>Opera\u00e7\u00f5es de rede.</li> <li>Aloca\u00e7\u00e3o e gerenciamento de mem\u00f3ria.</li> </ul>"},{"location":"Teoria/flags-compilacao/#interpretacao-do-output","title":"Interpreta\u00e7\u00e3o do Output","text":"<p>Vamos considerar novamente o exemplo de output:</p> <pre><code>real    0m10.123s\nuser    0m8.456s\nsys     0m1.234s\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <ul> <li>real (0m10.123s): O programa levou 10.123 segundos para ser executado do in\u00edcio ao fim. Isso inclui todo o tempo de espera.</li> <li>user (0m8.456s): A CPU gastou 8.456 segundos executando o c\u00f3digo do seu programa.</li> <li>sys (0m1.234s): A CPU gastou 1.234 segundos executando fun\u00e7\u00f5es do sistema em nome do seu programa.</li> </ul>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho-com-diferentes-flags-de-compilacao","title":"Compara\u00e7\u00e3o de Desempenho com Diferentes Flags de Compila\u00e7\u00e3o","text":"<p>Ao usar <code>time</code> para comparar programas compilados com diferentes flags de otimiza\u00e7\u00e3o (<code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Ofast</code>), voc\u00ea deve prestar aten\u00e7\u00e3o principalmente ao valor real para ver o impacto geral no tempo de execu\u00e7\u00e3o. No entanto, os valores user e sys tamb\u00e9m s\u00e3o importantes para entender como as otimiza\u00e7\u00f5es afetam o uso da CPU e o tempo gasto em opera\u00e7\u00f5es do sistema.</p>"},{"location":"Teoria/flags-compilacao/#_1","title":"Flags de compila\u00e7\u00e3o (-O1, -O2, -O3, -Ofast).","text":"<pre><code># Compila\u00e7\u00e3o com -O3\ng++ -O3 -o matrix_multiplication_O3 matrix_multiplication.cpp\n\n# Medi\u00e7\u00e3o de tempo de execu\u00e7\u00e3o\ntime ./matrix_multiplication_O3\n</code></pre> <p>Output esperado:</p> <pre><code>real    0m7.123s\nuser    0m6.789s\nsys     0m0.234s\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <ul> <li>real (0m7.123s): O tempo total de execu\u00e7\u00e3o foi de 7.123 segundos.</li> <li>user (0m6.789s): A CPU gastou 6.789 segundos executando o c\u00f3digo do programa.</li> <li>sys (0m0.234s): A CPU gastou 0.234 segundos em chamadas de sistema.</li> </ul> <p>Os valores fornecidos pelo comando <code>time</code> ajudam a entender o comportamento do seu programa e o impacto das otimiza\u00e7\u00f5es no desempenho geral. Analisar esses valores pode revelar gargalos e oportunidades de otimiza\u00e7\u00e3o adicional.</p>"},{"location":"Teoria/flags-compilacao/#exemplo-2-regressao-linear-ia","title":"Exemplo 2: Regress\u00e3o Linear (IA)","text":"<p>A regress\u00e3o linear \u00e9 um algoritmo b\u00e1sico de aprendizado de m\u00e1quina comumente usado em IA.</p>"},{"location":"Teoria/flags-compilacao/#codigo-base_1","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\ndouble linearRegression(const std::vector&lt;double&gt;&amp; X, const std::vector&lt;double&gt;&amp; Y) {\n    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n    int n = X.size();\n    for (int i = 0; i &lt; n; ++i) {\n        sumX += X[i];\n        sumY += Y[i];\n        sumXY += X[i] * Y[i];\n        sumX2 += X[i] * X[i];\n    }\n    return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n}\n\nint main() {\n    const int N = 1000000;\n    std::vector&lt;double&gt; X(N, 1.0);\n    std::vector&lt;double&gt; Y(N, 2.0);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    double slope = linearRegression(X, Y);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    std::cout &lt;&lt; \"Slope: \" &lt;&lt; slope &lt;&lt; \", Duration: \" &lt;&lt; duration.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/flags-compilacao/#compilacao-e-execucao_1","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<ol> <li>Compila\u00e7\u00e3o com <code>O1</code>:</li> </ol> <pre><code>g++ -O1 -o linear_regression_O1 linear_regression.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O2</code>:</li> </ol> <pre><code>g++ -O2 -o linear_regression_O2 linear_regression.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O3</code>:</li> </ol> <pre><code>g++ -O3 -o linear_regression_O3 linear_regression.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>Ofast</code>:</li> </ol> <pre><code>g++ -Ofast -o linear_regression_Ofast linear_regression.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho_1","title":"Compara\u00e7\u00e3o de Desempenho","text":"<p>Execute cada vers\u00e3o do programa compilado e compare a dura\u00e7\u00e3o relatada:</p> <pre><code>time ./linear_regression_O1\ntime ./linear_regression_O2\ntime ./linear_regression_O3\ntime ./linear_regression_Ofast\n</code></pre>"},{"location":"Teoria/flags-compilacao/#exemplo-3-processamento-de-grandes-conjuntos-de-dados-data-science","title":"Exemplo 3: Processamento de Grandes Conjuntos de Dados (Data Science)","text":"<p>Um exemplo comum em Data Science \u00e9 a normaliza\u00e7\u00e3o de um grande conjunto de dados.</p>"},{"location":"Teoria/flags-compilacao/#codigo-base_2","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n\nvoid normalize(std::vector&lt;double&gt;&amp; data) {\n    double mean = 0.0;\n    double stddev = 0.0;\n    int n = data.size();\n\n    for (int i = 0; i &lt; n; ++i) {\n        mean += data[i];\n    }\n    mean /= n;\n\n    for (int i = 0; i &lt; n; ++i) {\n        stddev += (data[i] - mean) * (data[i] - mean);\n    }\n    stddev = std::sqrt(stddev / n);\n\n    for (int i = 0; i &lt; n; ++i) {\n        data[i] = (data[i] - mean) / stddev;\n    }\n}\n\nint main() {\n    const int N = 10000000;\n    std::vector&lt;double&gt; data(N, 1.0);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    normalize(data);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    std::cout &lt;&lt; \"Duration: \" &lt;&lt; duration.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/flags-compilacao/#compilacao-e-execucao_2","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<ol> <li>Compila\u00e7\u00e3o com <code>O1</code>:</li> </ol> <pre><code>g++ -O1 -o normalize_O1 normalize.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O2</code>:</li> </ol> <pre><code>g++ -O2 -o normalize_O2 normalize.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O3</code>:</li> </ol> <pre><code>g++ -O3 -o normalize_O3 normalize.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>Ofast</code>:</li> </ol> <pre><code>g++ -Ofast -o normalize_Ofast normalize.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho_2","title":"Compara\u00e7\u00e3o de Desempenho","text":"<p>Execute cada vers\u00e3o do programa compilado e compare a dura\u00e7\u00e3o relatada:</p> <pre><code>time ./normalize_O1\ntime ./normalize_O2\ntime ./normalize_O3\ntime ./normalize_Ofast\n</code></pre> <p>Depois de compilar e executar os programas com diferentes flags de otimiza\u00e7\u00e3o, compare os tempos de execu\u00e7\u00e3o relatados por cada um. Isso ajudar\u00e1 a entender como diferentes n\u00edveis de otimiza\u00e7\u00e3o afetam o desempenho de opera\u00e7\u00f5es computacionalmente intensivas.</p>"},{"location":"Teoria/funcoes-inline/","title":"Fun\u00e7\u00f5es Inline","text":"<p>As fun\u00e7\u00f5es inline s\u00e3o usadas para reduzir a sobrecarga das chamadas de fun\u00e7\u00e3o, que pode ser significativa em programas de alto desempenho onde fun\u00e7\u00f5es s\u00e3o chamadas repetidamente. Em vez de realizar uma chamada de fun\u00e7\u00e3o, que envolve empilhar argumentos, saltar para a localiza\u00e7\u00e3o da fun\u00e7\u00e3o, executar a fun\u00e7\u00e3o, e ent\u00e3o retornar, o compilador substitui a chamada da fun\u00e7\u00e3o pelo pr\u00f3prio corpo da fun\u00e7\u00e3o. Isso pode resultar em um c\u00f3digo mais r\u00e1pido e eficiente.</p>"},{"location":"Teoria/funcoes-inline/#vantagens-de-usar-funcoes-inline","title":"Vantagens de Usar Fun\u00e7\u00f5es Inline","text":"<ol> <li>Redu\u00e7\u00e3o da Sobrecarga de Chamada de Fun\u00e7\u00e3o:<ul> <li>As chamadas de fun\u00e7\u00e3o envolvem opera\u00e7\u00f5es adicionais de empilhamento de argumentos e desvio de controle, que podem se tornar um gargalo se as fun\u00e7\u00f5es forem chamadas repetidamente.</li> <li>Fun\u00e7\u00f5es inline eliminam essa sobrecarga, substituindo a chamada pelo pr\u00f3prio c\u00f3digo da fun\u00e7\u00e3o.</li> </ul> </li> <li>Melhoria do Desempenho:<ul> <li>A execu\u00e7\u00e3o de fun\u00e7\u00f5es inline pode ser mais r\u00e1pida, especialmente em loops intensivos onde pequenas fun\u00e7\u00f5es s\u00e3o chamadas repetidamente.</li> <li>Pode resultar em otimiza\u00e7\u00f5es adicionais pelo compilador, como a elimina\u00e7\u00e3o de vari\u00e1veis tempor\u00e1rias e a fus\u00e3o de c\u00f3digo.</li> </ul> </li> <li>Efici\u00eancia do Cache:<ul> <li>Em alguns casos, a inser\u00e7\u00e3o de fun\u00e7\u00f5es inline pode melhorar a localidade de refer\u00eancia e a efici\u00eancia do cache, embora isso dependa da natureza do c\u00f3digo e do hardware.</li> </ul> </li> </ol>"},{"location":"Teoria/funcoes-inline/#contextos-ideais-para-aplicar-funcoes-inline","title":"Contextos Ideais para Aplicar Fun\u00e7\u00f5es Inline","text":"<ol> <li> <p>Fun\u00e7\u00f5es Pequenas e Simples:</p> <ul> <li>Fun\u00e7\u00f5es que s\u00e3o curtas e t\u00eam poucas opera\u00e7\u00f5es s\u00e3o ideais para serem inline. Por exemplo, fun\u00e7\u00f5es matem\u00e1ticas simples como <code>soma</code>, <code>subtrai</code>, <code>multiplica</code> ou <code>divide</code>.</li> </ul> <pre><code>inline int soma(int a, int b) {\n    return a + b;\n}\n</code></pre> </li> <li> <p>Fun\u00e7\u00f5es Chamadas Frequentemente:</p> <ul> <li>Fun\u00e7\u00f5es que s\u00e3o chamadas repetidamente em loops intensivos s\u00e3o boas candidatas para serem inline, pois a elimina\u00e7\u00e3o da sobrecarga da chamada de fun\u00e7\u00e3o pode ter um impacto significativo no desempenho.</li> </ul> <pre><code>inline int quadrado(int x) {\n    return x * x;\n}\n</code></pre> </li> <li> <p>Fun\u00e7\u00f5es que Acessam Membros de Classe:</p> <ul> <li>M\u00e9todos de classe que s\u00e3o simples e frequentemente chamados podem se beneficiar de serem inline. Em C++, m\u00e9todos definidos dentro da declara\u00e7\u00e3o de uma classe s\u00e3o implicitamente inline.</li> </ul> <pre><code>class Ponto {\npublic:\n    inline int getX() const { return x; }\n    inline int getY() const { return y; }\nprivate:\n    int x, y;\n};\n</code></pre> </li> </ol>"},{"location":"Teoria/funcoes-inline/#exemplo","title":"Exemplo","text":"<p>Vamos considerar um exemplo onde uma fun\u00e7\u00e3o inline \u00e9 usada para calcular o quadrado de um n\u00famero em um loop intensivo. Isso \u00e9 comum em opera\u00e7\u00f5es cient\u00edficas e de engenharia, onde c\u00e1lculos matem\u00e1ticos simples s\u00e3o realizados repetidamente.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Fun\u00e7\u00e3o inline para calcular o quadrado de um n\u00famero\ninline int quadrado(int x) {\n    return x * x;\n}\n\nint main() {\n    const int N = 1000000; // N\u00famero de elementos\n    vector&lt;int&gt; dados(N, 2); // Inicializa um vetor com N elementos, todos iguais a 2\n    vector&lt;int&gt; resultados(N);\n\n    auto inicio = high_resolution_clock::now();\n\n    // Loop intensivo que usa a fun\u00e7\u00e3o inline\n    for (int i = 0; i &lt; N; ++i) {\n        resultados[i] = quadrado(dados[i]);\n    }\n\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Tempo para calcular quadrados: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes-inline/#consideracoes-ao-usar-funcoes-inline","title":"Considera\u00e7\u00f5es ao Usar Fun\u00e7\u00f5es Inline","text":"<ol> <li>Tamanho da Fun\u00e7\u00e3o:<ul> <li>Fun\u00e7\u00f5es inline devem ser pequenas e simples. Fun\u00e7\u00f5es grandes inline podem aumentar significativamente o tamanho do c\u00f3digo bin\u00e1rio, o que pode ter um efeito negativo na efici\u00eancia do cache.</li> </ul> </li> <li>Otimiza\u00e7\u00f5es do Compilador:<ul> <li>O compilador pode ignorar a sugest\u00e3o de inline se achar que n\u00e3o ser\u00e1 ben\u00e9fico. Isso \u00e9 apenas uma sugest\u00e3o ao compilador.</li> </ul> </li> <li>Manutenibilidade:<ul> <li>Excesso de fun\u00e7\u00f5es inline pode tornar o c\u00f3digo mais dif\u00edcil de ler e manter. Use inline judiciosamente, apenas onde os benef\u00edcios de desempenho s\u00e3o claros.</li> </ul> </li> </ol> <p>As fun\u00e7\u00f5es inline s\u00e3o uma ferramenta valiosa em High-Performance Computing para reduzir a sobrecarga de chamadas de fun\u00e7\u00e3o e melhorar o desempenho em loops intensivos e c\u00e1lculos repetitivos. Elas devem ser usadas em fun\u00e7\u00f5es pequenas e frequentemente chamadas para obter os maiores benef\u00edcios. Ao combinar fun\u00e7\u00f5es inline com a sobrecarga de fun\u00e7\u00f5es, podemos otimizar ainda mais o c\u00f3digo para diferentes tipos de dados, mantendo a legibilidade e a organiza\u00e7\u00e3o.</p>"},{"location":"Teoria/funcoes/","title":"Passagem de Par\u00e2metros","text":"<p>Par\u00e2metros podem ser passados por valor, por refer\u00eancia ou por ponteiro. No contexto de HPC, passar par\u00e2metros por refer\u00eancia ou ponteiro \u00e9 geralmente prefer\u00edvel para evitar c\u00f3pias desnecess\u00e1rias de dados, que podem ser custosas em termos de tempo e mem\u00f3ria.</p>"},{"location":"Teoria/funcoes/#passagem-de-parametros-por-valor","title":"Passagem de Par\u00e2metros por Valor","text":"<p>Passar por valor significa que uma c\u00f3pia do argumento \u00e9 passada para a fun\u00e7\u00e3o. Qualquer modifica\u00e7\u00e3o feita ao par\u00e2metro dentro da fun\u00e7\u00e3o n\u00e3o afeta o argumento original.</p> <pre><code>// Fun\u00e7\u00e3o que recebe um par\u00e2metro por valor\nvoid exemploValor(int x) {\n    x = 10; // Modifica\u00e7\u00e3o local, n\u00e3o afeta o argumento original\n}\n</code></pre>"},{"location":"Teoria/funcoes/#passagem-por-referencia-e-passagem-por-ponteiro","title":"Passagem por Refer\u00eancia e Passagem por Ponteiro","text":"<p>Passagem por refer\u00eancia e passagem por ponteiro s\u00e3o duas formas de passar argumentos para fun\u00e7\u00f5es em C++, permitindo que a fun\u00e7\u00e3o modifique o argumento original. Apesar de terem prop\u00f3sitos similares, elas diferem em sintaxe e uso. Vamos explorar essas diferen\u00e7as detalhadamente.</p>"},{"location":"Teoria/funcoes/#passagem-por-referencia","title":"Passagem por Refer\u00eancia","text":"<p>Passar um argumento por refer\u00eancia significa que a fun\u00e7\u00e3o recebe uma refer\u00eancia ao argumento original, permitindo modificar diretamente o valor do argumento. A sintaxe usa o operador <code>&amp;</code> no par\u00e2metro da fun\u00e7\u00e3o.</p>"},{"location":"Teoria/funcoes/#sintaxe-e-exemplo","title":"Sintaxe e Exemplo","text":"<pre><code>#include &lt;iostream&gt;\n\n// Fun\u00e7\u00e3o que recebe um par\u00e2metro por refer\u00eancia\nvoid alteraPorReferencia(int&amp; x) {\n    x = 10; // Modifica\u00e7\u00e3o afeta o argumento original\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    alteraPorReferencia(valor);\n    std::cout &lt;&lt; \"Depois da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Sintaxe Limpa: A sintaxe \u00e9 mais clara e f\u00e1cil de ler, pois n\u00e3o envolve o uso expl\u00edcito de ponteiros.</li> <li>Seguran\u00e7a: Reduz o risco de manipula\u00e7\u00e3o incorreta de ponteiros (como desreferenciamento de ponteiros nulos).</li> <li>N\u00e3o Nulo: Refer\u00eancias devem ser inicializadas e n\u00e3o podem ser nulas.</li> </ul>"},{"location":"Teoria/funcoes/#passagem-por-ponteiro","title":"Passagem por Ponteiro","text":"<p>Passar um argumento por ponteiro significa que a fun\u00e7\u00e3o recebe o endere\u00e7o do argumento original. A sintaxe usa o operador <code>*</code> no par\u00e2metro da fun\u00e7\u00e3o e o operador <code>&amp;</code> ao passar o argumento.</p>"},{"location":"Teoria/funcoes/#sintaxe-e-exemplo_1","title":"Sintaxe e Exemplo","text":"<pre><code>#include &lt;iostream&gt;\n\n// Fun\u00e7\u00e3o que recebe um par\u00e2metro por ponteiro\nvoid alteraPorPonteiro(int* x) {\n    *x = 10; // Modifica\u00e7\u00e3o afeta o argumento original\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    alteraPorPonteiro(&amp;valor);\n    std::cout &lt;&lt; \"Depois da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes/#caracteristicas_1","title":"Caracter\u00edsticas","text":"<ul> <li>Flexibilidade: Permite a passagem de valores nulos (ponteiros nulos).</li> <li>Controle Expl\u00edcito: Fornece controle expl\u00edcito sobre a mem\u00f3ria, podendo ser \u00fatil em contextos onde manipula\u00e7\u00e3o direta de endere\u00e7os \u00e9 necess\u00e1ria.</li> <li>Complexidade: A sintaxe pode ser mais complexa e propensa a erros, como desreferenciamento de ponteiros nulos ou incorretos.</li> </ul>"},{"location":"Teoria/funcoes/#quando-usar-cada-um","title":"Quando Usar Cada Um","text":"<ul> <li>Passagem por Refer\u00eancia: Use quando voc\u00ea precisa modificar o argumento original e quer uma sintaxe mais limpa e segura. Ideal para a maioria dos casos onde a refer\u00eancia n\u00e3o precisa ser nula.</li> <li>Passagem por Ponteiro: Use quando h\u00e1 a necessidade de manipular diretamente endere\u00e7os de mem\u00f3ria ou quando o valor passado pode ser opcional (nulo).</li> </ul>"},{"location":"Teoria/funcoes/#exemplo-comparativo","title":"Exemplo Comparativo","text":"<p>Vamos comparar um exemplo onde modificamos um valor usando ambas as abordagens.</p>"},{"location":"Teoria/funcoes/#passagem-por-referencia_1","title":"Passagem por Refer\u00eancia","text":"<pre><code>#include &lt;iostream&gt;\n\nvoid incrementaReferencia(int&amp; x) {\n    x++; // Incrementa o valor\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes: \" &lt;&lt; valor &lt;&lt; std::endl;\n    incrementaReferencia(valor);\n    std::cout &lt;&lt; \"Depois: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes/#passagem-por-ponteiro_1","title":"Passagem por Ponteiro","text":"<pre><code>#include &lt;iostream&gt;\n\nvoid incrementaPonteiro(int* x) {\n    if (x) { // Verifica se o ponteiro n\u00e3o \u00e9 nulo\n        (*x)++; // Incrementa o valor\n    }\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes: \" &lt;&lt; valor &lt;&lt; std::endl;\n    incrementaPonteiro(&amp;valor);\n    std::cout &lt;&lt; \"Depois: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Ambos os exemplos acima modificam o valor original de <code>valor</code>, mas a abordagem de refer\u00eancia \u00e9 mais limpa, enquanto a abordagem de ponteiro oferece maior flexibilidade em termos de manipula\u00e7\u00e3o de endere\u00e7os e valores nulos.</p>"},{"location":"Teoria/loops-e-la%C3%A7os/","title":"Loops  e La\u00e7os","text":"<p>No contexto de HPC, onde a efici\u00eancia e a performance s\u00e3o cruciais, as estruturas de controle (loops e la\u00e7os) desempenham pap\u00e9is vitais:</p> <ol> <li>Otimiza\u00e7\u00e3o de Algoritmos<ul> <li>As estruturas de controle permitem que algoritmos sejam implementados de forma eficiente. Condicionais e loops bem utilizados podem reduzir o n\u00famero de opera\u00e7\u00f5es e evitar c\u00e1lculos desnecess\u00e1rios, otimizando o tempo de execu\u00e7\u00e3o.</li> </ul> </li> <li>Paralelismo<ul> <li>Em HPC, o paralelismo \u00e9 frequentemente utilizado para acelerar a execu\u00e7\u00e3o dos programas. Estruturas de controle s\u00e3o essenciais para dividir tarefas entre diferentes threads ou processos.</li> <li>O uso adequado de condicionais pode garantir que as tarefas sejam distribu\u00eddas eficientemente entre os recursos computacionais, evitando sobrecarga em um \u00fanico n\u00f3 de processamento.</li> </ul> </li> <li>Balanceamento de Carga<ul> <li>Estruturas de controle podem ajudar no balanceamento de carga, distribuindo o trabalho de maneira uniforme entre os processadores. Por exemplo, condicionais podem ser usados para verificar a carga de trabalho em diferentes n\u00f3s e ajustar dinamicamente a distribui\u00e7\u00e3o das tarefas.</li> <li>Isso \u00e9 crucial para evitar situa\u00e7\u00f5es onde alguns processadores ficam ociosos enquanto outros est\u00e3o sobrecarregados, maximizando a utiliza\u00e7\u00e3o de recursos e melhorando a performance geral.</li> </ul> </li> <li>Gerenciamento de Recursos<ul> <li>Condicionais e loops podem ser usados para gerenciar recursos, como aloca\u00e7\u00e3o de mem\u00f3ria e acesso a dispositivos de I/O. Em ambientes HPC, onde grandes volumes de dados s\u00e3o manipulados, o gerenciamento eficiente de mem\u00f3ria \u00e9 fundamental. Estruturas de controle podem ajudar a evitar desperd\u00edcio de mem\u00f3ria e garantir que os recursos sejam utilizados de maneira eficiente.</li> </ul> </li> </ol>"},{"location":"Teoria/loops-e-la%C3%A7os/#estruturas-de-controle-condicionais-if-else-if-else","title":"Estruturas de controle condicionais (<code>if</code>, <code>else if</code>, <code>else</code> ):","text":"<p>Exemplo: Encontrar o valor m\u00e1ximo em uma matriz</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Define a vari\u00e1vel max_value com o primeiro valor da matriz\n    int max_value = matrix[0][0];\n\n    // Percorre cada linha da matriz\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Percorre cada coluna da matriz\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Se o valor atual da matriz for maior que max_value, atualiza max_value\n            if (matrix[i][j] &gt; max_value) {\n                max_value = matrix[i][j];\n            }\n        }\n    }\n\n    // Imprime o valor m\u00e1ximo encontrado na matriz\n    std::cout &lt;&lt; \"O valor m\u00e1ximo na matriz \u00e9: \" &lt;&lt; max_value &lt;&lt; std::endl;\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-condicional-switch","title":"Estrutura de controle condicional <code>switch</code> :","text":"<p>Exemplo: Imprimir a posi\u00e7\u00e3o de um n\u00famero espec\u00edfico na matriz</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Define o valor alvo a ser encontrado\n    int target = 5;\n\n    // Percorre cada linha da matriz\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Percorre cada coluna da matriz\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Verifica o valor atual da matriz usando switch\n            switch(matrix[i][j]) {\n                case 5:\n                    // Se o valor for 5, imprime a posi\u00e7\u00e3o e sai do switch\n                    std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" encontrado em: (\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \")\" &lt;&lt; std::endl;\n                    break;\n                default:\n                    // Caso padr\u00e3o do switch, n\u00e3o faz nada\n                    break;\n            }\n        }\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-loop-for","title":"Estrutura de controle loop <code>for</code> :","text":"<p>Exemplo Somar todos os elementos de uma matriz :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Inicializa a vari\u00e1vel sum com 0\n    int sum = 0;\n\n    // Percorre cada linha da matriz\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Percorre cada coluna da matriz\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Adiciona o valor atual da matriz \u00e0 sum\n            sum += matrix[i][j];\n        }\n    }\n\n    // Imprime a soma de todos os elementos na matriz\n    std::cout &lt;&lt; \"A soma de todos os elementos na matriz \u00e9: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-loop-while","title":"Estrutura de controle loop <code>while</code> :","text":"<p>Encontrar um n\u00famero espec\u00edfico na matriz </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Define o valor alvo a ser encontrado\n    int target = 5;\n    bool found = false; // Flag para indicar se o valor foi encontrado\n    size_t i = 0; // \u00cdndice para as linhas\n\n    // Loop externo para percorrer as linhas\n    while (i &lt; matrix.size() &amp;&amp; !found) {\n        size_t j = 0; // \u00cdndice para as colunas\n        // Loop interno para percorrer as colunas\n        while (j &lt; matrix[i].size() &amp;&amp; !found) {\n            // Se o valor atual da matriz for igual ao alvo, imprime a posi\u00e7\u00e3o\n            if (matrix[i][j] == target) {\n                std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" encontrado em: (\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \")\" &lt;&lt; std::endl;\n                found = true; // Atualiza a flag\n            }\n            ++j; // Incrementa o \u00edndice das colunas\n        }\n        ++i; // Incrementa o \u00edndice das linhas\n    }\n\n    // Se o valor n\u00e3o foi encontrado, imprime uma mensagem\n    if (!found) {\n        std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" n\u00e3o encontrado na matriz.\" &lt;&lt; std::endl;\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-loop-do-while","title":"Estrutura de controle loop <code>do-while</code> :","text":"<p>Verificar se todos os elementos da matriz s\u00e3o positivos </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    bool all_positive = true; // Flag para indicar se todos os elementos s\u00e3o positivos\n    size_t i = 0; // \u00cdndice para as linhas\n\n    // Loop externo do-while para percorrer as linhas\n    do {\n        size_t j = 0; // \u00cdndice para as colunas\n        // Loop interno do-while para percorrer as colunas\n        do {\n            // Se o valor atual da matriz for menor ou igual a 0, atualiza a flag e sai do loop\n            if (matrix[i][j] &lt;= 0) {\n                all_positive = false;\n                break;\n            }\n            ++j; // Incrementa o \u00edndice das colunas\n        } while (j &lt; matrix[i].size());\n        ++i; // Incrementa o \u00edndice das linhas\n    } while (i &lt; matrix.size() &amp;&amp; all_positive);\n\n    // Imprime o resultado da verifica\u00e7\u00e3o\n    if (all_positive) {\n        std::cout &lt;&lt; \"Todos os elementos da matriz s\u00e3o positivos.\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Nem todos os elementos da matriz s\u00e3o positivos.\" &lt;&lt; std::endl;\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#controladores-de-loop-break","title":"Controladores de loop <code>break</code> :","text":"<p>Interromper a busca ao encontrar um n\u00famero espec\u00edfico (<code>break</code>)</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    int target = 5; // Define o valor alvo a ser encontrado\n    bool found = false; // Flag para indicar se o valor foi encontrado\n\n    // Loop externo para percorrer as linhas\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Loop interno para percorrer as colunas\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Se o valor atual da matriz for igual ao alvo, imprime a posi\u00e7\u00e3o\n            if (matrix[i][j] == target) {\n                std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" encontrado em: (\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \")\" &lt;&lt; std::endl;\n                found = true; // Atualiza a flag\n                break; // Interrompe o loop interno\n            }\n        }\n        if (found) {\n            break; // Interrompe o loop externo\n        }\n    }\n\n    // Se o valor n\u00e3o foi encontrado, imprime uma mensagem\n    if (!found) {\n        std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" n\u00e3o encontrado na matriz.\" &lt;&lt; std::endl;\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#controladores-de-loop-continue","title":"Controladores de loop continue :","text":"<p>Ignorar n\u00fameros negativos ao somar elementos de uma matriz (<code>continue</code>)</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros, incluindo n\u00fameros negativos\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, -2, 3},\n        {-4, 5, -6},\n        {7, -8, 9}\n    };\n\n    int sum = 0; // Inicializa a vari\u00e1vel sum com 0\n\n    // Loop externo para percorrer as linhas\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Loop interno para percorrer as colunas\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Se o valor atual da matriz for negativo, ignora-o e continua para a pr\u00f3xima itera\u00e7\u00e3o\n            if (matrix[i][j] &lt; 0) {\n                continue; // Ignora n\u00fameros negativos\n            }\n            // Adiciona o valor atual da matriz \u00e0 soma\n            sum += matrix[i][j];\n        }\n    }\n\n    // Imprime a soma de todos os elementos positivos na matriz\n    std::cout &lt;&lt; \"A soma de todos os elementos positivos na matriz \u00e9: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/","title":"Manipula\u00e7\u00e3o de Vetores","text":"<p>Manipula\u00e7\u00e3o b\u00e1sica de vetores em C++ envolve opera\u00e7\u00f5es comuns como inicializa\u00e7\u00e3o, acesso a elementos, modifica\u00e7\u00e3o, itera\u00e7\u00e3o, inser\u00e7\u00e3o, remo\u00e7\u00e3o, e c\u00f3pia de vetores. Esses conceitos s\u00e3o fundamentais, pois constituem a base para a manipula\u00e7\u00e3o de dados em grande escala.</p>"},{"location":"Teoria/manipulacao-vetores/#inicializacao-de-vetores-declaracao-e-inicializacao","title":"Inicializa\u00e7\u00e3o de Vetores \u2192 Declara\u00e7\u00e3o e Inicializa\u00e7\u00e3o","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec1;                // Declara um vetor vazio de inteiros\n    std::vector&lt;int&gt; vec2(10);            // Declara um vetor de 10 inteiros inicializados com zero\n    std::vector&lt;int&gt; vec3(10, 5);         // Declara um vetor de 10 inteiros, todos inicializados com 5\n\n    // Exemplo de inicializa\u00e7\u00e3o de vetor com valores espec\u00edficos\n    std::vector&lt;int&gt; vec4 = {1, 2, 3, 4, 5};\n\n    // Imprime os elementos do vetor vec4\n    for (int val : vec4) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#acesso-e-modificacao-de-elementos","title":"Acesso e Modifica\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Acessa elementos usando o operador []\n    std::cout &lt;&lt; \"Primeiro elemento: \" &lt;&lt; vec[0] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Terceiro elemento: \" &lt;&lt; vec[2] &lt;&lt; std::endl;\n\n    // Acessa elementos usando o m\u00e9todo at()\n    std::cout &lt;&lt; \"Segundo elemento: \" &lt;&lt; vec.at(1) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#modificacao-de-elementos","title":"Modifica\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Modifica elementos usando o operador []\n    vec[0] = 10;\n    vec[2] = 30;\n\n    // Modifica elementos usando o m\u00e9todo at()\n    vec.at(1) = 20;\n\n    // Imprime os elementos modificados\n    for (int val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#iteracao-usando-loop","title":"Itera\u00e7\u00e3o Usando Loop","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Itera sobre os elementos usando um loop tradicional\n    for (size_t i = 0; i &lt; vec.size(); ++i) {\n        std::cout &lt;&lt; vec[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#insercao-de-elementos","title":"Inser\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Insere elementos no final do vetor\n    vec.push_back(6);\n    vec.push_back(7);\n\n    // Insere um elemento na posi\u00e7\u00e3o espec\u00edfica\n    vec.insert(vec.begin() + 2, 10); // Insere o valor 10 na terceira posi\u00e7\u00e3o\n\n    // Imprime os elementos ap\u00f3s a inser\u00e7\u00e3o\n    for (int val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#remocao-de-elementos","title":"Remo\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Remove o \u00faltimo elemento\n    vec.pop_back();\n\n    // Remove um elemento na posi\u00e7\u00e3o espec\u00edfica\n    vec.erase(vec.begin() + 1); // Remove o segundo elemento\n\n    // Imprime os elementos ap\u00f3s a remo\u00e7\u00e3o\n    for (int val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#copiando-vetores","title":"Copiando Vetores","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec1 = {1, 2, 3, 4, 5};\n\n    // Cria uma c\u00f3pia de vec1\n    std::vector&lt;int&gt; vec2 = vec1;\n\n    // Modifica a c\u00f3pia\n    vec2[0] = 10;\n\n    // Imprime os elementos dos dois vetores\n    std::cout &lt;&lt; \"vec1: \";\n    for (int val : vec1) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"vec2: \";\n    for (int val : vec2) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#contextos-uteis-para-hpc","title":"Contextos \u00dateis para HPC","text":"<p>Manipula\u00e7\u00f5es b\u00e1sicas de vetores s\u00e3o frequentemente utilizadas em HPC para inicializar e processar grandes conjuntos de dados. Aqui est\u00e3o alguns contextos \u00fateis:</p> <ol> <li>Inicializa\u00e7\u00e3o de Dados:<ul> <li>Vetores podem ser usados para armazenar dados de entrada para simula\u00e7\u00f5es ou c\u00e1lculos.</li> </ul> </li> <li>Opera\u00e7\u00f5es em S\u00e9rie:<ul> <li>Aplicar opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas em todos os elementos de um vetor \u00e9 uma tarefa comum em HPC.</li> </ul> </li> <li>Armazenamento de Resultados Intermedi\u00e1rios:<ul> <li>Vetores s\u00e3o \u00fateis para armazenar resultados intermedi\u00e1rios em algoritmos iterativos.</li> </ul> </li> </ol>"},{"location":"Teoria/manipulacao-vetores/#exemplo-uso-de-vector-com-classe-e-inline","title":"Exemplo: Uso de <code>Vector</code> com Classe e Inline","text":"<p>A utiliza\u00e7\u00e3o de classes para encapsular a l\u00f3gica de manipula\u00e7\u00e3o de vetores, junto com o uso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria e fun\u00e7\u00f5es <code>inline</code>, permite a cria\u00e7\u00e3o de estruturas de dados flex\u00edveis e de alto desempenho. Neste exemplo, implementaremos uma classe <code>Vector</code> que demonstrar\u00e1 esses conceitos.</p>"},{"location":"Teoria/manipulacao-vetores/#conceitos-fundamentais","title":"Conceitos Fundamentais","text":"<p>Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria: A aloca\u00e7\u00e3o din\u00e2mica permite que a mem\u00f3ria para o vetor seja alocada em tempo de execu\u00e7\u00e3o, proporcionando flexibilidade na gest\u00e3o do tamanho do vetor. Utilizamos <code>new</code> para alocar mem\u00f3ria e <code>delete[]</code> para liber\u00e1-la, garantindo que o uso de mem\u00f3ria seja eficiente e controlado.</p> <p>Ponteiros: Os ponteiros s\u00e3o utilizados para manipular diretamente a mem\u00f3ria alocada dinamicamente. No nosso exemplo, <code>int* dados</code> \u00e9 um ponteiro para o array que armazenar\u00e1 os elementos do vetor.</p> <p>Fun\u00e7\u00f5es Inline: Fun\u00e7\u00f5es <code>inline</code> s\u00e3o usadas para otimizar o desempenho, especialmente em m\u00e9todos curtos e frequentemente chamados. A declara\u00e7\u00e3o <code>inline</code> sugere ao compilador que expanda o c\u00f3digo da fun\u00e7\u00e3o no local da chamada, reduzindo a sobrecarga de chamadas de fun\u00e7\u00e3o.</p> <p>Redimensionamento Din\u00e2mico: Redimensionar dinamicamente o vetor permite que ele cres\u00e7a conforme necess\u00e1rio. Implementamos um m\u00e9todo que duplica a capacidade do vetor quando necess\u00e1rio, copiando os dados existentes para um novo espa\u00e7o de mem\u00f3ria alocado.</p>"},{"location":"Teoria/manipulacao-vetores/#implementacao-da-classe-vector","title":"Implementa\u00e7\u00e3o da Classe <code>Vector</code>","text":"<p>A seguir, apresentamos a implementa\u00e7\u00e3o detalhada da classe <code>Vector</code>, que inclui m\u00e9todos para inicializa\u00e7\u00e3o, acesso, modifica\u00e7\u00e3o, inser\u00e7\u00e3o e remo\u00e7\u00e3o de elementos, al\u00e9m de um m\u00e9todo para redimensionamento din\u00e2mico.</p> <pre><code>#include &lt;iostream&gt;\n\nclass Vector {\npublic:\n    Vector(int tamanho);                  // Construtor que inicializa o vetor\n    ~Vector();                            // Destrutor que libera a mem\u00f3ria alocada\n    void inicializa(int valor);           // M\u00e9todo para inicializar o vetor\n    inline int get(int index) const;      // M\u00e9todo inline para acessar um elemento\n    inline void set(int index, int valor); // M\u00e9todo inline para modificar um elemento\n    void inserir(int index, int valor);   // M\u00e9todo para inserir um elemento\n    void remover(int index);              // M\u00e9todo para remover um elemento\n    void imprime() const;                 // M\u00e9todo para imprimir o vetor\n    inline int tamanho() const;           // M\u00e9todo inline para obter o tamanho do vetor\n\nprivate:\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#definicao-da-classe-vector","title":"Defini\u00e7\u00e3o da Classe <code>Vector</code>","text":"<p>Vamos adicionar fun\u00e7\u00f5es inline e algumas otimiza\u00e7\u00f5es para melhorar o desempenho onde for poss\u00edvel.</p> <ol> <li>Atributos:<ul> <li><code>int* dados</code>: Ponteiro para o array din\u00e2mico que armazena os elementos do vetor.</li> <li><code>int tam</code>: Tamanho atual do vetor.</li> <li><code>int capacidade</code>: Capacidade m\u00e1xima do vetor antes de precisar redimensionar.</li> </ul> </li> </ol> <pre><code>#include &lt;iostream&gt;\n\nclass Vector {\npublic:\n    Vector(int tamanho);                  // Construtor que inicializa o vetor\n    ~Vector();                            // Destrutor que libera a mem\u00f3ria alocada\n    void inicializa(int valor);           // M\u00e9todo para inicializar o vetor\n    inline int get(int index) const;      // M\u00e9todo inline para acessar um elemento\n    inline void set(int index, int valor); // M\u00e9todo inline para modificar um elemento\n    void inserir(int index, int valor);   // M\u00e9todo para inserir um elemento\n    void remover(int index);              // M\u00e9todo para remover um elemento\n    void imprime() const;                 // M\u00e9todo para imprimir o vetor\n    inline int tamanho() const;           // M\u00e9todo inline para obter o tamanho do vetor\n\nprivate:\n    int* dados;                           // Ponteiro para os dados do vetor\n    int tam;                              // Tamanho atual do vetor\n    int capacidade;                       // Capacidade m\u00e1xima do vetor\n    void redimensiona(int novaCapacidade); // M\u00e9todo para redimensionar o vetor\n};\n</code></pre> <ol> <li> <p>Construtor e Destrutor:</p> <ul> <li> <p><code>Vector(int tamanho)</code>: Inicializa o vetor com o tamanho especificado e aloca mem\u00f3ria dinamicamente.</p> <pre><code>Vector::Vector(int tamanho)\n    : tam(tamanho), capacidade(tamanho), dados(new int[tamanho]) {}\n</code></pre> </li> <li> <p><code>~Vector()</code>: Libera a mem\u00f3ria alocada para evitar vazamentos de mem\u00f3ria.</p> <pre><code>Vector::~Vector() {\n    delete[] dados; // Libera a mem\u00f3ria alocada\n}\n</code></pre> </li> </ul> </li> <li> <p>M\u00e9todos B\u00e1sicos:</p> <ul> <li> <p><code>inicializa(int valor)</code>: Inicializa todos os elementos do vetor com o valor especificado.</p> <pre><code>void Vector::inicializa(int valor) {\n    for (int i = 0; i &lt; tam; ++i) {\n        dados[i] = valor; // Inicializa cada elemento do vetor com o valor especificado\n    }\n}\n</code></pre> </li> <li> <p><code>get(int index) const</code>: M\u00e9todo inline para acessar um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>inline int Vector::get(int index) const {\n    if (index &gt;= 0 &amp;&amp; index &lt; tam) {\n        return dados[index]; // Retorna o elemento na posi\u00e7\u00e3o especificada\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n        return -1; // Valor de erro\n    }\n}\n</code></pre> </li> <li> <p><code>set(int index, int valor)</code>: M\u00e9todo inline para modificar um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>inline void Vector::set(int index, int valor) {\n    if (index &gt;= 0 &amp;&amp; index &lt; tam) {\n        dados[index] = valor; // Modifica o elemento na posi\u00e7\u00e3o especificada\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> </li> <li> <p><code>inserir(int index, int valor)</code>: Insere um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>void Vector::inserir(int index, int valor) {\n    if (index &gt;= 0 &amp;&amp; index &lt;= tam) {\n        if (tam &gt;= capacidade) {\n            redimensiona(2 * capacidade); // Redimensiona o vetor se necess\u00e1rio\n        }\n        for (int i = tam; i &gt; index; --i) {\n            dados[i] = dados[i - 1]; // Move os elementos para a direita\n        }\n        dados[index] = valor; // Insere o novo elemento\n        tam++; // Incrementa o tamanho do vetor\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>remover(int index)</code>: Remove um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>void Vector::remover(int index) {\n    if (index &gt;= 0 &amp;&amp; index &lt; tam) {\n        for (int i = index; i &lt; tam - 1; ++i) {\n            dados[i] = dados[i + 1]; // Move os elementos para a esquerda\n        }\n        tam--; // Decrementa o tamanho do vetor\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> </li> <li> <p><code>imprime() const</code>: Imprime todos os elementos do vetor.</p> <pre><code>void Vector::imprime() const {\n    for (int i = 0; i &lt; tam; ++i) {\n        std::cout &lt;&lt; dados[i] &lt;&lt; \" \"; // Imprime cada elemento do vetor\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p><code>tamanho() const</code>: M\u00e9todo inline para obter o tamanho atual do vetor.</p> <pre><code>inline int Vector::tamanho() const {\n    return tam; // Retorna o tamanho atual do vetor\n}\n</code></pre> </li> <li> <p><code>redimensiona(int novaCapacidade)</code>: Redimensiona o vetor para a nova capacidade especificada, alocando nova mem\u00f3ria e copiando os dados existentes.</p> <pre><code>void Vector::redimensiona(int novaCapacidade) {\n    int* novoDados = new int[novaCapacidade]; // Aloca nova mem\u00f3ria\n    for (int i = 0; i &lt; tam; ++i) {\n        novoDados[i] = dados[i]; // Copia os dados antigos\n    }\n    delete[] dados; // Libera a mem\u00f3ria antiga\n    dados = novoDados; // Atualiza o ponteiro para os novos dados\n    capacidade = novaCapacidade; // Atualiza a capacidade do vetor\n}\n</code></pre> </li> </ol>"},{"location":"Teoria/manipulacao-vetores/#uso-da-classe-vector","title":"Uso da Classe <code>Vector</code>","text":"<ol> <li> <p>Inicializa\u00e7\u00e3o e Impress\u00e3o:</p> <ul> <li>Criamos um vetor de tamanho 5 e inicializamos todos os elementos com 0.</li> <li> <p>Imprimimos o vetor inicializado.</p> <pre><code>int main() {\n    Vector vec(5); // Cria um vetor de tamanho 5\n    vec.inicializa(0); // Inicializa todos os elementos com 0\n\n    std::cout &lt;&lt; \"Vetor inicializado: \";\n    vec.imprime(); // Imprime o vetor inicializado\n</code></pre> </li> </ul> </li> <li> <p>Modifica\u00e7\u00e3o:</p> <ul> <li> <p>Modificamos o terceiro elemento para 10 e imprimimos o vetor.</p> <pre><code>    vec.set(2, 10); // Modifica o terceiro elemento para 10\n    std::cout &lt;&lt; \"Ap\u00f3s modificar o terceiro elemento para 10: \";\n    vec.imprime(); // Imprime o vetor ap\u00f3s a modifica\u00e7\u00e3o\n</code></pre> </li> </ul> </li> <li> <p>Inser\u00e7\u00e3o:</p> <ul> <li> <p>Inserimos o valor 20 na terceira posi\u00e7\u00e3o e imprimimos o vetor.</p> <pre><code>    vec.inserir(2, 20); // Insere o valor 20 na terceira posi\u00e7\u00e3o\n    std::cout &lt;&lt; \"Ap\u00f3s inserir 20 na terceira posi\u00e7\u00e3o: \";\n    vec.imprime(); // Imprime o vetor ap\u00f3s a inser\u00e7\u00e3o\n</code></pre> </li> </ul> </li> <li> <p>Remo\u00e7\u00e3o:</p> <ul> <li> <p>Removemos o segundo elemento e imprimimos o vetor.</p> <pre><code>    vec.remover(1); // Remove o segundo elemento\n    std::cout &lt;&lt; \"Ap\u00f3s remover o segundo elemento: \";\n    vec.imprime(); // Imprime o vetor ap\u00f3s a remo\u00e7\u00e3o\n</code></pre> </li> </ul> </li> <li> <p>Tamanho:</p> <ul> <li> <p>Imprimimos o tamanho atual do vetor.</p> <pre><code>    std::cout &lt;&lt; \"Tamanho do vetor: \" &lt;&lt; vec.tamanho() &lt;&lt; std::endl; // Imprime o tamanho do vetor\n\n    return 0;\n}\n</code></pre> </li> </ul> </li> </ol> <p>Neste exemplo, usamos aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria e ponteiros para criar e manipular vetores em C++ usando classes e objetos. Tamb\u00e9m adicionamos fun\u00e7\u00f5es inline para melhorar o desempenho em opera\u00e7\u00f5es comuns como acesso e modifica\u00e7\u00e3o de elementos.</p>"},{"location":"Teoria/memoria-dinamica/","title":"Aloca\u00e7\u00e3o de Mem\u00f3ria Din\u00e2mica","text":"<p>A aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica \u00e9 uma pr\u00e1tica que permite aos programadores alocar e desalocar mem\u00f3ria durante a execu\u00e7\u00e3o do programa. Quando lidamos com grandes volumes de dados e opera\u00e7\u00f5es computacionalmente intensivas, a gest\u00e3o eficiente da mem\u00f3ria \u00e9 crucial para o desempenho e a escalabilidade das aplica\u00e7\u00f5es.</p> <p>Em C++, a mem\u00f3ria din\u00e2mica \u00e9 gerenciada usando os operadores <code>new</code> e <code>delete</code> para alocar e desalocar mem\u00f3ria, respectivamente.</p>"},{"location":"Teoria/memoria-dinamica/#exemplo-1-alocacao-e-manipulacao-de-matrizes-dinamicas","title":"Exemplo 1: Aloca\u00e7\u00e3o e Manipula\u00e7\u00e3o de Matrizes Din\u00e2micas","text":"<p>Vamos considerar um exemplo de aloca\u00e7\u00e3o din\u00e2mica de uma matriz e sua utiliza\u00e7\u00e3o em opera\u00e7\u00f5es de HPC.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main() {\n    int N = 1000; // Tamanho da matriz\n\n    // Aloca mem\u00f3ria para uma matriz din\u00e2mica\n    int** matriz = new int*[N];\n    for (int i = 0; i &lt; N; ++i) {\n        matriz[i] = new int[N];\n    }\n\n    // Inicializa a matriz com valores\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            matriz[i][j] = i + j;\n        }\n    }\n\n    // Realiza uma opera\u00e7\u00e3o de soma simples na matriz\n    auto inicio = high_resolution_clock::now();\n    long long soma = 0;\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            soma += matriz[i][j];\n        }\n    }\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Soma de todos os elementos: \" &lt;&lt; soma &lt;&lt; endl;\n    cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    // Libera a mem\u00f3ria alocada para a matriz\n    for (int i = 0; i &lt; N; ++i) {\n        delete[] matriz[i];\n    }\n    delete[] matriz;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/memoria-dinamica/#alocacao-da-matriz","title":"Aloca\u00e7\u00e3o da Matriz:","text":"<ul> <li><code>int** matriz = new int*[N];</code> aloca mem\u00f3ria para um array de ponteiros.</li> <li>O loop <code>for</code> interno aloca mem\u00f3ria para cada linha da matriz.</li> <li>Inicializa\u00e7\u00e3o e Opera\u00e7\u00f5es:<ul> <li>A matriz \u00e9 inicializada com a soma dos \u00edndices.</li> <li>Realiza uma opera\u00e7\u00e3o de soma em todos os elementos da matriz, medindo o tempo de execu\u00e7\u00e3o.</li> </ul> </li> <li>Desaloca\u00e7\u00e3o da Mem\u00f3ria:<ul> <li>A mem\u00f3ria alocada para cada linha \u00e9 liberada usando <code>delete[]</code>.</li> <li>A mem\u00f3ria alocada para o array de ponteiros \u00e9 liberada usando <code>delete[]</code>.</li> </ul> </li> </ul>"},{"location":"Teoria/memoria-dinamica/#alocacao-de-memoria-com-stdvector","title":"Aloca\u00e7\u00e3o de Mem\u00f3ria com <code>std::vector</code>","text":"<p>Usar <code>std::vector</code> \u00e9 uma alternativa eficiente e segura para a aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica manual em C++. <code>std::vector</code> gerencia automaticamente a mem\u00f3ria, reduzindo o risco de vazamentos de mem\u00f3ria e outros erros.</p>"},{"location":"Teoria/memoria-dinamica/#exemplo-com-stdvector","title":"Exemplo com <code>std::vector</code>","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main() {\n    int N = 1000; // Tamanho da matriz\n\n    // Aloca mem\u00f3ria para uma matriz din\u00e2mica usando std::vector\n    vector&lt;vector&lt;int&gt;&gt; matriz(N, vector&lt;int&gt;(N));\n\n    // Inicializa a matriz com valores\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            matriz[i][j] = i + j;\n        }\n    }\n\n    // Realiza uma opera\u00e7\u00e3o de soma simples na matriz\n    auto inicio = high_resolution_clock::now();\n    long long soma = 0;\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            soma += matriz[i][j];\n        }\n    }\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Soma de todos os elementos: \" &lt;&lt; soma &lt;&lt; endl;\n    cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/memoria-dinamica/#consideracoes-de-desempenho-em-hpc","title":"Considera\u00e7\u00f5es de Desempenho em HPC","text":"<ol> <li>Localidade de Dados:<ul> <li>A localidade de refer\u00eancia \u00e9 importante para o desempenho da cache. Matrizes alocadas dinamicamente podem ter menor localidade de refer\u00eancia do que matrizes est\u00e1ticas ou <code>std::vector</code>, especialmente se cada linha for alocada separadamente.</li> </ul> </li> <li>Fragmenta\u00e7\u00e3o de Mem\u00f3ria:<ul> <li>A aloca\u00e7\u00e3o din\u00e2mica pode levar \u00e0 fragmenta\u00e7\u00e3o de mem\u00f3ria, especialmente se a mem\u00f3ria for alocada e desalocada frequentemente. Isso pode ser mitigado usando pools de mem\u00f3ria ou alocadores personalizados.</li> </ul> </li> <li>Parallelismo:<ul> <li>Aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica pode introduzir sobrecarga em ambientes paralelos devido \u00e0 necessidade de sincroniza\u00e7\u00e3o. Em HPC, \u00e9 comum usar t\u00e9cnicas avan\u00e7adas para gerenciar a aloca\u00e7\u00e3o de mem\u00f3ria de forma eficiente em ambientes paralelos.</li> </ul> </li> </ol> <p>A aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica \u00e9 uma pr\u00e1tica fundamental em C++ que permite gerenciar a mem\u00f3ria de forma flex\u00edvel durante a execu\u00e7\u00e3o do programa. No contexto de HPC, a gest\u00e3o eficiente da mem\u00f3ria \u00e9 crucial para o desempenho e a escalabilidade das aplica\u00e7\u00f5es. Usar t\u00e9cnicas como aloca\u00e7\u00e3o manual com <code>new</code> e <code>delete</code> ou aloca\u00e7\u00e3o autom\u00e1tica com <code>std::vector</code> pode ajudar a escrever c\u00f3digo eficiente e seguro.</p>"},{"location":"Teoria/profiling/","title":"Profiling","text":"<p>Profiling \u00e9 o processo de medir o comportamento de um programa em termos de consumo de recursos, como tempo de execu\u00e7\u00e3o, uso de CPU, mem\u00f3ria e I/O. As informa\u00e7\u00f5es coletadas durante o profiling ajudam a identificar \"gargalos\" ou partes do c\u00f3digo que s\u00e3o ineficientes.</p> <p>Use o Cluster Franky</p> <pre><code>Acessando o terminal dele via ssh com o comando ssh nome_da_pasta@ip_do_cluster\n</code></pre> <p>ficou com d\u00favida?</p>"},{"location":"Teoria/profiling/#ferramentas-para-profiling-em-c","title":"Ferramentas para Profiling em C++","text":"<p>gprof: O gprof (GNU Profiler) \u00e9 uma ferramenta de profiling que faz parte do GNU Compiler Collection (GCC). Ele \u00e9 usado para medir o tempo de execu\u00e7\u00e3o gasto em cada fun\u00e7\u00e3o de um programa e criar um relat\u00f3rio detalhado de como esse tempo \u00e9 distribu\u00eddo entre as v\u00e1rias partes do c\u00f3digo. O gprof \u00e9 \u00fatil para identificar \"gargalos\" de desempenho em um programa, onde otimiza\u00e7\u00f5es podem ser mais eficazes.</p> <p>Valgrind: O Valgrind \u00e9 uma su\u00edte de ferramentas que ajuda a encontrar bugs de mem\u00f3ria e a realizar profiling de programas,tamb\u00e9m \u00e9 usado para medir o desempenho do programa em termos de uso de CPU.</p>"},{"location":"Teoria/profiling/#exemplo-1-usando-gprof","title":"Exemplo 1: Usando <code>gprof</code>","text":"<p>Vamos come\u00e7ar com um exemplo b\u00e1sico de como usar o <code>gprof</code>.</p>"},{"location":"Teoria/profiling/#codigo-de-exemplo-em-c","title":"C\u00f3digo de Exemplo em C++","text":"<p>O c\u00f3digo exemplo mult_matriz.cpp realiza uma opera\u00e7\u00e3o de multiplica\u00e7\u00e3o de matrizes. Ele multiplica duas matrizes  A  e  B  e armazena o resultado na matriz C.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid multiplyMatrices(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; C) {\n    int n = A.size();\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            C[i][j] = 0;\n            for (int k = 0; k &lt; n; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int n = 100;\n    std::vector&lt;std::vector&lt;int&gt;&gt; A(n, std::vector&lt;int&gt;(n, 1));\n    std::vector&lt;std::vector&lt;int&gt;&gt; B(n, std::vector&lt;int&gt;(n, 2));\n    std::vector&lt;std::vector&lt;int&gt;&gt; C(n, std::vector&lt;int&gt;(n, 0));\n\n    multiplyMatrices(A, B, C);\n\n    std::cout &lt;&lt; \"Matrix multiplication completed.\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/profiling/#compilacao-com-suporte-a-profiling","title":"Compila\u00e7\u00e3o com Suporte a Profiling","text":"<p>Para usar o <code>gprof</code>, precisamos compilar o c\u00f3digo com a flag <code>-pg</code>, que habilita o suporte ao profiling:</p> <pre><code>g++ -pg mult_matriz.cpp -o mult_matriz\n</code></pre>"},{"location":"Teoria/profiling/#executando-o-programa","title":"Executando o Programa","text":"<p>Depois de compilar, execute o programa normalmente:</p> <pre><code>./mult_matriz\n</code></pre> <p>Essa execu\u00e7\u00e3o vai gerar um arquivo chamado <code>gmon.out</code>, que cont\u00e9m os dados de profiling.</p>"},{"location":"Teoria/profiling/#analisando-os-dados-com-gprof","title":"Analisando os Dados com <code>gprof</code>","text":"<p>Agora, use o <code>gprof</code> para analisar os dados:</p> <pre><code>gprof mult_matriz gmon.out &gt; analise.txt\n</code></pre> <p>Isso cria um relat\u00f3rio detalhado do tempo gasto em cada fun\u00e7\u00e3o e a quantidade de chamadas feitas. O relat\u00f3rio ser\u00e1 salvo no arquivo <code>analise.txt</code>.</p>"},{"location":"Teoria/profiling/#entendendo-o-relatorio-de-profiling","title":"Entendendo o Relat\u00f3rio de Profiling","text":"<p>Ap\u00f3s executar o seu programa com <code>gprof</code>, voc\u00ea obter\u00e1 um relat\u00f3rio que cont\u00e9m duas se\u00e7\u00f5es principais: o Flat Profile e o Call Graph. Vamos explorar o significado de cada uma e como interpret\u00e1-las.</p>"},{"location":"Teoria/profiling/#flat-profile-identificando-as-funcoes-criticas","title":"Flat Profile: Identificando as Fun\u00e7\u00f5es Cr\u00edticas","text":"<p>O Flat Profile fornece uma vis\u00e3o geral do tempo que cada fun\u00e7\u00e3o consome durante a execu\u00e7\u00e3o do programa. Aqui est\u00e3o os principais elementos do relat\u00f3rio:</p> <ul> <li> <p>% time: Indica a porcentagem do tempo total de execu\u00e7\u00e3o que foi gasto em cada fun\u00e7\u00e3o. Fun\u00e7\u00f5es com valores mais altos s\u00e3o geralmente os principais alvos para otimiza\u00e7\u00e3o.</p> </li> <li> <p>cumulative seconds: \u00c9 o tempo acumulado at\u00e9 essa fun\u00e7\u00e3o ser chamada. Ele ajuda a entender quanto tempo foi gasto no programa at\u00e9 aquele ponto.</p> </li> <li> <p>self seconds: \u00c9 ao tempo gasto exclusivamente dentro da fun\u00e7\u00e3o, sem incluir o tempo das fun\u00e7\u00f5es que ela chama.</p> </li> <li> <p>calls: Mostra quantas vezes a fun\u00e7\u00e3o foi chamada. Fun\u00e7\u00f5es chamadas muitas vezes podem ser boas candidatas para otimiza\u00e7\u00e3o, especialmente se tiverem um tempo significativo por chamada.</p> </li> <li> <p>self ms/call e total ms/call: Esses valores mostram o tempo m\u00e9dio gasto em cada chamada da fun\u00e7\u00e3o. <code>self ms/call</code> \u00e9 o tempo gasto na pr\u00f3pria fun\u00e7\u00e3o, enquanto <code>total ms/call</code> inclui o tempo das fun\u00e7\u00f5es que ela invoca.</p> </li> </ul>"},{"location":"Teoria/profiling/#call-graph-compreendendo-as-relacoes-entre-funcoes","title":"Call Graph: Compreendendo as Rela\u00e7\u00f5es Entre Fun\u00e7\u00f5es","text":"<p>O Call Graph mostra a hierarquia de chamadas entre as fun\u00e7\u00f5es do seu programa. Ele detalha como as fun\u00e7\u00f5es est\u00e3o interconectadas e qual o impacto de cada uma no tempo de execu\u00e7\u00e3o total.</p> <ul> <li> <p>Self/Children Time: O tempo \"Self\" \u00e9 o gasto na pr\u00f3pria fun\u00e7\u00e3o, enquanto o tempo \"Children\" \u00e9 o gasto nas fun\u00e7\u00f5es que ela chama.</p> </li> <li> <p>Called: Informa quantas vezes uma fun\u00e7\u00e3o foi chamada, seja diretamente ou indiretamente por outras fun\u00e7\u00f5es.</p> </li> </ul>"},{"location":"Teoria/profiling/#analise-do-relatorio-de-profiling","title":"An\u00e1lise do Relat\u00f3rio de Profiling","text":"<p>No relat\u00f3rio gerado, as fun\u00e7\u00f5es relacionadas ao operador <code>operator[]</code> do <code>std::vector</code> aparecem como cr\u00edticas, consumindo cerca de 33% do tempo de execu\u00e7\u00e3o cada. Isso indica que a maneira como os vetores s\u00e3o acessados e manipulados no c\u00f3digo esta consumindo bastante tempo.</p> <p>Al\u00e9m disso, a fun\u00e7\u00e3o <code>multiplyMatrices</code> aparece com um tempo de execu\u00e7\u00e3o acumulado consider\u00e1vel. Como esta fun\u00e7\u00e3o realiza o trabalho pesado da multiplica\u00e7\u00e3o de matrizes, \u00e9 natural que ela seja um foco de aten\u00e7\u00e3o para otimiza\u00e7\u00e3o.</p>"},{"location":"Teoria/profiling/#oportunidades-de-otimizacao","title":"Oportunidades de Otimiza\u00e7\u00e3o","text":"<p>Com base no relat\u00f3rio, os poss\u00edveis candidatos a otimiza\u00e7\u00e3o s\u00e3o:</p> <ul> <li> <p>Reduzir Acessos ao Vetor: Como o acesso aos elementos do vetor (<code>operator[]</code>) consome uma parte significativa do tempo de execu\u00e7\u00e3o, podemos tentar reduzir o n\u00famero de acessos diretos ao vetor. </p> </li> <li> <p>Otimizar a Fun\u00e7\u00e3o <code>multiplyMatrices</code>: Esta fun\u00e7\u00e3o \u00e9 o cora\u00e7\u00e3o do processamento e qualquer melhoria aqui ter\u00e1 um grande impacto no desempenho global. Podemos pensar em paralelizar a fun\u00e7\u00e3o para distribuir o trabalho entre m\u00faltiplos n\u00facleos ou m\u00e1quinas, em um ambiente HPC como o Cluster Franky.</p> </li> </ul>"},{"location":"Teoria/profiling/#exemplo-2-usando-valgrind-para-profiling-de-memoria","title":"Exemplo 2: Usando Valgrind para Profiling de Mem\u00f3ria","text":"<p>O Valgrind tem um conjunto de ferramentas para an\u00e1lise de programas. Uma de suas funcionalidades mais conhecidas \u00e9 a detec\u00e7\u00e3o de problemas de mem\u00f3ria, mas tamb\u00e9m pode ser usado para profiling de CPU.</p> <p>Vamos usar o mesmo c\u00f3digo de multiplica\u00e7\u00e3o de matrizes do exemplo anterior.</p>"},{"location":"Teoria/profiling/#usando-o-valgrind-para-detectar-problemas-de-memoria","title":"Usando o Valgrind para Detectar Problemas de Mem\u00f3ria","text":"<p>Primeiro, compile o c\u00f3digo normalmente, sem flags especiais:</p> <pre><code>g++ mult_matriz.cpp -o mult_matriz\n</code></pre> <p>Agora, execute o programa usando o Valgrind para detectar problemas de mem\u00f3ria:</p> <pre><code>valgrind --leak-check=full ./mult_matriz &amp;&gt;leak-check.txt\n</code></pre> <p>O Valgrind ir\u00e1 executar o programa e relatar quaisquer vazamentos de mem\u00f3ria ou acessos inv\u00e1lidos no arquivo leak-check.txt.</p> <p>No relat\u00f3rio obtido aqui nos meus testes eu tive os seguintes resultados:</p>"},{"location":"Teoria/profiling/#interpretacao-do-relatorio-valgrind","title":"Interpreta\u00e7\u00e3o do Relat\u00f3rio Valgrind","text":"<ol> <li>HEAP SUMMARY (Resumo da Pilha)</li> <li> <p>in use at exit: 0 bytes in 0 blocks: Isso significa que, ao final da execu\u00e7\u00e3o do programa, n\u00e3o h\u00e1 blocos de mem\u00f3ria alocados que n\u00e3o foram liberados. Ou seja, toda a mem\u00f3ria que foi alocada foi devidamente liberada.</p> </li> <li> <p>total heap usage: 308 allocs, 308 frees, 202,128 bytes allocated: Este campo indica que, ao longo da execu\u00e7\u00e3o do programa, 308 aloca\u00e7\u00f5es de mem\u00f3ria heap ocorreram, e todas as 308 foram correspondidas por uma libera\u00e7\u00e3o. O total de mem\u00f3ria alocada durante o programa foi de 202,128 bytes.</p> </li> <li> <p>All heap blocks were freed -- no leaks are possible</p> </li> <li> <p>Esta linha confirma que todos os blocos de mem\u00f3ria foram liberados corretamente, portanto, n\u00e3o h\u00e1 vazamentos de mem\u00f3ria poss\u00edveis. Isso significa que o gerenciamento de mem\u00f3ria no programa est\u00e1 sendo feito corretamente.</p> </li> <li> <p>ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</p> </li> <li>Esta parte do relat\u00f3rio informa que n\u00e3o houve nenhum erro de mem\u00f3ria detectado. Isso inclui erros como acessos inv\u00e1lidos, uso de mem\u00f3ria n\u00e3o inicializada, ou acessos fora dos limites. O Valgrind n\u00e3o encontrou nenhum problema relacionado \u00e0 mem\u00f3ria neste programa.</li> </ol>"},{"location":"Teoria/profiling/#usando-o-valgrind-para-profiling-de-cpu-com-callgrind","title":"Usando o Valgrind para Profiling de CPU com <code>callgrind</code>","text":"<p>O Valgrind tamb\u00e9m pode ser usado para profiling de CPU com a ferramenta Callgrind:</p> <pre><code>valgrind --tool=callgrind ./mult_matriz \n</code></pre> <p>Este comando vai resultar em um arquivo de sa\u00edda <code>callgrind.out.&lt;PID&gt;</code>, que cont\u00e9m informa\u00e7\u00f5es detalhadas sobre o uso da CPU por cada fun\u00e7\u00e3o do programa.</p> <p>O relat\u00f3rio que voc\u00ea executou com Callgrind fornece um resumo sobre o desempenho do programa em termos de instru\u00e7\u00f5es executadas. Os elementos principais do relat\u00f3rio s\u00e3o:</p> <ol> <li> <p>Events: Ir: <code>Ir</code> significa \"Instruction References\". Este evento conta o n\u00famero total de instru\u00e7\u00f5es de m\u00e1quina que foram executadas pelo programa. As instru\u00e7\u00f5es de m\u00e1quina s\u00e3o as opera\u00e7\u00f5es mais b\u00e1sicas que a CPU realiza, como somar n\u00fameros, carregar dados da mem\u00f3ria, ou comparar valores. No relat\u00f3rio aqui do meu teste, o valor de <code>Ir</code> \u00e9 128,306,660. Isso significa que o programa executou mais de 128 milh\u00f5es de instru\u00e7\u00f5es durante a multiplica\u00e7\u00e3o de matrizes.</p> </li> <li> <p>Collected: 128,306,660: Este n\u00famero indica que o Callgrind coletou dados sobre todas essas 128 milh\u00f5es de instru\u00e7\u00f5es. \u00c9 uma confirma\u00e7\u00e3o de que todas as instru\u00e7\u00f5es executadas foram monitoradas.</p> </li> <li> <p>I refs: 128,306,660 : <code>I refs</code> \u00e9 uma m\u00e9trica que mostra o n\u00famero total de refer\u00eancias de instru\u00e7\u00e3o que foram feitas durante a execu\u00e7\u00e3o do programa. Como o valor \u00e9 igual ao de <code>Ir</code>, isso indica que cada instru\u00e7\u00e3o foi contabilizada.</p> </li> </ol> <p>O que fazer com essas informa\u00e7\u00f5es?</p> <ul> <li> <p>N\u00famero de Instru\u00e7\u00f5es: Um alto n\u00famero de instru\u00e7\u00f5es (<code>Ir</code>) pode indicar que o programa est\u00e1 realizando muitas opera\u00e7\u00f5es. Em um ambiente HPC, isso pode ser bom ou ruim, dependendo da efici\u00eancia dessas instru\u00e7\u00f5es. Muitas instru\u00e7\u00f5es simples podem ser r\u00e1pidas, enquanto poucas instru\u00e7\u00f5es complexas podem ser mais lentas.</p> </li> <li> <p>Identifica\u00e7\u00e3o de Gargalos: Ao combinar esses dados com outras informa\u00e7\u00f5es, como tempos de execu\u00e7\u00e3o e cache misses (que Callgrind tamb\u00e9m pode monitorar), voc\u00ea pode identificar quais partes do c\u00f3digo consomem mais recursos e otimizar essas \u00e1reas. Por exemplo, se uma fun\u00e7\u00e3o espec\u00edfica estiver gerando um grande n\u00famero de instru\u00e7\u00f5es e utilizando muito cache, ela pode ser um gargalo que precisa ser otimizado.</p> </li> </ul>"},{"location":"Teoria/profiling/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Para uma an\u00e1lise mais detalhada, voc\u00ea pode:</p> <p>Usar o KCachegrind (uma interface gr\u00e1fica) para visualizar o resultado detalhadamente:</p> <pre><code>kcachegrind callgrind.out.&lt;PID&gt;\n</code></pre> <p></p> <p>Como podemos ver na imagem, a fun\u00e7\u00e3o <code>multiplyMatrices</code> est\u00e1 destacada em laranja e consome 97.80% do total de instru\u00e7\u00f5es. Isso indica que a multiplica\u00e7\u00e3o de matrizes \u00e9 a opera\u00e7\u00e3o mais intensiva e cr\u00edtica em termos de desempenho no c\u00f3digo. Como essa fun\u00e7\u00e3o domina o uso de CPU, ela \u00e9 o principal alvo para otimiza\u00e7\u00e3o.</p> <p>As fun\u00e7\u00f5es que manipulam <code>std::vector</code> tamb\u00e9m aparecem com destaque:</p> <p><code>std::vector::operator[]</code>: Consome 18.71% das instru\u00e7\u00f5es. Esse operador \u00e9 chamado cada vez que um elemento do vetor \u00e9 acessado. A alta porcentagem indica que muitos acessos ao vetor est\u00e3o ocorrendo, o que pode ser um ponto de otimiza\u00e7\u00e3o.</p> <p><code>std::vector::allocator</code>: Tamb\u00e9m est\u00e1 destacada, indicando que a aloca\u00e7\u00e3o e acesso aos elementos do vetor \u00e9 um fator importante no uso de recursos.</p>"},{"location":"Teoria/profiling/#comparacao-entre-gprof-e-valgrind","title":"Compara\u00e7\u00e3o entre Gprof e Valgrind","text":"<p>Gprof e Valgrind s\u00e3o ferramentas de profiling, mas com focos e funcionalidades especificas. Na tabela temos uma compara\u00e7\u00e3o detalhada entre essas duas ferramentas:</p> Aspecto Gprof Valgrind Foco Principal Profiling de desempenho, medindo o tempo gasto em fun\u00e7\u00f5es. Detecta erros de uso de mem\u00f3ria e oferece ferramentas de profiling. Uso T\u00edpico Mapear gargalos de desempenho e identificar o tempo de execu\u00e7\u00e3o das fun\u00e7\u00f5es. Detectar vazamentos de mem\u00f3ria, acessos inv\u00e1lidos, e mapear o uso de CPU e mem\u00f3ria. Complexidade Relativamente simples de usar e interpretar, adequado para profiling inicial. Mais complexo, com v\u00e1rias ferramentas especializadas para diferentes tipos de an\u00e1lise. Overhead de Execu\u00e7\u00e3o Baixo overhead; o programa roda quase na velocidade normal. Alto overhead; o programa pode rodar significativamente mais lento devido \u00e0 an\u00e1lise detalhada. An\u00e1lise de Fun\u00e7\u00f5es Oferece relat\u00f3rios de chamadas (Call Graph) e perfis de fun\u00e7\u00f5es para entender o tempo de execu\u00e7\u00e3o. Oferece gr\u00e1ficos de chamadas detalhados com Callgrind, al\u00e9m de perfis de cache e instru\u00e7\u00f5es. Depura\u00e7\u00e3o de Mem\u00f3ria N\u00e3o fornece suporte para debug de mem\u00f3ria. Ferramenta principal para depura\u00e7\u00e3o de mem\u00f3ria, com suporte para detectar vazamentos e erros. Multithreading Suporta an\u00e1lise b\u00e1sica, mas n\u00e3o \u00e9 especializado em detectar race conditions. Helgrind \u00e9 especializado race conditions em programas multithreaded. Integra\u00e7\u00e3o e Uso Parte do GCC, f\u00e1cil de integrar em fluxos de trabalho de compila\u00e7\u00e3o. Requer execu\u00e7\u00e3o com a ferramenta espec\u00edfica e pode necessitar de ajustes no ambiente para uso eficiente. Ambiente de Uso Ideal para profiling em ambientes de desenvolvimento e produ\u00e7\u00e3o. Melhor utilizado em desenvolvimento e testes devido ao overhead; \u00fatil em produ\u00e7\u00e3o para an\u00e1lise pontual."},{"location":"Teoria/profiling/#conclusao","title":"Conclus\u00e3o","text":"<p>Gprof e Valgrind s\u00e3o ferramentas complementares no arsenal de um desenvolvedor:</p> <ul> <li> <p>Gprof \u00e9 uma boa escolha quando o objetivo \u00e9 entender a distribui\u00e7\u00e3o de tempo de execu\u00e7\u00e3o entre as fun\u00e7\u00f5es de um programa. Com seu baixo overhead, \u00e9 ideal para profiling inicial e para identificar rapidamente as \u00e1reas do c\u00f3digo que mais consomem tempo.</p> </li> <li> <p>Valgrind \u00e9 indispens\u00e1vel quando se trata de garantir o bom funcionamento do c\u00f3digo, especialmente em rela\u00e7\u00e3o ao uso de mem\u00f3ria. Embora introduza um overhead significativo, suas ferramentas como Memcheck e Callgrind s\u00e3o essenciais para detectar vazamentos de mem\u00f3ria, acessos inv\u00e1lidos, e para visualizar o desempenho em termos de uso de CPU e cache.</p> </li> </ul> <p>Em ambientes de HPC, usar Gprof para identificar gargalos de desempenho e Valgrind para garantir que o c\u00f3digo esteja livre de erros de mem\u00f3ria e bem otimizado, proporciona uma abordagem robusta para garantir que o software seja tanto r\u00e1pido quanto confi\u00e1vel. </p>"},{"location":"Teoria/slurm/","title":"SLURM","text":""},{"location":"Teoria/slurm/#o-que-e-slurm","title":"O que \u00e9 SLURM?","text":"<p>SLURM (Simple Linux Utility for Resource Management) \u00e9 um gerenciador de workload open-source amplamente utilizado em clusters de computa\u00e7\u00e3o de alto desempenho (HPC). Ele \u00e9 respons\u00e1vel por alocar recursos de computa\u00e7\u00e3o (como CPUs, mem\u00f3ria e GPUs) aos usu\u00e1rios e suas tarefas, gerenciar filas de jobs, monitorar o uso de recursos e agendar a execu\u00e7\u00e3o de tarefas de forma eficiente.</p>"},{"location":"Teoria/slurm/#principais-funcionalidades-do-slurm","title":"Principais Funcionalidades do SLURM","text":"<ol> <li>Aloca\u00e7\u00e3o de Recursos: SLURM distribui recursos de computa\u00e7\u00e3o, como n\u00f3s e processadores, conforme solicitado pelos usu\u00e1rios. Ele assegura que os recursos s\u00e3o utilizados de maneira eficiente e equitativa.</li> <li>Submiss\u00e3o de Jobs: Usu\u00e1rios podem submeter jobs (tarefas de computa\u00e7\u00e3o) ao SLURM, que coloca esses jobs em uma fila e os executa quando os recursos necess\u00e1rios est\u00e3o dispon\u00edveis.</li> <li>Monitoramento e Gerenciamento: SLURM monitoriza o estado dos jobs, n\u00f3s e parti\u00e7\u00f5es do cluster, fornecendo ferramentas para verificar o status e a utiliza\u00e7\u00e3o de recursos.</li> <li>Pol\u00edticas de Prioriza\u00e7\u00e3o: Implementa pol\u00edticas para priorizar jobs com base em v\u00e1rios fatores, como tempo de espera, utiliza\u00e7\u00e3o de recursos e prioridades definidas pelo administrador do cluster.</li> </ol>"},{"location":"Teoria/slurm/#comandos-principais-do-slurm","title":"Comandos Principais do SLURM","text":"<p>Alguns dos comandos principais usados no SLURM:</p> <ol> <li>sbatch: \u00c9 um comando do SLURM usado para submeter scripts de jobs para execu\u00e7\u00e3o em um cluster. Esses scripts cont\u00eam instru\u00e7\u00f5es sobre como os recursos devem ser alocados e quais comandos devem ser executados</li> <li>scancel: Cancela um job pendente ou em execu\u00e7\u00e3o.</li> <li>scontrol: Ferramenta administrativa usada para visualizar e/ou modificar o estado do SLURM. Muitos comandos <code>scontrol</code> s\u00f3 podem ser executados pelo adminstrador do sistema.</li> <li>sinfo: Relata o estado das filas e n\u00f3s gerenciados pelo SLURM, com v\u00e1rias op\u00e7\u00f5es de filtragem, ordena\u00e7\u00e3o e formata\u00e7\u00e3o.</li> <li>sprio: Exibe uma vis\u00e3o detalhada dos componentes que afetam a prioridade de um job.</li> <li>squeue: Relata o estado dos jobs em execu\u00e7\u00e3o em ordem de prioridade e depois os jobs pendentes em ordem de prioridade.</li> <li>srun: Submete um job para execu\u00e7\u00e3o e faz o pedido de aloca\u00e7\u00e3o dos recursos da maquina.</li> <li>strigger: Define, obt\u00e9m ou visualiza gatilhos de eventos, como n\u00f3s caindo ou jobs se aproximando do limite de tempo.</li> </ol>"},{"location":"Teoria/slurm/#exemplos-de-uso-para-cada-comando-slurm","title":"Exemplos de Uso para Cada Comando SLURM","text":""},{"location":"Teoria/slurm/#1-sbatch","title":"1. sbatch","text":"<p>Submete scripts de jobs para execu\u00e7\u00e3o em um cluster. Esses scripts cont\u00eam instru\u00e7\u00f5es sobre como os recursos devem ser alocados e quais comandos devem ser executados.</p> <p>Exemplo de Script:</p> <pre><code>#!/bin/bash\n#SBATCH --job-name=meu_job        # Nome do job\n#SBATCH --output=meu_job.out      # Arquivo de sa\u00edda\n#SBATCH --error=meu_job.err       # Arquivo de erro\n#SBATCH --ntasks=1                # N\u00famero de tarefas\n#SBATCH --cpus-per-task=4         # N\u00famero de CPUs por tarefa\n#SBATCH --mem=4G                  # Mem\u00f3ria total alocada para o job\n#SBATCH --time=00:02:00           # Tempo m\u00e1ximo de execu\u00e7\u00e3o (hh:mm:ss)\n#SBATCH --partition=normal        # Fila do cluster\n\necho \"Iniciando o job\"\nsleep 60\necho \"Job finalizado\"\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>-job-name=meu_job</code>: Define o nome do job como <code>meu_job</code>.</p> <p><code>-output=meu_job.out</code>: Especifica o arquivo onde a sa\u00edda padr\u00e3o do job ser\u00e1 registrada.</p> <p><code>-error=meu_job.err</code>: Especifica o arquivo onde os erros ser\u00e3o registrados.</p> <p><code>-ntasks=1</code>: Define o n\u00famero de tarefas (processos) a serem utilizados pelo job.</p> <p><code>-cpus-per-task=4</code>: Aloca 4 CPUs para cada tarefa.</p> <p><code>-mem=4G</code>: Especifica que 4 GB de mem\u00f3ria ser\u00e3o alocados para o job.</p> <p><code>-time=00:02:00</code>: Define o tempo m\u00e1ximo de execu\u00e7\u00e3o do job como 2 minutos.</p> <p><code>-partition=normal</code>: Especifica a fila do cluster onde o job ser\u00e1 executado.</p>"},{"location":"Teoria/slurm/#2-scancel","title":"2. scancel","text":"<p>Cancela um job pendente ou em execu\u00e7\u00e3o.</p> <p>Exemplo:</p> <pre><code>scancel 12345\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <ul> <li><code>12345</code>: Especifica o ID do job que deve ser cancelado.</li> </ul>"},{"location":"Teoria/slurm/#3-scontrol","title":"3. scontrol","text":"<p>Ferramenta administrativa usada para visualizar e/ou modificar o estado do SLURM. Muitos comandos <code>scontrol</code> s\u00f3 podem ser executados pelo administrador do sistema.</p> <p>Exemplo:</p> <pre><code>scontrol show job 12345\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>show job 12345</code>: Exibe informa\u00e7\u00f5es detalhadas sobre o job com ID <code>12345</code>.</p>"},{"location":"Teoria/slurm/#4-sinfo","title":"4. sinfo","text":"<p>Relata o estado das filas e n\u00f3s gerenciados pelo SLURM.</p> <p>Exemplo:</p> <pre><code>sinfo\n</code></pre>"},{"location":"Teoria/slurm/#5-sprio","title":"5. sprio","text":"<p>Exibe uma vis\u00e3o detalhada dos componentes que afetam a prioridade de um job.</p> <p>Exemplo:</p> <pre><code>sprio\n</code></pre>"},{"location":"Teoria/slurm/#6-squeue","title":"6. squeue","text":"<p>Relata o estado dos jobs em execu\u00e7\u00e3o em ordem de prioridade e depois os jobs pendentes em ordem de prioridade.</p> <p>Exemplo:</p> <pre><code>squeue -u username\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>u username</code>: Filtra a sa\u00edda para mostrar apenas os jobs do usu\u00e1rio <code>username</code>.</p>"},{"location":"Teoria/slurm/#7-srun","title":"7. srun","text":"<p>Submete um job para execu\u00e7\u00e3o e faz o pedido de aloca\u00e7\u00e3o dos recursos da m\u00e1quina.</p> <p>Exemplo:</p> <pre><code>srun -N 1 -n 1 --time=00:01:00 ./meu_programa\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>N 1</code>: Especifica que 1 n\u00f3 deve ser alocado.</p> <p><code>n 1</code>: Define que 1 tarefa deve ser executadas.</p> <p><code>-time=00:01:00</code>: Define o tempo m\u00e1ximo de execu\u00e7\u00e3o do job como 1 minuto.</p> <p><code>./meu_programa</code>: Especifica o programa a ser executado.</p>"},{"location":"Teoria/slurm/#9-strigger","title":"9. strigger","text":"<p>Define, obt\u00e9m ou visualiza gatilhos de eventos, como n\u00f3s caindo ou jobs se aproximando do limite de tempo.</p> <p>Exemplo: Vamos supor que voc\u00ea queira configurar um gatilho (<code>strigger</code>) para monitorar o uso de mem\u00f3ria de um job espec\u00edfico e enviar um alerta quando o uso de mem\u00f3ria ultrapassar um certo limite. Aqui est\u00e1 um exemplo completo:</p> <pre><code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=500 --action=\"echo 'Aten\u00e7\u00e3o: O uso de mem\u00f3ria ultrapassou 500 MB!'\"\n</code></pre>"},{"location":"Teoria/slurm/#explicacao-do-comando","title":"Explica\u00e7\u00e3o do Comando:","text":"<p><code>strigger</code>: Comando para configurar um gatilho no SLURM.</p> <p><code>--set</code>: Indica que estamos criando um novo gatilho.</p> <p><code>--jobid=&lt;JOB_ID&gt;</code>: Especifica o ID do job que queremos monitorar. Substitua <code>&lt;JOB_ID&gt;</code> pelo ID real do job.</p> <p><code>--threshold=500</code>: Define o limiar de 500 MB de uso de mem\u00f3ria. Quando o job usar mais de 500 MB, o gatilho ser\u00e1 ativado.</p> <p><code>--action=\"echo 'Aten\u00e7\u00e3o: O uso de mem\u00f3ria ultrapassou 500 MB!'\"</code>: Define a a\u00e7\u00e3o que ser\u00e1 executada quando o gatilho for ativado. Neste caso, a a\u00e7\u00e3o \u00e9 um simples comando <code>echo</code> que imprime uma mensagem de alerta.</p> <p>Este gatilho ser\u00e1 acionado quando o job especificado pelo <code>&lt;JOB_ID&gt;</code> ultrapassar 500 MB de uso de mem\u00f3ria. A a\u00e7\u00e3o definida (<code>echo</code>) ser\u00e1 executada, e voc\u00ea ver\u00e1 a mensagem \"Aten\u00e7\u00e3o: O uso de mem\u00f3ria ultrapassou 500 MB!\" no terminal ou no arquivo de sa\u00edda do job.</p> <p>Voc\u00ea pode personalizar o comando <code>strigger</code> para outras situa\u00e7\u00f5es, como monitorar o tempo restante de um job, detectar falhas de n\u00f3s, ou monitorar o uso de CPU, simplesmente ajustando os par\u00e2metros e as a\u00e7\u00f5es conforme necess\u00e1rio.</p>"},{"location":"Teoria/slurm/#tipos-comuns-de-eventos-monitoraveis-pelo-strigger","title":"Tipos Comuns de Eventos Monitor\u00e1veis pelo <code>strigger</code>:","text":"<p>Tempo Restante (<code>TIME_LIMIT</code>):</p> <p>Aciona o gatilho quando um job se aproxima de seu limite de tempo de execu\u00e7\u00e3o.</p> <p>Uso do <code>--threshold</code>: Especifica o tempo restante em segundos.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=60 --action=\"echo 'Job est\u00e1 a 60 segundos do limite de tempo!'\"</code></p> <p>Uso de Mem\u00f3ria (<code>MEMORY</code>):</p> <p>Aciona o gatilho quando o uso de mem\u00f3ria de um job ultrapassa um certo limite.</p> <p>Uso do <code>--threshold</code>: Especifica a quantidade de mem\u00f3ria usada, geralmente em megabytes (MB).</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=1024 --action=\"echo 'Job ultrapassou 1GB de mem\u00f3ria!'\"</code></p> <p>Falha de N\u00f3 (<code>NODE_FAIL</code>):</p> <p>Aciona o gatilho quando um n\u00f3 falha ou fica indispon\u00edvel.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de falha ocorre.</p> <p>Exemplo: <code>strigger --set --node=&lt;NODE_NAME&gt; --event=NODE_FAIL --action=\"echo 'N\u00f3 falhou!'\"</code></p> <p>Falha de Job (<code>JOB_FAIL</code>):</p> <p>Aciona o gatilho quando um job falha por qualquer motivo.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de falha ocorre.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=JOB_FAIL --action=\"echo 'Job falhou!'\"</code></p> <p>In\u00edcio de Job (<code>JOB_START</code>):</p> <p>Aciona o gatilho quando um job come\u00e7a a ser executado.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de in\u00edcio ocorre.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=JOB_START --action=\"echo 'Job iniciou!'\"</code></p> <p>Finaliza\u00e7\u00e3o de Job (<code>JOB_END</code>):</p> <p>Aciona o gatilho quando um job termina sua execu\u00e7\u00e3o, independentemente de ter sido conclu\u00eddo com sucesso ou n\u00e3o.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de finaliza\u00e7\u00e3o ocorre.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=JOB_END --action=\"echo 'Job terminou!'\"</code></p> <p>Limite de CPU (<code>CPU_LIMIT</code>):</p> <p>Aciona o gatilho quando o uso de CPU de um job ultrapassa um certo limite.</p> <p>Uso do <code>--threshold</code>: Especifica o uso de CPU em segundos de CPU ou em porcentagem.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=80 --action=\"echo 'Job ultrapassou 80% do uso de CPU!'\"</code></p> <p>Submiss\u00e3o de Job (<code>JOB_SUBMIT</code>):</p> <p>Aciona o gatilho quando um job \u00e9 submetido para execu\u00e7\u00e3o.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de submiss\u00e3o ocorre.</p> <p>Exemplo: <code>strigger --set --user=&lt;USER_NAME&gt; --event=JOB_SUBMIT --action=\"echo 'Um job foi submetido!'\"</code></p> <p>Queda de Parti\u00e7\u00e3o (<code>PARTITION_DOWN</code>):</p> <p>Aciona o gatilho quando uma parti\u00e7\u00e3o inteira do cluster cai ou fica indispon\u00edvel.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de queda da parti\u00e7\u00e3o ocorre.</p> <p>Exemplo: <code>strigger --set --partition=&lt;PARTITION_NAME&gt; --event=PARTITION_DOWN --action=\"echo 'Parti\u00e7\u00e3o caiu!'\"</code></p> <p>Chegada de Job ao Limiar de Tempo (<code>TIME_LIM_REACHED</code>):</p> <p>Similar ao <code>TIME_LIMIT</code>, mas pode ser mais espec\u00edfico para quando o tempo limite \u00e9 alcan\u00e7ado, n\u00e3o apenas quando est\u00e1 pr\u00f3ximo.</p> <p>Uso do <code>--threshold</code>: Especifica o tempo restante ou o evento do tempo limite.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=TIME_LIM_REACHED --action=\"echo 'Tempo limite alcan\u00e7ado!'\"</code></p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/","title":"Sobrecarga de Fun\u00e7\u00f5es em C++","text":"<p>Sobrecarga de fun\u00e7\u00f5es \u00e9 um recurso da linguagem C++ que permite definir m\u00faltiplas fun\u00e7\u00f5es com o mesmo nome, mas com diferentes listas de par\u00e2metros. Isso significa que voc\u00ea pode ter v\u00e1rias fun\u00e7\u00f5es que realizam tarefas semelhantes, mas aceitam diferentes tipos ou n\u00fameros de argumentos.</p> <p>No contexto de HPC, a sobrecarga de fun\u00e7\u00f5es pode ser usada para otimizar opera\u00e7\u00f5es em diferentes tipos de dados (por exemplo, opera\u00e7\u00f5es em inteiros, floats e doubles) sem duplicar o c\u00f3digo. Isso pode ajudar a escrever c\u00f3digo mais limpo e eficiente.</p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#regras-para-sobrecarga-de-funcoes","title":"Regras para Sobrecarga de Fun\u00e7\u00f5es","text":"<p>Para que duas ou mais fun\u00e7\u00f5es sejam sobrecarregadas corretamente, elas devem ser diferentes em pelo menos um dos seguintes aspectos:</p> <ol> <li>N\u00famero de par\u00e2metros: As fun\u00e7\u00f5es devem ter um n\u00famero diferente de par\u00e2metros.</li> <li>Tipo de par\u00e2metros: As fun\u00e7\u00f5es devem ter tipos diferentes de par\u00e2metros.</li> </ol> <p>A sobrecarga de fun\u00e7\u00f5es n\u00e3o pode ser feita apenas com base no tipo de retorno das fun\u00e7\u00f5es.</p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#exemplo-basico-de-sobrecarga-de-funcoes","title":"Exemplo B\u00e1sico de Sobrecarga de Fun\u00e7\u00f5es","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// Fun\u00e7\u00e3o que imprime um inteiro\nvoid imprimir(int valor) {\n    std::cout &lt;&lt; \"Inteiro: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n\n// Fun\u00e7\u00e3o que imprime um float\nvoid imprimir(float valor) {\n    std::cout &lt;&lt; \"Float: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n\n// Fun\u00e7\u00e3o que imprime uma string\nvoid imprimir(std::string valor) {\n    std::cout &lt;&lt; \"String: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n\nint main() {\n    imprimir(10);          // Chama a fun\u00e7\u00e3o que imprime um inteiro\n    imprimir(3.14f);       // Chama a fun\u00e7\u00e3o que imprime um float\n    imprimir(\"Hello\");     // Chama a fun\u00e7\u00e3o que imprime uma string\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>imprimir</code> \u00e9 sobrecarregada para aceitar diferentes tipos de argumentos: <code>int</code>, <code>float</code> e <code>std::string</code></p> <p>Vamos considerar um exemplo de sobrecarga de fun\u00e7\u00f5es para calcular o produto escalar de vetores de diferentes tipos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Fun\u00e7\u00e3o para calcular o produto escalar de vetores de inteiros\nint produtoEscalar(const std::vector&lt;int&gt;&amp; v1, const std::vector&lt;int&gt;&amp; v2) {\n    int produto = 0;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\n// Fun\u00e7\u00e3o para calcular o produto escalar de vetores de floats\nfloat produtoEscalar(const std::vector&lt;float&gt;&amp; v1, const std::vector&lt;float&gt;&amp; v2) {\n    float produto = 0.0f;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\n// Fun\u00e7\u00e3o para calcular o produto escalar de vetores de doubles\ndouble produtoEscalar(const std::vector&lt;double&gt;&amp; v1, const std::vector&lt;double&gt;&amp; v2) {\n    double produto = 0.0;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\nint main() {\n    std::vector&lt;int&gt; v1_int = {1, 2, 3};\n    std::vector&lt;int&gt; v2_int = {4, 5, 6};\n\n    std::vector&lt;float&gt; v1_float = {1.0f, 2.0f, 3.0f};\n    std::vector&lt;float&gt; v2_float = {4.0f, 5.0f, 6.0f};\n\n    std::vector&lt;double&gt; v1_double = {1.0, 2.0, 3.0};\n    std::vector&lt;double&gt; v2_double = {4.0, 5.0, 6.0};\n\n    std::cout &lt;&lt; \"Produto Escalar (int): \" &lt;&lt; produtoEscalar(v1_int, v2_int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (float): \" &lt;&lt; produtoEscalar(v1_float, v2_float) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (double): \" &lt;&lt; produtoEscalar(v1_double, v2_double) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#sobrecarga-de-funcoes-e-templates","title":"Sobrecarga de Fun\u00e7\u00f5es e Templates","text":"<p>Outra abordagem para lidar com opera\u00e7\u00f5es semelhantes em diferentes tipos de dados \u00e9 o uso de templates de fun\u00e7\u00f5es. Templates podem ser usados para evitar a necessidade de sobrecarregar fun\u00e7\u00f5es manualmente para cada tipo de dado.</p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#exemplo-de-template-de-funcao","title":"Exemplo de Template de Fun\u00e7\u00e3o","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Template de fun\u00e7\u00e3o para calcular o produto escalar de vetores\ntemplate &lt;typename T&gt;\nT produtoEscalar(const std::vector&lt;T&gt;&amp; v1, const std::vector&lt;T&gt;&amp; v2) {\n    T produto = 0;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\nint main() {\n    std::vector&lt;int&gt; v1_int = {1, 2, 3};\n    std::vector&lt;int&gt; v2_int = {4, 5, 6};\n\n    std::vector&lt;float&gt; v1_float = {1.0f, 2.0f, 3.0f};\n    std::vector&lt;float&gt; v2_float = {4.0f, 5.0f, 6.0f};\n\n    std::vector&lt;double&gt; v1_double = {1.0, 2.0, 3.0};\n    std::vector&lt;double&gt; v2_double = {4.0, 5.0, 6.0};\n\n    std::cout &lt;&lt; \"Produto Escalar (int): \" &lt;&lt; produtoEscalar(v1_int, v2_int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (float): \" &lt;&lt; produtoEscalar(v1_float, v2_float) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (double): \" &lt;&lt; produtoEscalar(v1_double, v2_double) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>A sobrecarga de fun\u00e7\u00f5es em C++ permite a defini\u00e7\u00e3o de m\u00faltiplas fun\u00e7\u00f5es com o mesmo nome, mas com diferentes listas de par\u00e2metros. Isso melhora a legibilidade, manuten\u00e7\u00e3o e facilidade de uso do c\u00f3digo. No contexto de HPC, a sobrecarga de fun\u00e7\u00f5es pode ser usada para otimizar opera\u00e7\u00f5es em diferentes tipos de dados, evitando duplica\u00e7\u00e3o de c\u00f3digo e melhorando a efici\u00eancia. Alternativamente, templates de fun\u00e7\u00f5es podem ser usados para alcan\u00e7ar resultados similares com menos c\u00f3digo.</p>"},{"location":"Teoria/uso-de-constantes/","title":"Const Correctness em HPC","text":"<p>Const Correctness (uso de constantes) \u00e9 um conceito em C++ que garante que os dados n\u00e3o sejam modificados quando n\u00e3o deveriam ser. Usar <code>const</code> corretamente pode melhorar a legibilidade do c\u00f3digo, evitar erros e permitir otimiza\u00e7\u00f5es pelo compilador. </p>"},{"location":"Teoria/uso-de-constantes/#usos-comuns-de-const","title":"Usos Comuns de <code>const</code>","text":""},{"location":"Teoria/uso-de-constantes/#1-variaveis-locais","title":"1. Vari\u00e1veis Locais","text":"<p>Declarar vari\u00e1veis locais como <code>const</code> se voc\u00ea n\u00e3o pretende modificar o valor delas.</p> <pre><code>const int valor = 10;\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#2-parametros-de-funcao","title":"2. Par\u00e2metros de Fun\u00e7\u00e3o","text":"<p>Usar <code>const</code> em par\u00e2metros de fun\u00e7\u00e3o para garantir que os argumentos n\u00e3o sejam modificados.</p> <pre><code>void imprimeValor(const int valor) {\n    std::cout &lt;&lt; \"Valor: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#3-ponteiros-e-referencias","title":"3. Ponteiros e Refer\u00eancias","text":"<p>Declarar ponteiros e refer\u00eancias como <code>const</code> para garantir que os dados apontados ou referenciados n\u00e3o sejam alterados.</p> <pre><code>void imprimeValor(const int* ptr) {\n    std::cout &lt;&lt; \"Valor: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n\nvoid imprimeValor(const int&amp; ref) {\n    std::cout &lt;&lt; \"Valor: \" &lt;&lt; ref &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#4-metodos-de-classe","title":"4. M\u00e9todos de Classe","text":"<p>Declarar m\u00e9todos como <code>const</code> para garantir que eles n\u00e3o modifiquem o estado do objeto.</p> <pre><code>class Ponto {\npublic:\n    Ponto(int x, int y) : x(x), y(y) {}\n\n    int getX() const { return x; }\n    int getY() const { return y; }\n\nprivate:\n    int x, y;\n};\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#exemplo-multiplicacao-de-matrizes-com-const-correctness","title":"Exemplo: Multiplica\u00e7\u00e3o de Matrizes com Const Correctness","text":"<p>Vamos considerar um exemplo de multiplica\u00e7\u00e3o de matrizes onde aplicamos const correctness para garantir que os dados de entrada n\u00e3o sejam modificados.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Fun\u00e7\u00e3o para multiplicar duas matrizes com const correctness\nvoid multiplicaMatriz(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B, vector&lt;vector&lt;int&gt;&gt;&amp; C) {\n    int N = A.size();\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            C[i][j] = 0;\n            for (int k = 0; k &lt; N; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int N = 100; // Tamanho da matriz\n    vector&lt;vector&lt;int&gt;&gt; A(N, vector&lt;int&gt;(N, 1));\n    vector&lt;vector&lt;int&gt;&gt; B(N, vector&lt;int&gt;(N, 1));\n    vector&lt;vector&lt;int&gt;&gt; C(N, vector&lt;int&gt;(N, 0));\n\n    auto inicio = high_resolution_clock::now();\n\n    // Chama a fun\u00e7\u00e3o de multiplica\u00e7\u00e3o de matrizes\n    multiplicaMatriz(A, B, C);\n\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Tempo de multiplica\u00e7\u00e3o de matrizes: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#const-correctness-em-classes","title":"Const Correctness em Classes","text":"<p>No contexto de HPC, classes frequentemente encapsulam dados e opera\u00e7\u00f5es. Garantir const correctness em m\u00e9todos de classe \u00e9 essencial.</p>"},{"location":"Teoria/uso-de-constantes/#exemplo-classe-de-matriz-com-metodos-const","title":"Exemplo: Classe de Matriz com M\u00e9todos Const","text":"<pre><code>class Matriz {\npublic:\n    Matriz(int N) : data(N, vector&lt;int&gt;(N, 0)) {}\n\n    const vector&lt;int&gt;&amp; operator[](int index) const {\n        return data[index];\n    }\n\n    vector&lt;int&gt;&amp; operator[](int index) {\n        return data[index];\n    }\n\n    void imprime() const {\n        for (const auto&amp; linha : data) {\n            for (int valor : linha) {\n                cout &lt;&lt; valor &lt;&lt; \" \";\n            }\n            cout &lt;&lt; endl;\n        }\n    }\n\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; data;\n};\n\nint main() {\n    Matriz matriz(3);\n\n    matriz[0][0] = 1;\n    matriz[1][1] = 2;\n    matriz[2][2] = 3;\n\n    cout &lt;&lt; \"Matriz:\" &lt;&lt; endl;\n    matriz.imprime();\n\n    return 0;\n}\n</code></pre> <p>Aplicar const correctness pode prevenir erros e permitir otimiza\u00e7\u00f5es adicionais pelo compilador. Usar <code>const</code> de maneira apropriada em vari\u00e1veis, par\u00e2metros de fun\u00e7\u00e3o, ponteiros, refer\u00eancias e m\u00e9todos de classe \u00e9 uma pr\u00e1tica recomendada para escrever c\u00f3digo robusto e eficiente.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/","title":"Cluster Franky","text":"<p>Nosso objetivo \u00e9 preparar voc\u00ea com as habilidades necess\u00e1rias para utilizar sistemas de HPC em situa\u00e7\u00f5es reais. Inspirado no supercomputador Santos Dumont, o Cluster Franky oferece um ambiente robusto e seguro para realizar simula\u00e7\u00f5es complexas e an\u00e1lises de grandes volumes de dados.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#como-o-sistema-funciona","title":"Como o Sistema Funciona","text":"<p>Para que voc\u00ea compreenda melhor como o Cluster Franky opera, veja a figura abaixo que detalha a arquitetura do sistema:</p> <p></p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#1-conexao-e-autenticacao","title":"1. Conex\u00e3o e Autentica\u00e7\u00e3o","text":"<p>O processo de intera\u00e7\u00e3o com o Cluster Franky come\u00e7a quando voc\u00ea se conecta ao Cluster via SSH atrav\u00e9s da rede do Insper, em seguida, voc\u00ea ser\u00e1 direcionado ao Login Node, que serve como o ponto de entrada para o cluster. Para acessar o sistema, \u00e9 necess\u00e1rio passar por um processo de autentica\u00e7\u00e3o usando pares de chaves p\u00fablicas e privadas, configurados previamente por nossa equipe t\u00e9cnica.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#2-envio-e-gerenciamento-de-tarefas-jobs","title":"2. Envio e Gerenciamento de Tarefas (Jobs)","text":"<p>Uma vez autenticado, voc\u00ea interage com o cluster atrav\u00e9s do Slurm. O Slurm \u00e9 respons\u00e1vel por gerenciar a execu\u00e7\u00e3o das tarefas que voc\u00ea submete, distribuindo-as eficientemente pelos recursos de computa\u00e7\u00e3o dispon\u00edveis, que s\u00e3o divididos em:</p> <ul> <li>N\u00f3 de Computa\u00e7\u00e3o CPU: Composto por cinco n\u00f3s, cada um com 24 threads e 64 GB de RAM.</li> <li>N\u00f3 de Computa\u00e7\u00e3o GPU: Composto por um n\u00f3s, equipado com uma GPU NVIDIA 1080 Ti, 16 GB de RAM e 8 threads.</li> </ul> <p>Os daemons de controle cada n\u00f3 de computa\u00e7\u00e3o gerencia a execu\u00e7\u00e3o das tarefas, garantindo que os recursos sejam alocados de forma otimizada. Isso significa que, independentemente de voc\u00ea estar executando simula\u00e7\u00f5es simples ou tarefas intensivas de processamento de dados, o sistema est\u00e1 configurado para maximizar a efici\u00eancia e minimizar o tempo de execu\u00e7\u00e3o.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#3-armazenamento-e-gestao-de-dados","title":"3. Armazenamento e Gest\u00e3o de Dados","text":"<p>Durante suas atividades, voc\u00ea deve utilizar a pasta SCRATCH para armazenar temporariamente os arquivos e dados necess\u00e1rios para suas tarefas. \u00c9 importante lembrar que essa pasta \u00e9 destinada ao armazenamento tempor\u00e1rio, portanto, certifique-se de salvar seus dados em um local seguro ap\u00f3s concluir suas atividades.</p> <p>O sistema de arquivos atual do Cluster Franky utiliza o NFS (Network File System), que facilita o acesso aos dados entre os n\u00f3s de computa\u00e7\u00e3o. No futuro, planejamos migrar para o sistema de arquivos Lustre, que oferecer\u00e1 maior efici\u00eancia e melhor desempenho no manuseio de grandes volumes de dados.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#porque-usar-o-cluster-franky","title":"Porque usar o Cluster Franky?","text":"<p>Utilizar o Cluster Franky oferece v\u00e1rios benef\u00edcios que v\u00e3o prepar\u00e1-lo para desafios reais em HPC:</p> <ul> <li> <p>Experi\u00eancia Pr\u00e1tica em HPC: Ao trabalhar com o Cluster Franky, voc\u00ea ter\u00e1 a oportunidade de realizar tarefas que simulam cen\u00e1rios reais encontrados em supercomputadores como o Santos Dumont. Isso inclui a execu\u00e7\u00e3o de simula\u00e7\u00f5es complexas, a otimiza\u00e7\u00e3o de recursos e o uso inteligente das ferramentas dispon\u00edveis.</p> </li> <li> <p>Desenvolvimento de Habilidades T\u00e9cnicas: Aprender a utilizar ferramentas avan\u00e7adas como o Slurm e a interagir com ambientes de computa\u00e7\u00e3o distribu\u00edda ir\u00e1 equip\u00e1-lo com habilidades t\u00e9cnicas valiosas, amplamente aplic\u00e1veis em diversas \u00e1reas de pesquisa e ind\u00fastria.</p> </li> <li> <p>Prepara\u00e7\u00e3o para o Mundo Real: A experi\u00eancia adquirida com o Cluster Franky ser\u00e1 um diferencial no mercado de trabalho, pois voc\u00ea estar\u00e1 familiarizado com pr\u00e1ticas e tecnologias utilizadas em sistemas de HPC de ponta.</p> </li> </ul> <p>O Cluster Franky n\u00e3o \u00e9 apenas uma ferramenta de aprendizado; \u00e9 uma porta de entrada para o mundo da computa\u00e7\u00e3o de alto desempenho. Aproveite essa oportunidade para expandir seus conhecimentos, experimentar e se preparar para enfrentar desafios de HPC. Se precisar de ajuda ou tiver d\u00favidas, procure um de n\u00f3s!</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/","title":"Contextualizando o HPC","text":""},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-hpc","title":"O que \u00e9 HPC?","text":"<p>High-Performance Computing (HPC) refere-se ao uso de supercomputadores e clusters de computadores para resolver problemas computacionalmente complexos. HPC \u00e9 essencial em campos como ci\u00eancia, engenharia e finan\u00e7as, onde grandes volumes de dados precisam ser processados rapidamente.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#top-500","title":"TOP 500","text":"<p>Supercomputador Fugaku Fonte:https://spectrum.ieee.org/japans-fugaku-supercomputer-is-first-in-the-world-to-simultaneously-top-all-high-performance-benchmarks</p> <p>O TOP 500 \u00e9 uma lista semestral que classifica os 500 supercomputadores mais poderosos do mundo com base no benchmark LINPACK, que mede a capacidade de resolver sistemas de equa\u00e7\u00f5es lineares. A lista \u00e9 um indicador importante do progresso em tecnologia de supercomputa\u00e7\u00e3o. Varia\u00e7\u00f5es da lista incluem:</p> <ul> <li>Green500: Classifica supercomputadores pela efici\u00eancia energ\u00e9tica.</li> <li>Graph500: Mede o desempenho em tarefas de an\u00e1lise de gr\u00e1ficos.</li> <li>HPCG: Avalia supercomputadores usando um benchmark alternativo ao LINPACK, mais representativo de cargas de trabalho reais em HPC.</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#que-tipo-de-problema-e-computacionalmente-complexo","title":"Que tipo de problema \u00e9 computacionalmente complexo?","text":"<p>Problemas computacionalmente complexos exigem grande capacidade de processamento e mem\u00f3ria para serem resolvidos eficientemente. Exemplos incluem:</p> <ul> <li>Simula\u00e7\u00f5es clim\u00e1ticas</li> <li>Modelagem molecular</li> <li>Processamento de grandes conjuntos de dados (Big Data)</li> <li>An\u00e1lise gen\u00f4mica</li> <li>Renderiza\u00e7\u00e3o de gr\u00e1ficos em alta resolu\u00e7\u00e3o</li> <li>Aprendizado de m\u00e1quina e intelig\u00eancia artificial</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-um-supercomputador","title":"O que \u00e9 um supercomputador?","text":"<p>Monstr\u00e3o - Supercomputador do Insper Fonte:https://www.insper.edu.br/noticias/conhece-o-monstrao-saiba-mais-sobre-o-supercomputador-do-insper/</p> <p>Um supercomputador \u00e9 um sistema computacional de alto desempenho projetado para processar grandes volumes de dados e realizar c\u00e1lculos complexos muito rapidamente. Ele consiste em milhares de n\u00f3s de computa\u00e7\u00e3o interconectados, cada um contendo m\u00faltiplos processadores, grande quantidade de mem\u00f3ria e armazenamento r\u00e1pido.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-um-cluster","title":"O que \u00e9 um Cluster?","text":"<p>Cluster Franky - Laborat\u00f3rio de Redes e Supercomputa\u00e7\u00e3o do Insper</p> <p>Um cluster \u00e9 um conjunto de computadores (n\u00f3s) conectados que trabalham juntos como se fossem um \u00fanico sistema. Cada n\u00f3 em um cluster \u00e9 um computador independente, mas o sistema inteiro \u00e9 gerenciado para atuar em conjunto, distribuindo tarefas e compartilhando recursos.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#qual-a-diferenca-de-um-supercomputador-para-um-cluster","title":"Qual a diferen\u00e7a de um supercomputador para um cluster?","text":"<p>A principal diferen\u00e7a entre um supercomputador e um cluster est\u00e1 na integra\u00e7\u00e3o e desempenho:</p> <ul> <li>Supercomputador: Um sistema integrado de alto desempenho projetado especificamente para computa\u00e7\u00e3o intensa. Possui uma arquitetura otimizada e interconex\u00f5es de alta velocidade.</li> <li>Cluster: S\u00e3o computadores independentes conectados para trabalhar juntos. Pode ser composto por hardware de mercado e geralmente \u00e9 mais flex\u00edvel e expans\u00edvel.</li> </ul> <p>OBS: Muitos supercomputadores modernos s\u00e3o de fato clusters, utilizando milhares de n\u00f3s interconectados para alcan\u00e7ar um desempenho extremamente alto.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-preciso-saber-para-utilizar-o-cluster","title":"O que \u00e9 preciso saber para utilizar o Cluster?","text":"<p>Para utilizar um cluster eficientemente, \u00e9 importante entender:</p> <ul> <li>Acesso e Conex\u00e3o: Como se conectar ao cluster e configurar as credenciais de acesso.</li> <li>Gerenciamento de Recursos: Como usar o sistema de gerenciamento de SLURM para submeter e monitorar jobs.</li> <li>Sistema de Arquivos: Navega\u00e7\u00e3o e uso do sistema de arquivos do cluster.</li> <li>Compila\u00e7\u00e3o e Execu\u00e7\u00e3o: Compilar c\u00f3digo e executar programas no ambiente do cluster.</li> <li>Paraleliza\u00e7\u00e3o: Como paralelizar c\u00f3digo usando bibliotecas como OpenMP e MPI.</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-preciso-saber-para-resolver-problemas-em-hpc","title":"O que \u00e9 preciso saber para resolver problemas em HPC?","text":"<p>Para resolver problemas em HPC, \u00e9 essencial ter conhecimento em:</p> <ul> <li>Arquitetura de Computadores: Compreender a arquitetura do sistema, incluindo hierarquia de mem\u00f3ria e caches, para escrever c\u00f3digo eficiente.</li> <li>Otimiza\u00e7\u00e3o de C\u00f3digo: T\u00e9cnicas de otimiza\u00e7\u00e3o, uso eficiente da mem\u00f3ria, uso efici\u00eante do compilador.</li> <li>Profiling: Ferramentas e t\u00e9cnicas para identificar gargalos de desempenho e medir a efici\u00eancia do c\u00f3digo.</li> <li>Gerenciamento de Recursos: Usar ferramentas de gerenciamento como SLURM para alocar recursos adequadamente.</li> <li>Programa\u00e7\u00e3o Paralela: Usar OpenMP para paraleliza\u00e7\u00e3o em mem\u00f3ria compartilhada e MPI para mem\u00f3ria distribu\u00edda.</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#recursos-adicionais","title":"Recursos Adicionais","text":"<ul> <li>Documenta\u00e7\u00e3o do SLURM: SLURM User Guide</li> <li>Tutoriais de MPI: MPI Tutorial</li> <li>OpenMP: OpenMP Official Site</li> <li>Profiling Tools: Gprof, Valgrind</li> </ul>"},{"location":"Teoria/introducao/conceitos-basicos-hw/","title":"Relembrando conceitos importantes","text":"<p>O mapa de mem\u00f3ria de um computador revela como a mem\u00f3ria \u00e9 organizada e gerenciada, isso \u00e9 essencial para entender o armazenamento, o acesso e a manipula\u00e7\u00e3o de dados pela CPU. A mem\u00f3ria principal do sistema inclui o heap, a stack e os segmentos de dados e c\u00f3digo. </p> <ol> <li>Pilha: Localizada no topo do mapa de mem\u00f3ria, \u00e9 usada para armazenar vari\u00e1veis locais e chamadas de fun\u00e7\u00e3o. Cada thread possui sua pr\u00f3pria pilha.</li> <li>Espa\u00e7o Livre: Espa\u00e7o entre a pilha e o heap, permitindo o crescimento de ambos conforme necess\u00e1rio.</li> <li>Heap: \u00c1rea usada para a aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica. Mem\u00f3ria \u00e9 alocada e desalocada conforme necess\u00e1rio durante a execu\u00e7\u00e3o do programa.</li> <li>Segmento de Dados: Cont\u00e9m vari\u00e1veis globais e est\u00e1ticas. Este segmento \u00e9 dividido em duas partes:<ul> <li>Segmento de Dados Inicializado: Armazena vari\u00e1veis globais e est\u00e1ticas que s\u00e3o inicializadas.</li> <li>BSS (Block Started by Symbol): Armazena vari\u00e1veis globais e est\u00e1ticas n\u00e3o inicializadas.</li> </ul> </li> <li>Segmento de C\u00f3digo: Cont\u00e9m o c\u00f3digo execut\u00e1vel do programa.</li> </ol> <p>Os endere\u00e7os da pilha crescem de cima para baixo, enquanto os endere\u00e7os do heap crescem de baixo para cima, conforme indicado pelas setas de crescimento no diagrama. Essa organiza\u00e7\u00e3o \u00e9 essencial para o gerenciamento eficiente da mem\u00f3ria e para garantir a integridade e desempenho do programa</p> <p></p> <p>Os caches, subdivididos em L1, L2 e L3, s\u00e3o mem\u00f3rias r\u00e1pidas de diferentes tamanhos e velocidades. O L1 \u00e9 o mais r\u00e1pido e menor, localizado dentro do n\u00facleo da CPU. O L2 \u00e9 maior e mais lento que o L1, mas ainda mais r\u00e1pido que a RAM, enquanto o L3, compartilhado entre os n\u00facleos do processador, \u00e9 maior e mais lento que o L2. Os registradores, pequenas quantidades de mem\u00f3ria dentro da CPU, s\u00e3o extremamente r\u00e1pidos e usados para opera\u00e7\u00f5es imediatas e tempor\u00e1rias.</p> <p></p> <ul> <li>Registradores: Pequenas quantidades de mem\u00f3ria dentro da CPU, extremamente r\u00e1pidas, usadas para opera\u00e7\u00f5es imediatas e tempor\u00e1rias. Tamanho: 64-128 bits.</li> <li>Cache L1: O cache mais r\u00e1pido e muito pequeno, localizado dentro do n\u00facleo da CPU. Tamanho: 32 KB.</li> <li>Cache L2: Maior e mais lento que o L1, mas ainda muito r\u00e1pido. Tamanho: 256 KB - 512 KB.</li> <li>Cache L3: Compartilhado entre os n\u00facleos do processador, \u00e9 maior e mais lento que o L2, mas ainda mais r\u00e1pido que a RAM. Tamanho: 2 MB - 16 MB.</li> <li>RAM: A mem\u00f3ria principal do sistema, maior em tamanho e a mais lenta em termos de velocidade comparada aos caches e registradores. Tamanho: 4 GB - 64 GB ou mais.</li> </ul> <p></p> <p>No contexto de HPC, escolher os tipos de dados adequados em C++ \u00e9 crucial por v\u00e1rias raz\u00f5es. </p> <ul> <li>Vari\u00e1veis menores ocupam menos espa\u00e7o, permitindo que mais dados sejam armazenados no cache ou na RAM, melhorando a localidade de cache e resultando em acessos mais r\u00e1pidos.</li> <li>A velocidade de processamento tamb\u00e9m \u00e9 impactada pela escolha dos tipos na declara\u00e7\u00e3o da vari\u00e1vel. A CPU processa tipos menores mais rapidamente, e instru\u00e7\u00f5es SIMD (Single Instruction, Multiple Data) podem processar m\u00faltiplos dados em paralelo se os tipos forem pequenos o suficiente para caberem nos registradores.</li> <li>A precis\u00e3o dos c\u00e1lculos \u00e9 outra considera\u00e7\u00e3o importante. Para c\u00e1lculos cient\u00edficos, a precis\u00e3o adicional dos <code>double</code> pode ser necess\u00e1ria para evitar erros num\u00e9ricos significativos, enquanto em gr\u00e1ficos e outras aplica\u00e7\u00f5es, <code>float</code> pode ser suficiente e mais eficiente em termos de mem\u00f3ria e processamento.</li> <li>Usar tipos menores de vari\u00e1veis reduzem a quantidade de dados transferidos entre n\u00f3s em um cluster, diminuindo a lat\u00eancia e a sobrecarga de comunica\u00e7\u00e3o.</li> </ul> <p>Considerar corretamente os tipos na cria\u00e7\u00e3o das vari\u00e1veis \u00e9 importante para maximizar a efici\u00eancia de uso de mem\u00f3ria, melhorar a velocidade e a precis\u00e3o dos c\u00e1lculos, otimizar o desempenho computacional, minimizar a fragmenta\u00e7\u00e3o de mem\u00f3ria, aproveitar melhor o paralelismo e reduzir a lat\u00eancia de comunica\u00e7\u00e3o, al\u00e9m de melhorar a localidade de cache e o acesso \u00e0 mem\u00f3ria. Compreender o mapa de mem\u00f3ria do computador e como os diferentes tipos de dados interagem com a CPU e a mem\u00f3ria pode levar a melhorias significativas no desempenho dos seus algoritmos.</p>"},{"location":"aulas/","title":"Entregas e Objetivos","text":"<p>atividade 01: Introdu\u00e7\u00e3o ao Curso - Contextualiza\u00e7\u00e3o do curso, introdu\u00e7\u00e3o a HPC, entender porque usamos C++ em HPC. </p> <p>atividade 02: Introdu\u00e7\u00e3o ao Cluster - Configurar o ambiente de desenvolvimento, submeter o primeiro job no Cluster Franky. </p> <p>atividade 02: SLURM - Entender como a solicita\u00e7\u00e3o de recursos impacta o tempo de execu\u00e7\u00e3o de uma tarefa  e compreender como pedir recursos ao SLURM.</p> <p>atividade 03: Introdu\u00e7\u00e3o ao C++ - Introdu\u00e7\u00e3o a c++.</p> <p>atividade 03: Usando o poder do C++ - Conhecer t\u00e9cnicas avan\u00e7adas de C++ que s\u00e3o essenciais para programar c\u00f3digos eficientes, seguros e preparados para escalar em aplica\u00e7\u00f5es de alta performance.</p> <p>atividade 04: Profiling - Entender como utilizar as flags de compila\u00e7\u00e3o e ferramentas de profiling para encontrar gargalos e melhorar o desempenho do c\u00f3digo.</p> <p>atividade 05: Busca Exaustiva - Entender como utilizar recurs\u00e3o para resolver o problema da mochila com busca exaustiva.  </p> <p>atividade 06: Heur\u00edstica Aleat\u00f3ria - Explorar heur\u00edsticas aleat\u00f3rias para resolver o problema da mochila. </p> <p>atividade 07: Busca Local Hill Climb - Entender como utilizar busca local e Hill Climb para resolver o problema da mochila. </p> <p>atividade 08: Problema da Mochila com Heur\u00edsticas - Entender como utilizar diferentes heur\u00edsticas para resolver o problema da mochila. </p> <p>atividade 09: Thrust para programa\u00e7\u00e3o paralela em GPU - Introdu\u00e7\u00e3o a Thrust.</p> <p>atividade 10: Iteradores e fun\u00e7\u00f5es customizadas  - Introdu\u00e7\u00e3o a iteradores e fun\u00e7\u00f5es customizadas.</p> <p>atividade 11: Fun\u00e7\u00f5es Customizadas e Otimiza\u00e7\u00e3o com Fusion Kernel  - Criar opera\u00e7\u00f5es customizadas usando functors, entender como combinar transforma\u00e7\u00f5es e redu\u00e7\u00f5es, e explorar a otimiza\u00e7\u00e3o com fusion kernel.</p> <p>atividade 12: Trabalhando com Schedulers no OpenMP   - Explorar diferentes schedulers do OpenMP, implementar paraleliza\u00e7\u00e3o de loops e recurs\u00f5es usando parallel for e tasks, e analisar estrat\u00e9gias para lidar com efeitos colaterais em regi\u00f5es paralelas, como o uso de omp critical e pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria. </p> <p>atividade 13: Pi pelo m\u00e9todo de Monte Carlo - Explorar o c\u00e1lculo de pi usando o m\u00e9todo Monte Carlo como exemplo de paralelismo. Aplicar diferentes t\u00e9cnicas de paralelismo para otimizar o desempenho. Analisar o impacto dessas t\u00e9cnicas na sincroniza\u00e7\u00e3o de vari\u00e1veis compartilhadas e na gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios. Comparar os resultados em termos de precis\u00e3o e ganho de performance ao paralelizar o algoritmo.</p>"},{"location":"aulas/01-introducao/","title":"Aula 01: A import\u00e2ncia da linguagem","text":"<p>Nesta atividade, veremos como a escolha da linguagem de programa\u00e7\u00e3o pode melhorar significativamente o desempenho de opera\u00e7\u00f5es computacionalmente intensivas. Utilizaremos Python e C++ para implementar e comparar o desempenho na multiplica\u00e7\u00e3o de matrizes, uma opera\u00e7\u00e3o comum em muitas aplica\u00e7\u00f5es de IA e vis\u00e3o computacional.</p>"},{"location":"aulas/01-introducao/#parte-1-implementacao-basica-em-python","title":"Parte 1: Implementa\u00e7\u00e3o B\u00e1sica em Python","text":"<p>Execute o c\u00f3digo abaixo e observe o tempo de execu\u00e7\u00e3o. Essa \u00e9 uma implementa\u00e7\u00e3o sequencial que processa a multiplica\u00e7\u00e3o de matrizes usando uma \u00fanica thread em python.</p> <pre><code>import time  # Importa o m\u00f3dulo time, que fornece fun\u00e7\u00f5es para medir o tempo de execu\u00e7\u00e3o do c\u00f3digo.\n\ndef multiply_matrices(A, B):\n    # Define a fun\u00e7\u00e3o multiply_matrices, que realiza a multiplica\u00e7\u00e3o de duas matrizes A e B.\n    # O resultado \u00e9 armazenado na matriz result.\n    result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))]\n    # Cria uma matriz de zeros com o mesmo n\u00famero de linhas que A e o mesmo n\u00famero de colunas que B.\n    # Esta matriz armazenar\u00e1 os resultados da multiplica\u00e7\u00e3o.\n\n    for i in range(len(A)):\n        # Itera sobre as linhas da matriz A.\n        for j in range(len(B[0])):\n            # Itera sobre as colunas da matriz B.\n            for k in range(len(B)):\n                # Itera sobre as colunas de A e as linhas de B para calcular o produto escalar da linha i de A com a coluna j de B.\n                result[i][j] += A[i][k] * B[k][j]\n                # Realiza a multiplica\u00e7\u00e3o dos elementos correspondentes de A e B e soma o resultado ao elemento result[i][j].\n\n    return result\n    # Retorna a matriz result, que cont\u00e9m o produto das matrizes A e B.\n\n# Gerar duas matrizes de tamanho grande para o teste\nN = 200  # Define o tamanho N das matrizes quadradas (200x200).\n\nA = [[i + j for j in range(N)] for i in range(N)]\n# Gera a matriz A de tamanho N x N, onde cada elemento A[i][j] \u00e9 a soma dos \u00edndices i e j.\n\nB = [[i * j for j in range(N)] for i in range(N)]\n# Gera a matriz B de tamanho N x N, onde cada elemento B[i][j] \u00e9 o produto dos \u00edndices i e j.\n\nstart_time = time.time()\n# Marca o tempo de in\u00edcio da multiplica\u00e7\u00e3o das matrizes usando a fun\u00e7\u00e3o time.time().\n\nresult = multiply_matrices(A, B)\n# Chama a fun\u00e7\u00e3o multiply_matrices para multiplicar as matrizes A e B, armazenando o resultado em 'result'.\n\nend_time = time.time()\n# Marca o tempo de t\u00e9rmino da multiplica\u00e7\u00e3o usando a fun\u00e7\u00e3o time.time().\n\nprint(f\"Tempo de execu\u00e7\u00e3o para a multiplica\u00e7\u00e3o de matrizes: {end_time - start_time:.2f} segundos\")\n# Calcula e exibe o tempo de execu\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes, subtraindo start_time de end_time.\n# O tempo \u00e9 formatado para mostrar duas casas decimais.\n</code></pre>"},{"location":"aulas/01-introducao/#parte-2-implementacao-em-c","title":"Parte 2: Implementa\u00e7\u00e3o em C++","text":"<p>Compile e execute o c\u00f3digo em C++. Compare o tempo de execu\u00e7\u00e3o com o resultado obtido na Parte 1. Observe como C++ lida com opera\u00e7\u00f5es computacionalmente intensivas de forma mais eficiente.</p> <p>Tip</p> <p>Se precisar de ajuda para instalar um compilador em C++ ou compilar e executar c\u00f3digos em c++, consulte o material dispon\u00edvel.</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda do C++ (necess\u00e1ria para usar std::cout).\n#include &lt;vector&gt;     // Inclui a biblioteca de vetores da STL (Standard Template Library) do C++, usada para criar matrizes din\u00e2micas.\n#include &lt;chrono&gt;     // Inclui a biblioteca de medi\u00e7\u00e3o de tempo do C++ (necess\u00e1ria para medir o tempo de execu\u00e7\u00e3o).\n\n// Fun\u00e7\u00e3o para multiplicar duas matrizes A e B, armazenando o resultado na matriz 'result'.\nvoid multiply_matrices(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {\n   // Loop para iterar sobre as linhas da matriz A.\n   for (size_t i = 0; i &lt; A.size(); ++i) {\n      // Loop para iterar sobre as colunas da matriz B.\n      for (size_t j = 0; j &lt; B[0].size(); ++j) {\n            result[i][j] = 0; // Inicializa o elemento result[i][j] com 0 antes de somar os produtos.\n            // Loop para calcular o produto escalar da linha i de A com a coluna j de B.\n            for (size_t k = 0; k &lt; B.size(); ++k) {\n               result[i][j] += A[i][k] * B[k][j]; // Realiza a multiplica\u00e7\u00e3o e soma dos elementos correspondentes de A e B.\n            }\n      }\n   }\n}\n\n// Fun\u00e7\u00e3o principal do programa.\nint main() {\n   size_t N = 200; // Define o tamanho N das matrizes quadradas (200x200).\n\n   // Declara e inicializa a matriz A como uma matriz NxN preenchida com zeros.\n   std::vector&lt;std::vector&lt;int&gt;&gt; A(N, std::vector&lt;int&gt;(N));\n\n   // Declara e inicializa a matriz B como uma matriz NxN preenchida com zeros.\n   std::vector&lt;std::vector&lt;int&gt;&gt; B(N, std::vector&lt;int&gt;(N));\n\n   // Declara e inicializa a matriz result como uma matriz NxN preenchida com zeros, que armazenar\u00e1 o resultado da multiplica\u00e7\u00e3o.\n   std::vector&lt;std::vector&lt;int&gt;&gt; result(N, std::vector&lt;int&gt;(N));\n\n   // Loop para preencher as matrizes A e B com valores.\n   for (size_t i = 0; i &lt; N; ++i) {\n      for (size_t j = 0; j &lt; N; ++j) {\n            A[i][j] = i + j; // Preenche a matriz A com a soma dos \u00edndices i e j.\n            B[i][j] = i * j; // Preenche a matriz B com o produto dos \u00edndices i e j.\n      }\n   }\n\n   // Marca o tempo de in\u00edcio da multiplica\u00e7\u00e3o das matrizes usando o rel\u00f3gio de alta resolu\u00e7\u00e3o.\n   auto start = std::chrono::high_resolution_clock::now();\n\n   // Chama a fun\u00e7\u00e3o multiply_matrices para multiplicar as matrizes A e B, armazenando o resultado em 'result'.\n   multiply_matrices(A, B, result);\n\n   // Marca o tempo de t\u00e9rmino da multiplica\u00e7\u00e3o.\n   auto end = std::chrono::high_resolution_clock::now();\n\n   // Calcula a dura\u00e7\u00e3o da multiplica\u00e7\u00e3o subtraindo o tempo de in\u00edcio do tempo de t\u00e9rmino, armazenando o resultado em 'duration'.\n   std::chrono::duration&lt;double&gt; duration = end - start;\n\n   // Exibe o tempo de execu\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes no console.\n   std::cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o para a multiplica\u00e7\u00e3o de matrizes em C++: \" &lt;&lt; duration.count() &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n\n   return 0; // Retorna 0, indicando que o programa foi executado com sucesso.\n}\n</code></pre>"},{"location":"aulas/01-introducao/#parte-3-paralelismo-em-c","title":"Parte 3: Paralelismo em C++","text":"<p>Compile e execute o c\u00f3digo modificado usando o comando '-fopenmp' para ter suporte ao paralelismo. Observe a diferen\u00e7a no tempo de execu\u00e7\u00e3o em compara\u00e7\u00e3o com as vers\u00f5es anteriores.</p> <pre><code>g++ -fopenmp  meu_programa.cpp -o meu_executavel_paralelo\n</code></pre> <p>Warning</p> <p>Lembre-se! Sempre que fizer altera\u00e7\u00f5es no seu c\u00f3digo em c++, \u00e9 necess\u00e1rio gerar um novo bin\u00e1rio.</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda, usada para fun\u00e7\u00f5es como std::cout.\n#include &lt;vector&gt;     // Inclui a biblioteca de vetores da STL (Standard Template Library) do C++.\n#include &lt;chrono&gt;     // Inclui a biblioteca para medi\u00e7\u00e3o de tempo, utilizada para calcular a dura\u00e7\u00e3o de execu\u00e7\u00e3o.\n#include &lt;omp.h&gt;      // Inclui a biblioteca OpenMP, usada para paralelismo em C++.\n\nvoid multiply_matrices(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {\n    // Define a fun\u00e7\u00e3o que realiza a multiplica\u00e7\u00e3o de duas matrizes A e B, armazenando o resultado na matriz 'result'.\n    #pragma omp parallel for\n    // Diretiva OpenMP que paraleliza o loop 'for' que segue. Cada itera\u00e7\u00e3o do loop externo ser\u00e1 executada em paralelo.\n    for (size_t i = 0; i &lt; A.size(); ++i) {\n        // Itera sobre as linhas da matriz A. 'size_t' \u00e9 um tipo de dado usado para representar tamanhos e \u00edndices.\n        for (size_t j = 0; j &lt; B[0].size(); ++j) {\n            // Itera sobre as colunas da matriz B.\n            result[i][j] = 0;\n            // Inicializa o elemento [i][j] da matriz result com 0 antes de somar os produtos.\n            for (size_t k = 0; k &lt; B.size(); ++k) {\n                // Itera sobre as colunas de A e as linhas de B para calcular o produto escalar da linha i de A com a coluna j de B.\n                result[i][j] += A[i][k] * B[k][j];\n                // Realiza a multiplica\u00e7\u00e3o dos elementos correspondentes de A e B, somando o resultado ao elemento result[i][j].\n            }\n        }\n    }\n}\n\nint main() {\n    size_t N = 200;\n    // Define o tamanho N das matrizes quadradas (200x200).\n    std::vector&lt;std::vector&lt;int&gt;&gt; A(N, std::vector&lt;int&gt;(N));\n    // Declara e inicializa a matriz A como uma matriz NxN preenchida com zeros.\n    std::vector&lt;std::vector&lt;int&gt;&gt; B(N, std::vector&lt;int&gt;(N));\n    // Declara e inicializa a matriz B como uma matriz NxN preenchida com zeros.\n    std::vector&lt;std::vector&lt;int&gt;&gt; result(N, std::vector&lt;int&gt;(N));\n    // Declara e inicializa a matriz result como uma matriz NxN preenchida com zeros, que armazenar\u00e1 o resultado da multiplica\u00e7\u00e3o.\n\n    for (size_t i = 0; i &lt; N; ++i) {\n        // Itera sobre as linhas da matriz A e B.\n        for (size_t j = 0; j &lt; N; ++j) {\n            // Itera sobre as colunas da matriz A e B.\n            A[i][j] = i + j;\n            // Preenche a matriz A com valores como a soma dos \u00edndices i e j.\n            B[i][j] = i * j;\n            // Preenche a matriz B com valores como o produto dos \u00edndices i e j.\n        }\n    }\n\n    auto start = std::chrono::high_resolution_clock::now();\n    // Marca o tempo de in\u00edcio da multiplica\u00e7\u00e3o das matrizes usando o rel\u00f3gio de alta resolu\u00e7\u00e3o.\n    multiply_matrices(A, B, result);\n    // Chama a fun\u00e7\u00e3o multiply_matrices para multiplicar as matrizes A e B, armazenando o resultado em 'result'.\n    auto end = std::chrono::high_resolution_clock::now();\n    // Marca o tempo de t\u00e9rmino da multiplica\u00e7\u00e3o.\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    // Calcula a dura\u00e7\u00e3o da multiplica\u00e7\u00e3o subtraindo o tempo de in\u00edcio do tempo de t\u00e9rmino, armazenando o resultado em 'duration'.\n    std::cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o para a multiplica\u00e7\u00e3o de matrizes em C++ com OpenMP: \" &lt;&lt; duration.count() &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n    // Exibe o tempo de execu\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes no console.\n\n    return 0;\n    // Retorna 0, indicando que o programa foi executado com sucesso.\n}\n</code></pre> <p>Esta atividade demonstrou como a escolha da linguagem de programa\u00e7\u00e3o pode impactar no desempenho de opera\u00e7\u00f5es computacionalmente intensivas, como a multiplica\u00e7\u00e3o de matrizes. Voc\u00ea viu como Python e C++ lidam com essas opera\u00e7\u00f5es e como o paralelismo pode ser uma boa op\u00e7\u00e3o, dependendo da complexidade do problema. Na pr\u00f3xima atividade, voc\u00ea levar\u00e1 essas implementa\u00e7\u00f5es para o cluster Franky e essas diferen\u00e7as ficar\u00e3o ainda mais vis\u00edveis.</p> <p>Tip</p> <p>Se quiser saber um pouco mais sobre HPC, relembrar conceitos ou aprofundar um pouco em C++</p>"},{"location":"aulas/01-introducao/#entrega-atividade-01","title":"Entrega - Atividade 01","text":"<ul> <li> <p>Aumente o tamanho das matrizes nos 3 exemplos para 300x300, 900x900 e 1300x1300 </p> </li> <li> <p>Elabore um gr\u00e1fico que relaciona a complexidade do problema (tamanho da matriz) com o tempo de execu\u00e7\u00e3o para cada implementa\u00e7\u00e3o.</p> </li> <li> <p>Fa\u00e7a uma an\u00e1lise comparativa sobre o impacto do paralelismo no desempenho de acordo com a complexidade do problema.</p> </li> <li> <p>Comente sobre como voc\u00ea acha que este problema pode ser abordado em um ambiente de HPC.</p> </li> </ul> <p>Submeta seu relat\u00f3rio at\u00e9 as 23h59 de 07/02 pelo Classroom, dispon\u00edvel no Blackboard.</p>"},{"location":"aulas/02-introducao/","title":"Aula 02: Acessando o Cluster Franky","text":"<p>Na Atividade 2, voc\u00ea ir\u00e1 executar as implementa\u00e7\u00f5es que foram testadas na Atividade 1, mas agora no ambiente de um cluster HPC usando SLURM. O objetivo \u00e9 observar como o ambiente de cluster, com sua capacidade de processamento paralelo, pode impactar o desempenho das opera\u00e7\u00f5es computacionalmente intensivas que voc\u00ea j\u00e1 explorou.</p>"},{"location":"aulas/02-introducao/#parte-0-configurando-seu-acesso-ao-cluster-franky","title":"Parte 0: Configurando seu acesso ao Cluster Franky","text":"<p>Para ter acesso ao Cluster Franky voc\u00ea precisa configurar suas credenciais de acesso e realizar acesso remoto via SSH.</p> <p>Entre no Blackboard, navegue at\u00e9 a se\u00e7\u00e3o de materiais do curso onde a pasta com o par de chaves foi disponibilizada, Fa\u00e7a o download da pasta completa, que cont\u00e9m os arquivos <code>id_rsa</code> (chave privada) e <code>id_rsa.pub</code> (chave p\u00fablica). Dependendo do sistema operacional que voc\u00ea utiliza, siga as instru\u00e7\u00f5es abaixo para configurar  corretamente sua chave privada.</p>"},{"location":"aulas/02-introducao/#para-macbook-ou-linux","title":"Para Macbook ou Linux:","text":"<p>Abra o terminal, navegue at\u00e9 a pasta onde a chave privada (<code>id_rsa</code>) foi baixada, mova a chave para o diret\u00f3rio <code>.ssh</code> em sua home:</p> <pre><code>mv id_rsa ~/.ssh/\n</code></pre> <p>Garanta que apenas voc\u00ea possa ler o arquivo:</p> <pre><code>chmod 400 ~/.ssh/id_rsa\n</code></pre> <p>Conecte-se ao cluster utilizando o comando SSH:</p> <p>Substitua <code>nome_da_pasta</code> pelo nome que est\u00e1 na pasta com as chaves que voc\u00ea baixou no BlackBoard e <code>cluster_endereco</code> pelo endere\u00e7o de IP fornecido durante a aula.</p> <p><pre><code>ssh -i ~/.ssh/id_rsa nome_da_pasta@ip_do_cluster\n</code></pre> ou</p> <pre><code>ssh nome_da_pasta@ip_do_cluster\n</code></pre>"},{"location":"aulas/02-introducao/#para-windows","title":"Para Windows:","text":"<p>Usando OpenSSH :</p> <p>Abra o PowerShell ou Windows Terminal. Navegue at\u00e9 a pasta onde a chave privada (<code>id_rsa</code>) foi baixada, mova a chave para a pasta <code>.ssh</code> em seu diret\u00f3rio de usu\u00e1rio:</p> <pre><code>mkdir $env:USERPROFILE\\.ssh\nmv id_rsa $env:USERPROFILE\\.ssh\\\n</code></pre> <p>Certifique-se de que as permiss\u00f5es est\u00e3o corretas: <pre><code>icacls $env:USERPROFILE\\.ssh\\id_rsa /inheritance:r /grant:r \"$($env:USERNAME):(R)\"\n</code></pre> Conecte-se ao cluster usando o comando: <pre><code>ssh -i $env:USERPROFILE\\.ssh\\id_rsa seu_usuario_insper@ip_do_cluster\n</code></pre></p>"},{"location":"aulas/02-introducao/#configurar-o-vs-code-para-acesso-remoto-ao-cluster","title":"Configurar o VS Code para Acesso Remoto ao Cluster**","text":"<p>Instale a Extens\u00e3o Remote - SSH:</p> <p>Abra o VS Code, v\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo). Pesquise por \"Remote - SSH\" e instale a extens\u00e3o oficial da Microsoft.</p> <p>Configurar o Acesso Remoto:</p> <p>Pressione <code>Ctrl+Shift+P</code> (ou <code>Cmd+Shift+P</code> no Mac) para abrir o painel de comandos.</p> <p>Digite <code>Remote-SSH: Add New SSH Host...</code> e selecione a op\u00e7\u00e3o.</p> <p>Insira o comando SSH que voc\u00ea utilizou anteriormente: <pre><code>ssh -i ~/.ssh/id_rsa nome_da_pasta@ip_do_cluster\n</code></pre> Escolha o arquivo de configura\u00e7\u00e3o padr\u00e3o (<code>~/.ssh/config</code> para Mac/Linux ou <code>C:\\Users\\seu_usuario\\.ssh\\config</code> para Windows).</p> <p>Pressione <code>Ctrl+Shift+P</code> (ou <code>Cmd+Shift+P</code> no Mac) novamente e digite <code>Remote-SSH: Connect to Host...</code>. Selecione o host configurado.</p> <p>O VS Code abrir\u00e1 uma nova janela conectada ao ambiente remoto do cluster.</p> <p></p> <p>Gerenciar Projetos Remotamente:</p> <p>Ap\u00f3s a conex\u00e3o, voc\u00ea pode abrir pastas e arquivos no cluster diretamente pelo VS Code.</p> <p>Utilize os recursos do VS Code, como o terminal integrado e o debug para trabalhar no cluster Franky.</p>"},{"location":"aulas/02-introducao/#executando-a-atividade-0-no-cluster-franky-usando-slurm","title":"Executando a Atividade 0 no Cluster Franky usando SLURM","text":"<p>Um arquivo .slurm \u00e9 usado para \"lan\u00e7ar jobs\" no sistema SLURM, especificando os recursos necess\u00e1rios para a execu\u00e7\u00e3o, como mem\u00f3ria, n\u00famero de m\u00e1quinas e n\u00facleos. Nesse arquivo, tamb\u00e9m definimos como desejamos o output do execut\u00e1vel e onde o sistema pode encontrar o arquivo a ser executado. Como a equipe que gerencia o Cluster definiu que os jobs sejam lan\u00e7ados apenas da pasta SCRATCH, podemos omitir o caminho do arquivo nos nossos arquivos .slurm.</p> <p>Warning</p> <p>As instru\u00e7\u00f5es #SBATCH s\u00e3o tecnicamente consideradas \"coment\u00e1rios\" pelo interpretador de comandos do shell (bash), mas n\u00e3o s\u00e3o realmente ignoradas. Quando voc\u00ea escreve um script para ser executado pelo SLURM, o bash interpreta as linhas #SBATCH como coment\u00e1rios normais, enquanto o gerenciador de jobs SLURM interpreta essas mesmas linhas como diretivas que definem como o job deve ser executado.</p> <p>Tip</p> <p>N\u00e3o \u00e9 necess\u00e1rio neste momento, mas se voc\u00ea quiser transferir arquivos da sua m\u00e1quina para o cluster e vice versa, voc\u00ea pode usar o comando scp mais detalhes aqui</p> <p>Crie um script de submiss\u00e3o .slurm para cada implementa\u00e7\u00e3o utilizando os exemplos abaixo. Esse script ser\u00e1 utilizado para enviar o job ao cluster.</p> <p>Script SLURM para o c\u00f3digo em Python:</p> <p>matriz_mult_python.slurm</p> <pre><code>#!/bin/bash\n#As instru\u00e7\u00f5es SBATCH n\u00e3o devem ser descomentadas\n\n#SBATCH --job-name=mult_matriz_py\n# define o nome do job. Esse nome aparece nas listas de jobs e \u00e9 \u00fatil para identificar o job.\n\n#SBATCH --output=mult_matriz_py.out\n# Especifica o arquivo onde a sa\u00edda padr\u00e3o (stdout) do job ser\u00e1 salva.\n\n#SBATCH --ntasks=1\n# Define o n\u00famero de tarefas que o job executar\u00e1. Neste caso, o job executa uma \u00fanica tarefa.\n\n#SBATCH --time=00:10:00\n# Define o tempo m\u00e1ximo de execu\u00e7\u00e3o para o job. Neste caso, o job tem um tempo limite de 10 minutos. Se o job exceder esse tempo, ele ser\u00e1 automaticamente encerrado.\n\n#SBATCH --partition=normal\n# Especifica a parti\u00e7\u00e3o (ou fila) onde o job ser\u00e1 submetido. Aqui, o job ser\u00e1 submetido a fila \"normal\".\n\npython3 mult_matriz_py.py\n#Executa o programa python3 dentro do n\u00f3 de computa\u00e7\u00e3o.\n</code></pre> <p>Script SLURM para arquivos C++:</p> <p>Como o C++ \u00e9 uma linguagem que requer compila\u00e7\u00e3o, precisamos gerar o execut\u00e1vel antes de preparar o arquivo .slurm.</p> <p>Dentro da pasta SCRATCH, compile seu c\u00f3digo .cpp para gerar o bin\u00e1rio.</p> <pre><code>g++  mult_matriz_cpp.cpp -o mult_matriz_cpp \n</code></pre> <p>matriz_mult_cpp.slurm</p> <pre><code>#!/bin/bash\n#SBATCH --job-name=matriz_mult_cpp\n# Define o nome do job como \"matrix_mult_openmp\". Esse nome aparece nas listas de jobs e \u00e9 \u00fatil para identificar o job.\n\n#SBATCH --output=matriz_mult_cpp.out\n# Especifica o arquivo onde a sa\u00edda padr\u00e3o (stdout) do job ser\u00e1 salva.\n\n#SBATCH --ntasks=1\n# Define o n\u00famero de tarefas que o job executar\u00e1. Neste caso, o job executa uma \u00fanica tarefa.\n\n#SBATCH --time=00:10:00\n# Define o tempo m\u00e1ximo de execu\u00e7\u00e3o para o job. Neste caso, o job tem um tempo limite de 10 minutos. Se o job exceder esse tempo, ele ser\u00e1 automaticamente encerrado.\n\n#SBATCH --partition=normal\n# Especifica a parti\u00e7\u00e3o (ou fila) onde o job ser\u00e1 submetido. Aqui, o job ser\u00e1 submetido a fila \"normal\".\n\n\n./mult_matriz_cpp\n# Executa o programa compilado \"mult_matriz_cpp\" dentro do n\u00f3 de computa\u00e7\u00e3o.\n</code></pre> <p>Script SLURM para arquivos C++ com Paralelismo:</p> <p>Ao utilizar o OpenMP para paralelizar c\u00f3digos em C++, \u00e9 necess\u00e1rio incluir a flag apropriada durante a compila\u00e7\u00e3o. Essa flag informa ao compilador para interpretar corretamente as diretivas OpenMP no c\u00f3digo e gerar o bin\u00e1rio de forma adequada.</p> <pre><code>g++ -fopenmp mult_matriz_paralelo.cpp -o mult_matriz_paralelo\n</code></pre> <p>matriz_mult_paralelo.slurm</p> <pre><code>#!/bin/bash\n\n#SBATCH --job-name=matriz_mult_paralelo\n# Define o nome do job como \"matrix_mult_paralelo\". Esse nome aparece nas listas de jobs e \u00e9 \u00fatil para identificar o job.\n\n#SBATCH --output=matriz_mult_paralelo.out\n# Especifica o arquivo onde a sa\u00edda padr\u00e3o (stdout) do job ser\u00e1 salva.\n\n#SBATCH --ntasks=1\n# Define o n\u00famero de tarefas que o job executar\u00e1. Neste caso, o job executa uma \u00fanica tarefa.\n\n#SBATCH --cpus-per-task=4\n# Especifica o n\u00famero de CPUs que devem ser alocadas para esta tarefa.\n\n#SBATCH --time=00:10:00\n# Define o tempo m\u00e1ximo de execu\u00e7\u00e3o para o job. Neste caso, o job tem um tempo limite de 10 minutos. Se o job exceder esse tempo, ele ser\u00e1 automaticamente encerrado.\n\n#SBATCH --partition=normal\n# Especifica a parti\u00e7\u00e3o (ou fila) onde o job ser\u00e1 submetido. Aqui, o job ser\u00e1 submetido a fila \"normal\".\n\n\n./mult_matriz_paralelo\n# Executa o programa compilado \"mult_matriz_paralelo\" dentro do n\u00f3 de computa\u00e7\u00e3o.\n</code></pre>"},{"location":"aulas/02-introducao/#parte-2-execucao-das-implementacoes-no-cluster","title":"Parte 2: Execu\u00e7\u00e3o das Implementa\u00e7\u00f5es no Cluster","text":"<p>Submiss\u00e3o dos Jobs:</p> <p>Utilize o comando <code>sbatch</code> para submeter cada script SLURM ao cluster.</p> <p>Exemplo:</p> <pre><code>sbatch matriz_mult_python.slurm\nsbatch matriz_mult_cpp.slurm\nsbatch matriz_mult_paralelo.slurm\n</code></pre> <p>Monitoramento dos Jobs:</p> <p>Use o comando <code>squeue</code> para monitorar o status dos jobs.</p> <p>Exemplo:</p> <pre><code>squeue \n</code></pre> <p>An\u00e1lise dos Resultados:</p> <p>Ap\u00f3s a execu\u00e7\u00e3o dos jobs, os resultados estar\u00e3o dispon\u00edveis nos arquivos <code>.out</code>  especificados em cada script SLURM.</p> <ul> <li> <p>Compare os tempos de execu\u00e7\u00e3o dos tr\u00eas m\u00e9todos (Python, C++, C++ com OpenMP) no cluster.</p> </li> <li> <p>Analise como o paralelismo afeta o desempenho no ambiente do cluster, em compara\u00e7\u00e3o com sua execu\u00e7\u00e3o local.</p> </li> </ul> <p>Tip</p> <p>Se quiser explorar mais os comandos do SLURM, temos uma material aqui que pode te ajudar</p> <p>Entrega Atividade 2 - Relat\u00f3rio de Desempenho:</p> <ul> <li> <p>Prepare um relat\u00f3rio detalhado, incluindo gr\u00e1ficos que mostrem a rela\u00e7\u00e3o entre o tamanho das matrizes e o tempo de execu\u00e7\u00e3o para cada implementa\u00e7\u00e3o.</p> </li> <li> <p>Discuta o impacto do ambiente HPC no desempenho das opera\u00e7\u00f5es e como o paralelismo pode escalar em um cluster de m\u00faltiplos n\u00f3s.</p> </li> <li> <p>Submeta seu relat\u00f3rio at\u00e9 as 23h59 de 10/02 pelo Classroom, dispon\u00edvel no Blackboard.</p> </li> </ul> <p>Nesta atividade, voc\u00ea explorou como o ambiente de cluster, pode ser utilizado para otimizar e acelerar opera\u00e7\u00f5es que s\u00e3o intensivas em termos computacionais. Isso oferece uma base s\u00f3lida para entender como tarefas de grande escala, como o processamento de big data ou o treinamento de modelos de IA, podem ser significativamente aceleradas com HPC.</p>"},{"location":"aulas/02-slurm/","title":"Explorando Comandos SLURM","text":"<p>Objetivo: Entender como a solicita\u00e7\u00e3o de recursos impacta o tempo de execu\u00e7\u00e3o de uma tarefa e compreender como pedir recursos ao SLURM.</p> <p>Recursos Necess\u00e1rios: Acesso ao cluster Franky configurado.</p>"},{"location":"aulas/02-slurm/#programa-c-para-realizar-a-convolucao-de-uma-matriz","title":"Programa C++ para realizar a convolu\u00e7\u00e3o de uma matriz","text":"<p>Crie um arquivo chamado <code>convolucao.cpp</code> com o seguinte conte\u00fado:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;mpi.h&gt;\n#include &lt;omp.h&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n\n#define N 300\n#define FILTER_SIZE 11\n#define ITERATIONS 10\n\n// Fun\u00e7\u00e3o para alocar dinamicamente uma matriz NxN\nint** aloca_matriz(int n) {\n    int** matriz = new int*[n];\n    for (int i = 0; i &lt; n; i++) {\n        matriz[i] = new int[n]();\n    }\n    return matriz;\n}\n\n// Fun\u00e7\u00e3o para liberar mem\u00f3ria da matriz NxN\nvoid libera_matriz(int** matriz, int n) {\n    if (matriz) {\n        for (int i = 0; i &lt; n; i++) {\n            delete[] matriz[i];\n        }\n        delete[] matriz;\n    }\n}\n\n// Fun\u00e7\u00e3o de convolu\u00e7\u00e3o\nint apply_filter(int x, int y, int** matrix, int filter[FILTER_SIZE][FILTER_SIZE]) {\n    int result = 0;\n    int filter_offset = FILTER_SIZE / 2;\n\n    for (int i = -filter_offset; i &lt;= filter_offset; i++) {\n        for (int j = -filter_offset; j &lt;= filter_offset; j++) {\n            int xi = x + i;\n            int yj = y + j;\n\n            // Garantindo que os \u00edndices est\u00e3o dentro dos limites da matriz\n            if (xi &gt;= 0 &amp;&amp; xi &lt; N &amp;&amp; yj &gt;= 0 &amp;&amp; yj &lt; N) {\n                int value = matrix[xi][yj] * filter[i + filter_offset][j + filter_offset];\n                result += value;\n                result += std::sin(value) * std::cos(value); \n                result += static_cast&lt;int&gt;(std::pow(value, 2)) % 7;\n            }\n        }\n    }\n    return result;\n}\n\nint main(int argc, char *argv[]) {\n    MPI_Init(&amp;argc, &amp;argv);\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;size);\n\n    // Aloca as matrizes dinamicamente\n    int** matrix = aloca_matriz(N);\n    int** result = aloca_matriz(N);\n    int filter[FILTER_SIZE][FILTER_SIZE];\n\n    // Inicializa a matriz apenas no processo mestre (rank 0)\n    if (rank == 0) {\n        for (int i = 0; i &lt; N; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                matrix[i][j] = (i + j) % 255; // Mant\u00e9m valores entre 0-255\n            }\n        }\n\n        for (int i = 0; i &lt; FILTER_SIZE; i++) {\n            for (int j = 0; j &lt; FILTER_SIZE; j++) {\n                filter[i][j] = 1; // Filtro simples\n            }\n        }\n    }\n\n    MPI_Barrier(MPI_COMM_WORLD);\n    auto start = std::chrono::high_resolution_clock::now();\n\n    // Enviar matriz para todos os processos (transmitindo linha por linha para evitar erros de buffer)\n    for (int i = 0; i &lt; N; i++) {\n        MPI_Bcast(matrix[i], N, MPI_INT, 0, MPI_COMM_WORLD);\n    }\n\n    // Definir quantas linhas cada processo vai processar\n    int rows_per_process = N / size;\n    int start_row = rank * rows_per_process;\n    int end_row = (rank == size - 1) ? N : start_row + rows_per_process;\n\n    for (int iter = 0; iter &lt; ITERATIONS; iter++) {\n        #pragma omp parallel for collapse(2) schedule(dynamic, 1)\n        for (int i = start_row; i &lt; end_row; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                result[i][j] = apply_filter(i, j, matrix, filter);\n            }\n        }\n\n\n        int recvcounts[size];  // N\u00famero de elementos que cada processo enviar\u00e1\n        int displs[size];      // Deslocamento de onde cada processo come\u00e7a no buffer global\n\n        for (int i = 0; i &lt; size; i++) {\n            recvcounts[i] = (i == size - 1) ? (N - i * rows_per_process) * N : rows_per_process * N;\n            displs[i] = i * rows_per_process * N;\n        }\n\n        MPI_Gatherv(result[start_row], rows_per_process * N, MPI_INT,\n                    matrix[0], recvcounts, displs, MPI_INT,\n                    0, MPI_COMM_WORLD);\n    }\n\n    MPI_Barrier(MPI_COMM_WORLD);\n    auto end = std::chrono::high_resolution_clock::now();\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    double exec_time = duration.count();\n\n    double max_exec_time;\n    MPI_Reduce(&amp;exec_time, &amp;max_exec_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) {\n        std::cout &lt;&lt; \"A tarefa levou \" &lt;&lt; max_exec_time &lt;&lt; \" segundos para ser executada\" &lt;&lt; std::endl;\n    }\n\n    // Libera mem\u00f3ria das matrizes\n    libera_matriz(matrix, N);\n    libera_matriz(result, N);\n\n    MPI_Finalize();\n    return 0;\n}\n</code></pre> <p>Compile o programa dentro do Cluster:</p> <pre><code>mpic++ -fopenmp convolucao.cpp -o convolucao\n</code></pre>"},{"location":"aulas/02-slurm/#criacao-de-scripts-slurm","title":"Cria\u00e7\u00e3o de Scripts SLURM","text":"<p>Crie um arquivo convolucao_limitado.slurm com a seguinte configura\u00e7\u00e3o:</p> <p><pre><code>#!/bin/bash\n#SBATCH --job-name=convolucao_limitado    # Nome do job\n#SBATCH --output=limitado_%j.txt   # Gera um novo arquivo de sa\u00edda a cada execu\u00e7\u00e3o\n#SBATCH --ntasks=1                               # N\u00famero de tarefas (apenas 1 processos)\n#SBATCH --cpus-per-task=1                        # N\u00famero de threads por tarefa (apenas 1 thread por processo)\n#SBATCH --mem=512MB                             # Mem\u00f3ria total alocada por n\u00f3 (512 MB)\n#SBATCH --time=00:10:00                          # Tempo m\u00e1ximo de execu\u00e7\u00e3o (at\u00e9 10 minutos)\n#SBATCH --partition=espec                       # Fila do cluster a ser utilizada\n\n# Exporta a vari\u00e1vel de ambiente para configurar o n\u00famero de threads OpenMP\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n# Executa o programa usando MPI e OpenMP\nmpirun ./convolucao\n</code></pre> Este .slurm submete um job que executa 1 tarefas, com 1 CPU por tarefa, 512MB de mem\u00f3ria por n\u00f3, e um tempo m\u00e1ximo de execu\u00e7\u00e3o de 10 minutos.</p> <p>Vamos solicitar mais recursos e ver o que acontece, crie um arquivo convolucao_buffado.slurm com a seguinte configura\u00e7\u00e3o:</p> <p><pre><code>#!/bin/bash\n#SBATCH --job-name=convolucao_buffado             # Nome do job\n#SBATCH --output=buffado_%j.txt          # Nome do arquivo de sa\u00edda\n#SBATCH --ntasks=4                              # N\u00famero de tarefas (4 processos)\n#SBATCH --cpus-per-task=4                       # N\u00famero de threads por tarefa (2 threads por processo)\n#SBATCH --mem=2048                               # Mem\u00f3ria total alocada por n\u00f3 (2 GBs)\n#SBATCH --time=00:10:00                         # Tempo m\u00e1ximo de execu\u00e7\u00e3o (10 minutos)\n#SBATCH --partition=espec                      # fila do cluster a ser utilizada\n\n# Exporta a vari\u00e1vel de ambiente para configurar o n\u00famero de threads OpenMP\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n\n# Executa o programa usando MPI e OpenMP\nmpirun ./convolucao\n</code></pre> Este .slurm submete um job que executa 4 tarefas simultaneamente, com 4 CPUs por tarefa, 1 GB de mem\u00f3ria por n\u00f3, e um tempo m\u00e1ximo de execu\u00e7\u00e3o de 10 minutos.</p>"},{"location":"aulas/02-slurm/#exploracao-dos-comandos-slurm","title":"Explora\u00e7\u00e3o dos Comandos SLURM","text":"<p>Submeta os jobs usando o comando <code>sbatch</code>:</p> <pre><code>sbatch convolucao_limitado.slurm\nsbatch convolucao_buffado.slurm\n</code></pre> <p>Utilize o comando <code>sinfo</code> para observar o estado dos n\u00f3s e das filas:</p> <pre><code>sinfo\n</code></pre> <p>Use o comando <code>squeue</code> para observar o estado dos jobs em execu\u00e7\u00e3o no Cluster Franky:</p> <pre><code>squeue\n</code></pre> <p>Use o comando abaixo para ver as especifica\u00e7\u00f5es de recursos dispon\u00edveis nas filas do Cluster Franky:</p> <pre><code>scontrol show partition\n</code></pre> <p>Se quiser ver uma fila especifica, use o comando:</p> <pre><code>scontrol show partition nome_da_fila\n</code></pre>"},{"location":"aulas/02-slurm/#exemplo-interpretacao-da-particao-express","title":"Exemplo -&gt; Interpreta\u00e7\u00e3o da Parti\u00e7\u00e3o <code>express</code>","text":"<p>Esta configura\u00e7\u00e3o define como os jobs s\u00e3o alocados e executados nos n\u00f3s computacionais.</p> <ul> <li><code>PartitionName=express</code> \u2192 Nome da parti\u00e7\u00e3o.  </li> <li><code>AllowGroups=ALL</code> \u2192 Todos os grupos de usu\u00e1rios podem submeter jobs.  </li> <li><code>AllowAccounts=ALL</code> \u2192 Todos os usu\u00e1rios podem submeter jobs, independentemente da conta.  </li> <li> <p><code>AllowQos=ALL</code> \u2192 Todos os n\u00edveis de Qualidade de Servi\u00e7o (QoS) s\u00e3o permitidos.  </p> </li> <li> <p><code>AllocNodes=ALL</code> \u2192 Todos os n\u00f3s podem ser alocados para jobs nesta parti\u00e7\u00e3o.  </p> </li> <li> <p><code>Nodes=compute[00-04]</code> \u2192 Os n\u00f3s compute00, compute01, compute02, compute03 e compute04 est\u00e3o dispon\u00edveis.  </p> </li> <li> <p><code>Default=YES</code> \u2192 Esta \u00e9 a parti\u00e7\u00e3o padr\u00e3o se nenhuma for especificada.  </p> </li> <li><code>MaxNodes=2</code> \u2192 Cada job pode usar no m\u00e1ximo 2 n\u00f3s.  </li> <li><code>MinNodes=0</code> \u2192 Jobs podem rodar mesmo se n\u00e3o houver n\u00f3s alocados inicialmente.  </li> <li><code>MaxTime=00:05:00</code> \u2192 Tempo m\u00e1ximo de execu\u00e7\u00e3o para um job \u00e9 5 minutos.  </li> <li> <p><code>DefaultTime=NONE</code> \u2192 O tempo padr\u00e3o do job n\u00e3o est\u00e1 definido, ent\u00e3o \u00e9 obrigat\u00f3rio especific\u00e1-lo ao submeter.  </p> </li> <li> <p><code>MaxCPUsPerNode=UNLIMITED</code> \u2192 N\u00e3o h\u00e1 limite de CPUs por n\u00f3.  </p> </li> <li><code>MaxCPUsPerSocket=UNLIMITED</code> \u2192 N\u00e3o h\u00e1 limite de CPUs por socket (conjunto de n\u00facleos de um processador f\u00edsico).  </li> <li><code>TotalCPUs=80</code> \u2192 A parti\u00e7\u00e3o possui 80 CPUs dispon\u00edveis no total.  </li> <li><code>TotalNodes=5</code> \u2192 Existem 5 n\u00f3s dispon\u00edveis.  </li> <li><code>DefMemPerNode=UNLIMITED</code> \u2192 A mem\u00f3ria dispon\u00edvel por n\u00f3 n\u00e3o tem um limite padr\u00e3o.  </li> <li><code>MaxMemPerNode=12000</code> \u2192 Cada n\u00f3 pode usar at\u00e9 12GB de RAM por job.  </li> <li> <p><code>TRES=cpu=80,mem=70000M,node=5,billing=80</code> \u2192 O SLURM controla 80 CPUs, 70GB de RAM e 5 n\u00f3s nesta parti\u00e7\u00e3o.  </p> </li> <li> <p><code>PriorityJobFactor=1</code> \u2192 Todos os jobs na parti\u00e7\u00e3o t\u00eam fator de prioridade 1 (sem prefer\u00eancia sobre outras parti\u00e7\u00f5es).  </p> </li> <li> <p><code>PriorityTier=1</code> \u2192 Prioridade desta parti\u00e7\u00e3o \u00e9 1 (normal).  </p> </li> <li> <p><code>ExclusiveUser=NO</code> \u2192 Os n\u00f3s podem ser compartilhados entre m\u00faltiplos jobs de diferentes usu\u00e1rios.  </p> </li> <li><code>OverSubscribe=YES:4</code> \u2192 Permite que at\u00e9 4 jobs compartilhem um mesmo n\u00f3.  </li> <li><code>OverTimeLimit=NONE</code> \u2192 N\u00e3o h\u00e1 limite para jobs que excedam o tempo solicitado.  </li> <li> <p><code>PreemptMode=OFF</code> \u2192 Jobs nesta parti\u00e7\u00e3o n\u00e3o podem ser interrompidos (preempted) por outros jobs de maior prioridade.  </p> </li> <li> <p><code>DisableRootJobs=NO</code> \u2192 Usu\u00e1rios root podem submeter jobs.  </p> </li> <li><code>GraceTime=0</code> \u2192 Sem tempo de espera antes da execu\u00e7\u00e3o do job.  </li> <li><code>Hidden=NO</code> \u2192 A parti\u00e7\u00e3o est\u00e1 vis\u00edvel para todos os usu\u00e1rios.  </li> <li><code>RootOnly=NO</code> \u2192 N\u00e3o \u00e9 necess\u00e1rio ser administrador para rodar jobs.  </li> <li><code>ReqResv=NO</code> \u2192 N\u00e3o requer reserva antecipada de recursos.  </li> </ul> <p>Utilize o comando <code>scancel</code> para cancelar um job:</p> <pre><code>scancel jobid\n</code></pre> <p>Use o comando <code>sprio</code> para visualizar a prioridade dos jobs:</p> <pre><code>sprio\n</code></pre> <p>Tip</p> <p>Se quiser testar outros exemplos verifique o material dispon\u00edvel aqui</p>"},{"location":"aulas/02-slurm/#atividade-02-explorando-comandos-slurm","title":"Atividade 02: Explorando comandos SLURM","text":"<ol> <li> <p>Modifique o N\u00famero de Itera\u00e7\u00f5es da Convolu\u00e7\u00e3o no C\u00f3digo convolucao.cpp; Aumente o n\u00famero de itera\u00e7\u00f5es de   convolu\u00e7\u00e3o no c\u00f3digo para 10, 30, e 60. Isso aumentar\u00e1 a complexidade computacional, observe como o desempenho do c\u00f3digo \u00e9 afetado por essa modifica\u00e7\u00e3o.</p> </li> <li> <p>Ajuste o arquivo .slurm para garantir que os recursos de hardware (n\u00famero de tarefas, CPUs por tarefa, e mem\u00f3ria) e o tempo de execu\u00e7\u00e3o sejam adequados para processar o aumento no n\u00famero de itera\u00e7\u00f5es de convolu\u00e7\u00e3o. Experimente diferentes configura\u00e7\u00f5es de recursos para observar como eles impactam o tempo de execu\u00e7\u00e3o.</p> </li> <li> <p>Gere um gr\u00e1fico comparando o tempo de execu\u00e7\u00e3o do algoritmo para cada n\u00famero de itera\u00e7\u00f5es. Analise o impacto da aloca\u00e7\u00e3o de mais recursos, como o n\u00famero de CPUs a quantidade de mem\u00f3ria e observe tamb\u00e9m, como o volume de uso do cluster por outros usu\u00e1rios afeta o tempo de execu\u00e7\u00e3o. </p> </li> </ol>"},{"location":"aulas/02-slurm/#entrega-do-relatorio-pelo-classroom-as-23h59-de-1402","title":"Entrega do relat\u00f3rio pelo Classroom \u00e1s 23h59 de 14/02","text":""},{"location":"aulas/03-cpp/03-cpp/","title":"Usando o poder do C++","text":"<p>Em programa\u00e7\u00e3o de alto desempenho, pequenas otimiza\u00e7\u00f5es podem resultar em grandes melhorias no tempo de execu\u00e7\u00e3o e no uso de recursos. Nesta aula, vamos explorar t\u00e9cnicas avan\u00e7adas de C++ que s\u00e3o essenciais para programar c\u00f3digos eficientes, seguros e preparados para escalar em aplica\u00e7\u00f5es de alta performance.</p>"},{"location":"aulas/03-cpp/03-cpp/#objetivos-da-aula","title":"Objetivos da Aula","text":"<ol> <li> <p>Passagem de Par\u00e2metros e Manipula\u00e7\u00e3o de Arquivos: Entender como a passagem de par\u00e2metros por valor, refer\u00eancia e ponteiro impacta o desempenho e a seguran\u00e7a do c\u00f3digo. Al\u00e9m disso, vamos manipular arquivos para ler e escrever dados.</p> </li> <li> <p>Const Correctness: Aprender a usar o modificador <code>const</code> para garantir a imutabilidade de dados onde necess\u00e1rio, melhorando a robustez do c\u00f3digo e permitindo otimiza\u00e7\u00f5es autom\u00e1ticas pelo compilador.</p> </li> <li> <p>Aloca\u00e7\u00e3o de Mem\u00f3ria Din\u00e2mica: Compreender a aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria din\u00e2mica em C++, o que \u00e9 fundamental para gerenciar grandes volumes de dados em HPC. Exploraremos as diferen\u00e7as entre aloca\u00e7\u00e3o manual e a utiliza\u00e7\u00e3o de cont\u00eaineres padr\u00e3o do C++ como <code>std::vector</code>.</p> </li> <li> <p>Manipula\u00e7\u00e3o de Vetores: Trabalhar com <code>std::vector</code> e aprender a realizar opera\u00e7\u00f5es comuns em HPC, como inicializa\u00e7\u00e3o, modifica\u00e7\u00e3o e itera\u00e7\u00e3o sobre grandes conjuntos de dados, al\u00e9m de encapsular essa l\u00f3gica em classes eficientes.</p> </li> </ol>"},{"location":"aulas/03-cpp/03-cpp/#por-que-isso-e-importante","title":"Por que isso \u00e9 Importante?","text":"<p>A passagem correta de par\u00e2metros pode evitar c\u00f3pias desnecess\u00e1rias de dados, melhorando a efici\u00eancia. A utiliza\u00e7\u00e3o do <code>const</code> n\u00e3o s\u00f3 previne modifica\u00e7\u00f5es acidentais nos dados, mas tamb\u00e9m permite que o compilador fa\u00e7a otimiza\u00e7\u00f5es mais agressivas. A aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica \u00e9 importante para lidar com os grandes volumes de dados t\u00edpicos de HPC, e a manipula\u00e7\u00e3o eficiente de vetores \u00e9 essencial para o processamento r\u00e1pido de dados.</p>"},{"location":"aulas/03-cpp/03-cpp/#1-passagem-de-parametros-e-manipulacao-de-arquivos","title":"1. Passagem de Par\u00e2metros e Manipula\u00e7\u00e3o de Arquivos","text":"<p>Objetivo: Praticar a passagem de par\u00e2metros por valor, refer\u00eancia e ponteiro em C++, al\u00e9m de trabalhar com leitura e escrita de arquivos.</p> <p>Exerc\u00edcio: Implemente uma fun\u00e7\u00e3o que leia um arquivo de texto contendo n\u00fameros inteiros e armazene-os em um <code>std::vector&lt;int&gt;</code>. Use passagem por refer\u00eancia para garantir que o vetor seja preenchido corretamente. </p> <p>Crie duas fun\u00e7\u00f5es: uma que dobra os valores no vetor usando passagem por refer\u00eancia, e outra que faz o mesmo usando ponteiros.</p> <p>Escreva os valores dobrados em um novo arquivo de texto.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>O arquivo com os valores de entrada est\u00e1 dispon\u00edvel em entrada.txt.</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda, usada para opera\u00e7\u00f5es como std::cout.\n#include &lt;fstream&gt;    // Inclui a biblioteca para manipula\u00e7\u00e3o de arquivos, usada para ler e escrever arquivos.\n#include &lt;vector&gt;     // Inclui a biblioteca de vetores, usada para armazenar e manipular listas de n\u00fameros.\n\n// Declara\u00e7\u00e3o de fun\u00e7\u00f5es:\n\n// Fun\u00e7\u00e3o que l\u00ea n\u00fameros de um arquivo e os armazena em um vetor.\nvoid lerArquivo(const std::string&amp; nomeArquivo, std::vector&lt;int&gt;&amp; numeros);\n\n// Fun\u00e7\u00e3o que dobra os valores de um vetor de n\u00fameros, passando o vetor original por refer\u00eancia.\nvoid dobrarValoresReferencia(const std::vector&lt;int&gt;&amp; numerosOriginais, std::vector&lt;int&gt;&amp; numerosDobrados);\n\n// Fun\u00e7\u00e3o que dobra os valores de um vetor de n\u00fameros, passando o vetor original por ponteiro.\nvoid dobrarValoresPonteiro(const std::vector&lt;int&gt;* numerosOriginais, std::vector&lt;int&gt;* numerosDobrados);\n\n// Fun\u00e7\u00e3o que escreve os n\u00fameros de um vetor em um arquivo.\nvoid escreverArquivo(const std::string&amp; nomeArquivo, const std::vector&lt;int&gt;&amp; numeros);\n\n// Implementa\u00e7\u00e3o das fun\u00e7\u00f5es...\n\nint main() {\n    // Declara\u00e7\u00e3o de dois vetores de inteiros: um para armazenar os n\u00fameros lidos do arquivo e outro para armazenar os n\u00fameros dobrados.\n    std::vector&lt;int&gt; numeros, numerosDobrados;\n\n    // Chama a fun\u00e7\u00e3o para ler os n\u00fameros do arquivo \"entrada.txt\" e armazena-os no vetor 'numeros'.\n    lerArquivo(\"entrada.txt\", numeros);\n\n    // Chama a fun\u00e7\u00e3o que dobra os valores do vetor 'numeros' usando passagem por refer\u00eancia e armazena o resultado no vetor 'numerosDobrados'.\n    dobrarValoresReferencia(numeros, numerosDobrados);\n\n    // Chama a fun\u00e7\u00e3o que escreve os n\u00fameros do vetor 'numerosDobrados' no arquivo \"saida_referencia.txt\".\n    escreverArquivo(\"saida_referencia.txt\", numerosDobrados);\n\n    // Chama a fun\u00e7\u00e3o que dobra os valores do vetor 'numeros' usando passagem por ponteiro e armazena o resultado no vetor 'numerosDobrados'.\n    dobrarValoresPonteiro(&amp;numeros, &amp;numerosDobrados);\n\n    // Chama a fun\u00e7\u00e3o que escreve os n\u00fameros do vetor 'numerosDobrados' no arquivo \"saida_ponteiro.txt\".\n    escreverArquivo(\"saida_ponteiro.txt\", numerosDobrados);\n\n    // Retorna 0, indicando que o programa terminou com sucesso.\n    return 0;\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#2-const-correctness","title":"2. Const Correctness","text":"<p>Objetivo: Praticar o uso de <code>const</code> para garantir a imutabilidade de dados onde necess\u00e1rio, melhorando a seguran\u00e7a e otimiza\u00e7\u00f5es de c\u00f3digo.</p> <p>Exerc\u00edcio:</p> <p>Implemente uma fun\u00e7\u00e3o para multiplica\u00e7\u00e3o de matrizes que utiliza <code>const</code> para garantir que as matrizes de entrada n\u00e3o sejam modificadas.</p> <p>Crie uma classe <code>Matriz</code> que encapsule as opera\u00e7\u00f5es b\u00e1sicas de uma matriz quadrada, utilizando m\u00e9todos <code>const</code> para opera\u00e7\u00f5es de leitura.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Classe Matriz para representar uma matriz quadrada\nclass Matriz {\npublic:\n    // Construtor que inicializa uma matriz quadrada de dimens\u00e3o N x N\n    Matriz(int N) {\n        data.resize(N, std::vector&lt;int&gt;(N, 0));  // Inicializa a matriz com zeros\n    }\n\n    // M\u00e9todo para acessar um elemento espec\u00edfico da matriz (leitura)\n    // Use 'const' para garantir que este m\u00e9todo n\u00e3o modifica a matriz\n    int get(int i, int j) const {\n        // Retorna o elemento na posi\u00e7\u00e3o (i, j)\n        return data[i][j];\n    }\n\n    // M\u00e9todo para modificar um elemento espec\u00edfico da matriz (escrita)\n    void set(int i, int j, int valor) {\n        // Modifica o elemento na posi\u00e7\u00e3o (i, j)\n        data[i][j] = valor;\n    }\n\n    // M\u00e9todo para imprimir a matriz\n    void imprime() const {\n        for (const auto&amp; linha : data) {\n            for (int valor : linha) {\n                std::cout &lt;&lt; valor &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    // M\u00e9todo para acessar o tamanho da matriz (n\u00famero de linhas ou colunas)\n    int tamanho() const {\n        return data.size();\n    }\n\nprivate:\n    std::vector&lt;std::vector&lt;int&gt;&gt; data;  // Armazena os elementos da matriz\n};\n\n// Fun\u00e7\u00e3o que multiplica duas matrizes A e B, armazenando o resultado em C\n// Garanta que A e B s\u00e3o constantes para evitar modifica\u00e7\u00f5es\nvoid multiplicaMatriz(const Matriz&amp; A, const Matriz&amp; B, Matriz&amp; C) {\n    int N = A.tamanho();  // Sup\u00f5e que as matrizes s\u00e3o quadradas e de mesma dimens\u00e3o\n\n    // La\u00e7o para realizar a multiplica\u00e7\u00e3o de matrizes\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = 0; j &lt; N; j++) {\n            int soma = 0;\n            for (int k = 0; k &lt; N; k++) {\n                // Multiplica os elementos correspondentes de A e B\n                soma += A.get(i, k) * B.get(k, j);\n            }\n            // Armazena o resultado em C\n            C.set(i, j, soma);\n        }\n    }\n}\n\nint main() {\n    int N = 3;  // Define o tamanho da matriz (N x N)\n\n    // Cria as matrizes: A, B, e C, todas de dimens\u00e3o N x N\n    Matriz A(N), B(N), C(N);\n\n    // Exemplo de preenchimento das matrizes A e B\n    // Sinta-se a vontade para modificar os valores\n    A.set(91, 16, 18); A.set(79, 1, 33); A.set(1, 2, 3);\n    A.set(31, 42, 43); A.set(61, 12, 53); A.set(4, 5, 6);\n    A.set(2, 52, 79); A.set(25, 18, 85); A.set(7, 8, 9);\n\n    B.set(13, 23, 9); B.set(14, 62, 8); B.set(13, 2, 47);\n    B.set(1, 42, 6); B.set(22, 75, 5); B.set(17, 2, 54);\n    B.set(2, 59, 3); B.set(2, 44, 2); B.set(98, 2, 74);\n\n    // Multiplica as matrizes A e B, armazenando o resultado em C\n    multiplicaMatriz(A, B, C);\n\n    // Imprime a matriz resultante C\n    C.imprime();\n\n    return 0;  // Retorna 0, indicando que o programa terminou com sucesso\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#3-alocacao-de-memoria-dinamica","title":"3. Aloca\u00e7\u00e3o de Mem\u00f3ria Din\u00e2mica","text":"<p>Objetivo: Entender a aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria din\u00e2mica em C++, muito importante para gerenciar grandes volumes de dados em HPC.</p> <p>Exerc\u00edcio: Implemente uma fun\u00e7\u00e3o que aloca dinamicamente uma matriz de inteiros de tamanho N x N e realiza uma soma simples de todos os seus elementos.</p> <p>Em seguida, substitua a aloca\u00e7\u00e3o din\u00e2mica manual pela utiliza\u00e7\u00e3o de <code>std::vector</code> e compare o desempenho das duas abordagens.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda, usada para opera\u00e7\u00f5es como std::cout.\n#include &lt;chrono&gt;     // Inclui a biblioteca para medi\u00e7\u00e3o de tempo, usada para medir a performance do c\u00f3digo.\n\nint main() {\n    int N = 1000;  // Define o tamanho da matriz como N x N, onde N \u00e9 1000.\n\n    // Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria para uma matriz N x N.\n    // Primeiro, aloca um array de ponteiros, onde cada ponteiro ir\u00e1 apontar para uma linha da matriz.\n    int** matriz = new int*[N];\n\n    // Para cada linha da matriz, aloca um array de inteiros de tamanho N.\n    for (int i = 0; i &lt; N; ++i) {\n        matriz[i] = new int[N];\n    }\n\n    // Aqui voc\u00ea pode inicializar e somar os elementos da matriz.\n    // Por exemplo, voc\u00ea pode preencher a matriz com valores e calcular a soma total.\n\n    // Libera\u00e7\u00e3o da mem\u00f3ria alocada dinamicamente.\n    // Primeiro, libera a mem\u00f3ria alocada para cada linha (os arrays de inteiros).\n    for (int i = 0; i &lt; N; ++i) {\n        delete[] matriz[i];\n    }\n\n    // Finalmente, libera a mem\u00f3ria alocada para o array de ponteiros.\n    delete[] matriz;\n\n    return 0;  // Retorna 0, indicando que o programa terminou com sucesso.\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#algumas-dicas","title":"Algumas dicas","text":"<p>1 - Para alocar dinamicamente uma matriz <code>N x N</code>, voc\u00ea precisar\u00e1 criar um ponteiro para um ponteiro (ou seja, um array de ponteiros) e, em seguida, alocar um espa\u00e7o de mem\u00f3ria para cada linha da matriz.</p> <p>2 - Ap\u00f3s alocar a matriz, voc\u00ea pode preench\u00ea-la com valores (por exemplo, aleat\u00f3rios ou sequenciais) e somar todos os elementos.</p> <p>3 - \u00c9 fundamental liberar toda a mem\u00f3ria alocada dinamicamente para evitar vazamentos de mem\u00f3ria. Isso significa liberar cada linha e depois o array de ponteiros.</p> <p>4 - Use a biblioteca chrono para medir o tempo de execu\u00e7\u00e3o das partes chave do seu c\u00f3digo.</p>"},{"location":"aulas/03-cpp/03-cpp/#perguntas-para-reflexao","title":"Perguntas para Reflex\u00e3o:","text":"<p>Qual abordagem foi mais r\u00e1pida? Quais vantagens voc\u00ea percebe ao usar <code>std::vector</code>? Como a aloca\u00e7\u00e3o autom\u00e1tica e a libera\u00e7\u00e3o de mem\u00f3ria pelo <code>std::vector</code> afetam a seguran\u00e7a e robustez do c\u00f3digo?</p>"},{"location":"aulas/03-cpp/03-cpp/#4-manipulacao-de-vetores","title":"4. Manipula\u00e7\u00e3o de Vetores","text":"<p>Objetivo: Trabalhar com <code>std::vector</code> para realizar opera\u00e7\u00f5es comuns em HPC, como a inicializa\u00e7\u00e3o, modifica\u00e7\u00e3o, e itera\u00e7\u00e3o sobre grandes conjuntos de dados.</p> <p>Exerc\u00edcio: - Implemente uma fun\u00e7\u00e3o que inicializa um vetor com valores espec\u00edficos e realiza opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas, como multiplica\u00e7\u00e3o por um escalar. - Crie uma classe <code>Vector</code> que encapsule a l\u00f3gica de manipula\u00e7\u00e3o de vetores, incluindo m\u00e9todos para adicionar, remover e acessar elementos. Garanta que a classe seja eficiente usando aloca\u00e7\u00e3o din\u00e2mica e fun\u00e7\u00f5es <code>inline</code>.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Vector {\npublic:\n    Vector(int tamanho);\n    ~Vector();\n    void inicializa(int valor);\n    int get(int index) const;\n    void set(int index, int valor);\n    void inserir(int index, int valor);\n    void remover(int index);\n    void imprime() const;\n\nprivate:\n    int* dados;\n    int tam;\n    int capacidade;\n    void redimensiona(int novaCapacidade);\n};\n\n// Implementa\u00e7\u00e3o das fun\u00e7\u00f5es...\n\nint main() {\n    Vector vec(5);\n    vec.inicializa(0);\n    vec.imprime();\n\n    return 0;\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#entrega-da-atividade-42","title":"Entrega da Atividade 4.2","text":"<p>A entrega sera pelo Classroom at\u00e9 segunda (24/02), as 23h59.</p>"},{"location":"aulas/04-Profiling/04-Profiling/","title":"Otimiza\u00e7\u00e3o e Profiling","text":"<p>Em ambientes de HPC, dominar t\u00e9cnicas de otimiza\u00e7\u00e3o e profiling pode fazer toda a diferen\u00e7a na execu\u00e7\u00e3o de programas complexos. Nosso objetivo \u00e9 capacitar voc\u00ea a identificar gargalos de desempenho em seu c\u00f3digo. </p> <p>Objetivo: Entender como utilizar as flags de compila\u00e7\u00e3o e ferramentas de profiling para encontrar gargalos e melhorar o desempenho do c\u00f3digo.</p> <p>Recursos Necess\u00e1rios:</p> <ul> <li> <p>C\u00f3digo base do programa de convolu\u00e7\u00e3o (<code>convolucao.cpp</code>) usado na aula 02.</p> </li> <li> <p>Ferramentas de profiling: <code>gprof</code>, <code>Valgrind</code>.</p> </li> <li> <p>Se voc\u00ea estiver usando Windows, ser\u00e1 necess\u00e1rio usar o WSL, se voc\u00ea n\u00e3o tem o WSL configurado, siga esse tutorial antes de come\u00e7ar </p> </li> </ul>"},{"location":"aulas/04-Profiling/04-Profiling/#configuracao-e-teste-do-x11-nos-principais-sistemas-operacionais","title":"Configura\u00e7\u00e3o e Teste do X11 nos Principais Sistemas Operacionais","text":""},{"location":"aulas/04-Profiling/04-Profiling/#linux","title":"Linux","text":"<p>Instale o X11 (se necess\u00e1rio):   <pre><code>sudo apt install x11-apps xauth  # Debian/Ubuntu\nsudo dnf install xorg-x11-xauth  # Fedora/RHEL\n</code></pre></p> <p>Conecte-se ao cluster com X11 Forwarding:   <pre><code> ssh -X -i ~/.ssh/id_rsa seu_usuario@ip_do_cluster\n</code></pre> Teste a exibi\u00e7\u00e3o gr\u00e1fica:   <pre><code>xclock\nxeyes\n</code></pre></p>"},{"location":"aulas/04-Profiling/04-Profiling/#macos","title":"macOS","text":"<p>Instale o XQuartz (servidor X para macOS):   <pre><code>brew install --cask xquartz\n</code></pre>   Depois de instalar, abra o XQuartz e rode:   <pre><code>xhost +\n</code></pre></p> <p>Conecte-se ao cluster com SSH e X11 Forwarding:   <code>bash     ssh -X -i ~/.ssh/id_rsa seu_usuario@ip_do_cluster</code></p> <p>Teste a exibi\u00e7\u00e3o gr\u00e1fica:   <pre><code>xclock\nxeyes\n</code></pre></p>"},{"location":"aulas/04-Profiling/04-Profiling/#windows","title":"Windows","text":"<p>Abra o WSL, instale o X11</p> <pre><code>sudo apt install x11-apps xauth  # Debian/Ubuntu\n</code></pre> <p>Teste a exibi\u00e7\u00e3o gr\u00e1fica:   <pre><code>xclock\nxeyes\n</code></pre></p> <p>Se voc\u00ea nunca acessou o Franky usando o WSL, ser\u00e1 necess\u00e1rio configurar as chaves de acesso...</p> <p>Instale os pacotes do ssh   <pre><code>sudo apt install openssh-server\n\nssh localhost\n</code></pre> Copie as suas chaves para a pasta .ssh em <code>~/.ssh</code></p> <p>Certifique-se de que as permiss\u00f5es est\u00e3o corretas:</p> <pre><code>sudo chwon seu_usuario:seu_usuario id_rsa*\nsudo chmod 400 id_rsa\n</code></pre> <p>Agora conecte-se ao Franky com o X11 Forwarding ativo usando a flag <code>-X</code> ou <code>-Y</code> no comando SSH:</p> <pre><code>ssh -X -i ~/.ssh/id_rsa seu_usuario@ip_do_cluster\n</code></pre>"},{"location":"aulas/04-Profiling/04-Profiling/#para-conectar-ao-cluster-com-x11-forwarding-e-testar-a-configuracao","title":"Para conectar ao Cluster com X11 Forwarding e Testar a Configura\u00e7\u00e3o","text":"<p>Ap\u00f3s configurar o X11 Forwarding, conecte-se ao cluster utilizando a flag <code>-X</code> ou <code>-Y</code> no comando SSH:</p> <p><pre><code>ssh -X -i ~/.ssh/id_rsa seu_usuario@ip_do_cluster\n</code></pre> Se houver problemas com <code>-X</code>, tente com <code>-Y</code>, que permite conex\u00f5es X11 menos restritivas: <pre><code>ssh -Y -i ~/.ssh/id_rsa seu_usuario@ip_do_cluster\n</code></pre></p>"},{"location":"aulas/04-Profiling/04-Profiling/#verificando-se-o-x11-esta-funcionando","title":"Verificando se o X11 est\u00e1 Funcionando","text":"<p>Ap\u00f3s conectar ao cluster via SSH, execute o seguinte comando para verificar se o display foi corretamente encaminhado:</p> <p><pre><code>echo $DISPLAY\n</code></pre> - Se o retorno for algo como <code>localhost:10.0</code>, significa que o X11 Forwarding est\u00e1 ativo. - Se o retorno for vazio, pode ser necess\u00e1rio revisar a configura\u00e7\u00e3o.</p> <p>Agora, teste a exibi\u00e7\u00e3o de uma aplica\u00e7\u00e3o gr\u00e1fica simples no cluster:</p> <p><pre><code>xclock\n</code></pre> Se a configura\u00e7\u00e3o estiver correta, um rel\u00f3gio gr\u00e1fico ser\u00e1 exibido na tela do seu computador.</p> <p>Se o X11 Forwarding estiver corretamente configurado, o teste com <code>xclock</code> abrir\u00e1 uma janela gr\u00e1fica no seu computador. Se houver falhas, verifique se o servidor X est\u00e1 rodando na sua m\u00e1quina local.</p> <p></p> <p>Ap\u00f3s concluir as configura\u00e7\u00f5es, vamos retornar ao guia. Come\u00e7aremos explorando as flags de compila\u00e7\u00e3o que o GCC oferece para otimizar seu c\u00f3digo. Desde ajustes b\u00e1sicos at\u00e9 transforma\u00e7\u00f5es avan\u00e7adas, voc\u00ea ver\u00e1 como as diferentes flags podem impactar o desempenho de seu programa.</p> <p>Ap\u00f3s otimizar o c\u00f3digo na compila\u00e7\u00e3o, vamos entender como as ferramentas de profiling Gprof e Valgrind funcionam. Essas ferramentas s\u00e3o \u00fateis para identificar quais partes do c\u00f3digo s\u00e3o as mais exigentes em termos de recursos e onde os maiores ganhos de desempenho podem ser alcan\u00e7ados.</p>"},{"location":"aulas/04-Profiling/04-Profiling/#flags-de-compilacao","title":"Flags de Compila\u00e7\u00e3o","text":"<ul> <li><code>-O1</code>: N\u00edvel b\u00e1sico de otimiza\u00e7\u00e3o que aplica melhorias simples, mantendo o tempo de compila\u00e7\u00e3o r\u00e1pido.</li> <li><code>-O2</code>: Aplica\u00e7\u00e3o de otimiza\u00e7\u00f5es mais agressivas, incluindo inlining de fun\u00e7\u00f5es simples, unrolling de loops, e remo\u00e7\u00e3o de c\u00f3digo morto.</li> <li><code>-O3</code>: N\u00edvel mais alto de otimiza\u00e7\u00e3o, inclui todas as otimiza\u00e7\u00f5es do <code>-O2</code> al\u00e9m de transforma\u00e7\u00f5es adicionais que podem aumentar ainda mais o desempenho, como a vectoriza\u00e7\u00e3o de loops.</li> <li><code>-march=native</code>: Gera c\u00f3digo otimizado para a arquitetura espec\u00edfica da m\u00e1quina onde o programa est\u00e1 sendo compilado, aproveitando ao m\u00e1ximo as instru\u00e7\u00f5es da CPU dispon\u00edvel.</li> </ul>"},{"location":"aulas/04-Profiling/04-Profiling/#compilacao-com-diferentes-flags","title":"Compila\u00e7\u00e3o com Diferentes Flags","text":"<ol> <li>Compile o programa <code>convolucao.cpp</code> com diferentes n\u00edveis de otimiza\u00e7\u00e3o:</li> </ol> <p>Sem otimiza\u00e7\u00e3o: <pre><code>mpic++ convolucao.cpp -o convolucao_basicao\n</code></pre></p> <p>Otimiza\u00e7\u00e3o b\u00e1sica (<code>-O1</code>): <pre><code>mpic++ -O1 convolucao.cpp -o convolucao_O1\n</code></pre> Otimiza\u00e7\u00e3o padr\u00e3o (<code>-O2</code>): <pre><code>mpic++ -O2 convolucao.cpp -o convolucao_O2\n</code></pre> Otimiza\u00e7\u00e3o avan\u00e7ada (<code>-O3</code>): <pre><code>mpic++ -O3 -march=native convolucao.cpp -o convolucao_O3\n</code></pre></p>"},{"location":"aulas/04-Profiling/04-Profiling/#medicao-de-desempenho","title":"Medi\u00e7\u00e3o de Desempenho","text":"<ol> <li>Execute cada vers\u00e3o do programa no cluster usando um script SLURM similar ao usado na aula 02.</li> </ol> <p>Modifique o n\u00famero de itera\u00e7\u00f5es para 10, 30, e 60 para avaliar o impacto da complexidade no tempo de execu\u00e7\u00e3o, submeta os jobs via SLURM, verifique os tempos de execu\u00e7\u00e3o e compare o impacto de cada n\u00edvel de otimiza\u00e7\u00e3o.</p>"},{"location":"aulas/04-Profiling/04-Profiling/#analise-dos-resultados","title":"An\u00e1lise dos Resultados","text":"<p>Gr\u00e1ficos: Elabore gr\u00e1ficos que relacionam o tempo de execu\u00e7\u00e3o com o n\u00famero de itera\u00e7\u00f5es para cada n\u00edvel de otimiza\u00e7\u00e3o. Discuss\u00e3o: Analise como as diferentes flags de otimiza\u00e7\u00e3o impactaram o desempenho. Identifique quais otimiza\u00e7\u00f5es trouxeram maiores ganhos e em quais situa\u00e7\u00f5es.</p>"},{"location":"aulas/04-Profiling/04-Profiling/#profiling-com-gprof-e-valgrind","title":"Profiling com Gprof e Valgrind","text":""},{"location":"aulas/04-Profiling/04-Profiling/#usando-o-gprof","title":"Usando o Gprof","text":"<p>Compile o c\u00f3digo com suporte ao Gprof:</p> <p><pre><code>mpic++ -pg -O2 convolucao.cpp -o convolucao_gprof\n</code></pre> Execute o programa e gere o perfil:</p> <p><pre><code>sbatch convolucao_gprof.slurm\n</code></pre> Analise o <code>gmon.out</code> gerado:</p> <pre><code>gprof convolucao_gprof gmon.out &gt; analysis_gprof.txt\n</code></pre> <p>Interprete o Flat Profile e o Call Graph gerados. Identifique as fun\u00e7\u00f5es cr\u00edticas e discuta poss\u00edveis otimiza\u00e7\u00f5es com base nos resultados.</p>"},{"location":"aulas/04-Profiling/04-Profiling/#usando-o-callgrind-valgrind","title":"Usando o Callgrind (Valgrind)","text":"<p>Execute o programa com o Callgrind:</p> <pre><code>valgrind --tool=callgrind ./convolucao_O2\n</code></pre> <p>Para visualizar o relat\u00f3rio via terminal use o comando:</p> <pre><code>callgrind_annotate callgrind.out.&lt;pid&gt;\n</code></pre> <p><pre><code>kcachegrind callgrind.out.*\n</code></pre> Analise o uso de CPU e cache. Identifique fun\u00e7\u00f5es e loops que s\u00e3o candidatos para otimiza\u00e7\u00e3o. Compare as sa\u00eddas do gprof e Callgrind. </p> <p></p>"},{"location":"aulas/04-Profiling/04-Profiling/#profiling","title":"Profiling","text":"<p>Elabore um Relat\u00f3rio que inclua: </p> <ul> <li> <p>Gr\u00e1ficos e an\u00e1lise dos tempos de execu\u00e7\u00e3o para diferentes otimiza\u00e7\u00f5es.</p> </li> <li> <p>Discuss\u00e3o sobre os resultados obtidos.</p> </li> <li> <p>Sugest\u00f5es de otimiza\u00e7\u00f5es adicionais baseadas nos resultados de profiling.</p> </li> </ul> <p>Submiss\u00e3o: Envie o relat\u00f3rio pelo Classroom at\u00e9 28/02, 23h59.</p>"},{"location":"aulas/05-heuristicas/","title":"Problema da Mochila com Busca Exaustiva","text":"<p>O problema da mochila \u00e9 um dos problemas cl\u00e1ssicos da computa\u00e7\u00e3o e \u00e9 amplamente estudado em otimiza\u00e7\u00e3o de algoritmos e computa\u00e7\u00e3o. </p> <p>Imagine que voc\u00ea est\u00e1 se preparando para uma viagem e tem uma mochila com capacidade limitada de peso. Voc\u00ea tem v\u00e1rios itens \u00e0 sua disposi\u00e7\u00e3o, cada um com um peso espec\u00edfico e um valor associado. Seu objetivo \u00e9 escolher quais itens colocar na mochila para maximizar o valor total, sem ultrapassar a capacidade m\u00e1xima de peso que a mochila pode carregar.</p> <p>Suponha que voc\u00ea tenha os seguintes itens:</p> <p>Item 1: Peso = 2 kg, Valor = 3</p> <p>Item 2: Peso = 3 kg, Valor = 4</p> <p>Item 3: Peso = 4 kg, Valor = 5</p> <p>Item 4: Peso = 5 kg, Valor = 8</p> <p>E sua mochila pode carregar at\u00e9 8 kg. A quest\u00e3o \u00e9: quais itens voc\u00ea deve escolher para maximizar o valor total na mochila, sem ultrapassar a capacidade de 8 kg?</p> <p>Se voc\u00ea tentar todas as combina\u00e7\u00f5es poss\u00edveis de itens, ver\u00e1 que algumas op\u00e7\u00f5es permitem carregar mais valor do que outras. Por exemplo:</p> <p>Se voc\u00ea escolher os itens 1 e 4, o peso total ser\u00e1 7 kg e o valor total ser\u00e1 11.</p> <p>Se escolher os itens 2 e 3, o peso total ser\u00e1 7 kg e o valor total ser\u00e1 9.</p> <p>Neste caso, a melhor combina\u00e7\u00e3o seria escolher os itens 1 e 4, que oferecem o maior valor total de 11 sem exceder o peso m\u00e1ximo de 8 kg.</p>"},{"location":"aulas/05-heuristicas/#desafios-do-problema","title":"Desafios do Problema:","text":"<p>O problema da mochila torna-se cada vez mais complexo \u00e0 medida que o n\u00famero de itens aumenta. Com mais itens, o n\u00famero de combina\u00e7\u00f5es poss\u00edveis cresce exponencialmente, tornando a busca pela solu\u00e7\u00e3o \u00f3tima um desafio computacional significativo. Por isso, algoritmos eficientes s\u00e3o necess\u00e1rios para resolver o problema em casos de grande escala.</p> <p>A atividade desta aula consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria. </p> <p>Abaixo voc\u00ea encontrar\u00e1 as listas contendo peso e valor dos itens para organizar na mochila.</p> <p>Entrada 1, Entrada 2, Entrada 3, Entrada 4 </p> <p>Neste exerc\u00edcio, voc\u00ea implementar\u00e1 uma solu\u00e7\u00e3o para o problema da mochila usando a t\u00e9cnica de busca exaustiva em C++. O objetivo \u00e9 maximizar o valor dos objetos dentro da mochila sem exceder sua capacidade. </p> <p>Descri\u00e7\u00e3o do Problema: Dado um conjunto de N objetos, cada um com um peso  w_i  e um valor  v_i , selecione uma combina\u00e7\u00e3o de objetos que maximize o valor total sem ultrapassar a capacidade W da mochila.</p> <ul> <li>Entrada: <pre><code>N W\nw1 v1\nw2 v2\n...\nwN vN\n</code></pre></li> </ul> <p>Onde: N: N\u00famero de objetos</p> <p>W: Capacidade da mochila </p> <p>Wi: Peso do objeto</p> <p>Vi: Valor do objeto.</p> <p>Para resolver o problema da mochila usando busca exaustiva, precisamos avaliar todas as combina\u00e7\u00f5es poss\u00edveis de itens. Uma abordagem comum \u00e9 usar recurs\u00e3o para explorar todas as possibilidades.</p>"},{"location":"aulas/05-heuristicas/#o-que-e-recursao","title":"O que \u00e9 Recurs\u00e3o?","text":"<p>Recurs\u00e3o \u00e9 uma t\u00e9cnica fundamental na programa\u00e7\u00e3o, onde uma fun\u00e7\u00e3o chama a si mesma para resolver subproblemas menores de uma tarefa maior. A ideia central \u00e9 dividir um problema complexo em partes menores, que podem ser resolvidas de forma mais simples. Em um algoritmo recursivo, o problema \u00e9 resolvido ao fazer chamadas sucessivas para a mesma fun\u00e7\u00e3o, mas com par\u00e2metros ajustados que aproximam a solu\u00e7\u00e3o a cada passo.</p> <p>Exemplificando...</p> <p>Considere a tarefa de calcular o fatorial de um n\u00famero  n . O fatorial de  n , representado como  n! , \u00e9 o produto de todos os n\u00fameros inteiros de 1 at\u00e9  n . Podemos definir isso de forma recursiva: -  0! = 1  (caso base) -  n! = n \\times (n-1)!  (caso recursivo)</p> <p>Usando recurs\u00e3o, a fun\u00e7\u00e3o que calcula o fatorial chama a si mesma com o valor  n-1 , at\u00e9 que atinge o caso base.</p>"},{"location":"aulas/05-heuristicas/#recursao-no-problema-da-mochila","title":"Recurs\u00e3o no Problema da Mochila","text":"<p>No contexto do problema da mochila, a recurs\u00e3o \u00e9 utilizada para explorar todas as combina\u00e7\u00f5es poss\u00edveis de itens que podem ser colocados na mochila. A ideia \u00e9 considerar, para cada item, duas possibilidades: inclu\u00ed-lo na mochila ou n\u00e3o inclu\u00ed-lo. Para cada uma dessas escolhas, o problema \u00e9 reduzido ao mesmo problema, mas com um item a menos e, no caso de inclus\u00e3o, com uma capacidade reduzida na mochila.</p> <p>A estrutura recursiva para resolver o problema da mochila pode ser descrita da seguinte forma:</p> <ol> <li> <p>Caso Base: Se n\u00e3o h\u00e1 mais itens a serem considerados ou se a capacidade  restante da mochila \u00e9 zero, o valor total \u00e9 zero.</p> </li> <li> <p>Caso Recursivo: Para cada item  i :</p> </li> </ol> <p>Se incluir o item  i : resolva o problema para os itens restantes com a capacidade reduzida.</p> <p>Se n\u00e3o incluir o item  i : resolva o problema para os itens restantes sem alterar a capacidade.</p> <p>Retorne a melhor das duas solu\u00e7\u00f5es.</p>"},{"location":"aulas/05-heuristicas/#atividade-05-problema-da-mochila-com-busca-exaustiva","title":"Atividade 05: Problema da Mochila com Busca Exaustiva","text":"<p>Objetivo: Implemente uma solu\u00e7\u00e3o para o problema da mochila usando a t\u00e9cnica de busca exaustiva atrav\u00e9s de recurs\u00e3o em C++. O objetivo \u00e9 maximizar o valor dos objetos dentro da mochila sem exceder sua capacidade.</p> <p>Utilize os arquivos de entrada Entrada 1, Entrada 2, Entrada 3 e Entrada 4 para validar sua implementa\u00e7\u00e3o. Verifique se o programa consegue determinar a combina\u00e7\u00e3o correta para maximizar o valor na mochila para cada arquivo de entrada.</p> <p>Compare o tempo de execu\u00e7\u00e3o para os diferentes arquivos de entrada. Considerando que o algoritmo explora todas as combina\u00e7\u00f5es poss\u00edveis, discuta suas limita\u00e7\u00f5es em termos de tempo de execu\u00e7\u00e3o e uso de mem\u00f3ria.</p> <p>Ser\u00e1 que voc\u00ea consegue um resultado melhor?</p> <p>Entrada 1 -&gt; Peso ocupado: 10 Kg, Valor alcan\u00e7ado: 266 dinheiros</p> <p>Entrada 2 -&gt; Peso ocupado: 2 Kg, Valor alcan\u00e7ado: 156 dinheiros</p> <p>Entrada 3 -&gt; Peso ocupado: 95 Kg, Valor alcan\u00e7ado: 236 dinheiros</p> <p>Entrada 4 -&gt; Peso ocupado: 10 Kg, Valor alcan\u00e7ado: 55 dinheiros</p> <p>Disponibilize no seu reposit\u00f3rio o c\u00f3digo e as an\u00e1lises at\u00e9 as 23h59 de 07/03. </p>"},{"location":"aulas/06-aleatorizacao/","title":"Heur\u00edsticas Aleat\u00f3rias para o Problema da Mochila","text":"<p>Nesta aula, vamos experimentar um conjuntos de dados maiores e testar novas heur\u00edsticas baseadas em sele\u00e7\u00e3o aleat\u00f3ria. O objetivo \u00e9 comparar a efici\u00eancia e a qualidade das solu\u00e7\u00f5es geradas pelos diferentes m\u00e9todos.</p>"},{"location":"aulas/06-aleatorizacao/#implementacao-de-heuristicas-aleatorias","title":"Implementa\u00e7\u00e3o de Heur\u00edsticas Aleat\u00f3rias","text":"<p>Tip</p> <p>documenta\u00e7\u00e3o da biblioteca random neste link</p> <p>Implemente duas novas heur\u00edsticas aleat\u00f3rias para selecionar os itens da mochila:</p>"},{"location":"aulas/06-aleatorizacao/#tarefa-1-embaralhar-e-preencher-a-mochila","title":"Tarefa 1: Embaralhar e Preencher a Mochila:","text":"<p>1. Embaralhe o vetor de itens (peso e valor).</p> <p>2. Percorra o vetor do primeiro ao \u00faltimo item e, se o item couber na mochila, coloca ele l\u00e1 sem pensar.</p> <p>3. Continue at\u00e9 que a mochila esteja cheia ou at\u00e9 que os itens acabem.</p> <p>Execute a heur\u00edstica e compare o resultado obtido e o tempo de execu\u00e7\u00e3o com o m\u00e9todo de busca exaustiva.</p>"},{"location":"aulas/06-aleatorizacao/#tarefa-2-selecao-aleatoria-baseada-em-probabilidade","title":"Tarefa 2: Sele\u00e7\u00e3o Aleat\u00f3ria Baseada em Probabilidade:","text":"<p>1. Percorra os itens sem alterar a ordem.</p> <p>2. Para cada item, gere um n\u00famero aleat\u00f3rio de probabilidade (entre 0 e 1).</p> <p>3. Se a probabilidade for maior que um valor limiar definido (por exemplo, 0.5), adicione o item \u00e0 mochila se ele couber; caso contr\u00e1rio, ignore-o, mesmo que caiba.</p>"},{"location":"aulas/06-aleatorizacao/#heuristicas-aleatorias-par-ao-problema-da-mochila","title":"Heur\u00edsticas Aleat\u00f3rias par ao Problema da Mochila","text":"<p>Teste com Novas Entradas: As mochilas da atividade passada eram bem basiconas, vamos testar o c\u00f3digo com mochilas computacionalmente mais desafiadoras:</p> <p></p> <p>Entrada_1.txt, Entrada_2.txt, Entrada_3.txt, Entrada_4.txt</p> <p>1. Registre o tempo necess\u00e1rio para o algoritmo de busca exaustiva resolver cada Entrada.</p> <p>Tip</p> <p>A busca exaustiva vai demorar horrores, voc\u00ea pode submeter o c\u00f3digo no cluster e pegar o resultado um dia, quando a busca terminar &lt;3</p> <p>2. Execute o algor\u00edtimo embaralhado da Tarefa 1 pelo menos 5 vezes para cada entrada.</p> <p>3. Execute o algor\u00edtimo probabil\u00edstico da Tarefa 2 pelo menos 5 vezes para cada entrada.</p> <p>4. Analise as diferen\u00e7as nos tempos de execu\u00e7\u00e3o e na qualidade das solu\u00e7\u00f5es encontradas (valores obtidos e pesos das mochilas) das heur\u00edsticas aleat\u00f3rias e da busca exaustiva.</p> <p>Ser\u00e1 que voc\u00ea consegue um resultado melhor?</p> <p>Entrada 1 -&gt; Peso ocupado: 373 Kg, Valor alcan\u00e7ado: 601 dinheiros em 27 segundos</p> <p>Entrada 2 -&gt; Peso ocupado: 239 Kg, Valor alcan\u00e7ado: 870 dinheiros em 30 minutos e 48 segundos</p> <p>Entrada 3 -&gt; Peso ocupado: ? Kg, Valor alcan\u00e7ado: ? dinheiros</p> <p>Entrada 4 -&gt; Peso ocupado: 600 Kg, Valor alcan\u00e7ado: 648 dinheiros  em 9 minutos e 54 segundos</p> <p>Suba no GitHub os c\u00f3digos e um relat\u00f3rio com suas an\u00e1lises at\u00e9 as 23h59 de 10/03</p>"},{"location":"aulas/07-busca-global/","title":"Busca exaustiva","text":""},{"location":"aulas/07-busca-global/#pseudo-codigo","title":"Pseudo-c\u00f3digo","text":"<p>Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia:</p> <ul> <li>Iniciando com o objeto 0:<ul> <li>N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado</li> <li>Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade <code>C - p[0]</code>. Retorne o resultado <code>+ v[0]</code>.</li> <li>Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne.</li> </ul> </li> </ul> <p>Tip</p> <p>Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo!</p> <p>Question</p> <p>Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor.</p> <p>Question</p> <p>Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor.</p> <p>Dica: pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada.</p>"},{"location":"aulas/07-busca-global/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Vamos agora tentar implementar o algoritmo de busca global que fizemos.</p> <p>Example</p> <p>Implemente em C++ seu algoritmo acima.</p> <p>Question</p> <p>Teste o seu programa com a entrada <code>in-aula.txt</code> (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13?</p>"},{"location":"aulas/07-busca-global/#fechamento","title":"Fechamento","text":"<p>Question</p> <p>Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?</p>"},{"location":"aulas/07-busca-local/","title":"Busca local e Hill Climb","text":"<p>Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o.</p>"},{"location":"aulas/07-busca-local/#busca-local","title":"Busca local","text":"<p>Vamos implementar uma busca local para a Mochila seguindo os tr\u00eas algoritmos vistos na aula.</p>"},{"location":"aulas/07-busca-local/#mochila-cheia","title":"Mochila cheia","text":"<p>Tip</p> <p>voc\u00ea pode utilizar o c\u00f3digo embaralhado da da aula 07</p> <p>Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia:</p> <ol> <li>Gere uma solu\u00e7\u00e3o aleat\u00f3ria.</li> <li>Percorra novamente todos os objetos (na ordem da entrada).</li> <li>Se um objeto couber na mochila, inclua-o.</li> </ol>"},{"location":"aulas/07-busca-local/#substituicao-de-objeto","title":"Substitui\u00e7\u00e3o de objeto","text":"<p>Para implementar a Substitui\u00e7\u00e3o de objeto iremos adotar a seguinte estrat\u00e9gia:</p> <ol> <li>Gere uma solu\u00e7\u00e3o aleat\u00f3ria.</li> <li>Execute Mochila Cheia.</li> <li>Para cada objeto (em ordem da entrada):</li> <li>Verifique, para cada objeto n\u00e3o usado, se uma troca aumentaria o valor da mochila.</li> <li>Em caso positivo, fa\u00e7a a troca e volte para o in\u00edcio do passo 2.</li> <li>Repita enquanto for poss\u00edvel.</li> </ol>"},{"location":"aulas/07-busca-local/#hill-climbing-para-a-mochila","title":"Hill Climbing para a Mochila","text":"<p>Para implementar o Hill Climbing na Mochila, seguimos o m\u00e9todo abaixo:</p> <ol> <li> <p>Para uma mochila com capacidade  C  e diversos itens, com seus respectivos pesos (W) e valores (V). Nosso objetivo \u00e9 maximizar  \\sum V , respeitando a restri\u00e7\u00e3o  W \\leq C .</p> </li> <li> <p>Podemos codificar nosso problema como uma string bin\u00e1ria. 0 significa que o item  i  n\u00e3o foi inclu\u00eddo, enquanto que 1 significa que  i  foi inclu\u00eddo.</p> </li> <li>Supondo 10 objetos, nossa string poderia ser: <code>0010010000</code>.</li> <li>Para este exemplo, vamos gerar 10 poss\u00edveis vizinhos a partir da modifica\u00e7\u00e3o de um bit: <code>1010010000</code>, <code>0110010000</code>, etc.</li> <li>Vamos computar a qualidade desses 10 vizinhos. Se houver um melhor, ele \u00e9 a nova solu\u00e7\u00e3o e repetimos o processo, at\u00e9 que nenhum vizinho melhor seja encontrado.</li> </ol> <p>Rode os algoritmos implementados, incluindo a Substitui\u00e7\u00e3o de objeto e o Hill Climbing, 10 vezes e retorne a melhor solu\u00e7\u00e3o.</p> <p>Houve melhoria em rela\u00e7\u00e3o ao algoritmo embaralhado e ao probabil\u00edstico da aula 07? Como voc\u00ea avalia os ganhos obtidos pelas diferentes estrat\u00e9gias vistas para resolver o problema da mochila?</p> <p>Analise as diferen\u00e7as nos tempos de execu\u00e7\u00e3o e na qualidade das solu\u00e7\u00f5es nas diferentes estrat\u00e9gias vistas para resolver o problema da mochila.</p> <p>Utilize as entradas Entrada_1.txt, Entrada_2.txt e Entrada_3.txt</p> <p>**Disponibilize no seu reposit\u00f3rio o c\u00f3digo e as an\u00e1lises at\u00e9 as 23h59 de 14/03. *</p>"},{"location":"aulas/08-heuristica/","title":"Heur\u00edsticas","text":""},{"location":"aulas/08-heuristica/#mais-caro-primeiro","title":"Mais caro primeiro","text":"<p>A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos.</p> <p>Question</p> <p>Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel?</p> Resposta <p>Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2).</p> <p>Example</p> <p>Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima.</p> <p>Dicas:</p> <ul> <li>C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <code>&lt;algorithm&gt;</code>. Use-o.</li> <li>Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo.</li> <li>Pode ser conveniente organizar os dados usando <code>struct</code>.</li> </ul>"},{"location":"aulas/08-heuristica/#mais-leve-primeiro","title":"Mais leve primeiro","text":"<p>Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco. Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor.</p> <p>Question</p> <p>Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta a complexidade computacional.</p> <p>Question</p> <p>Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima?</p> <p>Example</p> <p>Implemente agora a heur\u00edstica do mais leve. Chame seu programa de <code>mais_leve</code>, mantendo tamb\u00e9m o c\u00f3digo do anterior.</p>"},{"location":"aulas/08-heuristica/#analisando-nossas-heuristicas","title":"Analisando nossas heur\u00edsticas","text":"<p>Question</p> <p>Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Coloque no relat\u00f3rio as sa\u00eddas de cada programa.</p> <p>Question</p> <p>Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Coloque no relat\u00f3rio as sa\u00eddas de cada programa.</p> <p>Question</p> <p>Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor?</p> <p>Question</p> <p>Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?</p> <p>Question</p> <p>Qual a complexidade computacional das abordagens?</p> <p>Question</p> <p>Quando uma \u00e9 melhor que a outra?</p> <p>Question</p> <p>Alguma consegue obter o melhor valor poss\u00edvel?</p> <p>Entrega do relat\u00f3rio para 21/03 as 23h59</p>"},{"location":"aulas/09-thrust/","title":"Thrust para programa\u00e7\u00e3o paralela em GPU","text":""},{"location":"aulas/09-thrust/#o-que-e-thrust","title":"O que \u00e9 Thrust?","text":"<p>Thrust \u00e9 uma biblioteca desenvolvida pela Nvidia para facilitar a programa\u00e7\u00e3o em GPUs. Ela \u00e9 inspirada na biblioteca da STL (Standard Template Library) do C++, mas com um foco em opera\u00e7\u00f5es paralelas, tanto na GPU quanto na CPU. Thrust permite que o codigo seja executado de forma eficiente em paralelo, sem a complexidade de escrever kernels CUDA.</p>"},{"location":"aulas/09-thrust/#como-thrust-funciona","title":"Como Thrust Funciona?","text":"<p>Thrust fornece uma s\u00e9rie de algoritmos e estruturas de dados otimizadas para execu\u00e7\u00e3o em paralelo. Isso inclui:</p> <ul> <li>Vetores: <code>thrust::host_vector</code> e <code>thrust::device_vector</code> s\u00e3o vetores que gerenciam mem\u00f3ria na CPU e GPU, respectivamente.</li> <li>Algoritmos: Thrust oferece uma variedade de algoritmos paralelos prontos para uso, como <code>thrust::sort</code>, <code>thrust::reduce</code>, <code>thrust::transform</code>, entre outros.</li> <li>Iteradores: Assim como a STL, Thrust usa iteradores para percorrer elementos de vetores, permitindo aplicar algoritmos de maneira eficiente.</li> </ul> <p>Por exemplo, em vez de escrever um kernel CUDA manualmente para somar os elementos de um vetor, voc\u00ea pode usar a fun\u00e7\u00e3o <code>thrust::reduce</code>, que faz isso de forma otimizada e em paralelo na GPU.</p>"},{"location":"aulas/09-thrust/#vantagens-de-usar-thrust","title":"Vantagens de Usar Thrust","text":"<p>1. Simplicidade: Thrust abstrai a complexidade da programa\u00e7\u00e3o paralela em CUDA. </p> <p>2. Portabilidade: Um dos grandes benef\u00edcios da Thrust \u00e9 que o mesmo c\u00f3digo pode ser compilado para rodar tanto na CPU quanto na GPU. Isso \u00e9 poss\u00edvel porque Thrust permite escolher o backend de execu\u00e7\u00e3o: voc\u00ea pode usar OpenMP, TBB (Threading Building Blocks) ou a pr\u00f3pria GPU. Isso torna seu c\u00f3digo mais flex\u00edvel e port\u00e1til.</p> <p>3. Desempenho: Thrust \u00e9 otimizada para aproveitar ao m\u00e1ximo a capacidade de processamento paralelo das GPUs da Nvidia. Como muitos dos algoritmos oferecidos pela Thrust s\u00e3o implementados diretamente em CUDA, eles podem ser significativamente mais r\u00e1pidos que implementa\u00e7\u00f5es sequenciais tradicionais, especialmente em opera\u00e7\u00f5es que envolvem grandes volumes de dados.</p> <p>4. Reuso de C\u00f3digo: Assim como a STL, Thrust permite reutilizar muito c\u00f3digo. Como ela \u00e9 baseada em templates, voc\u00ea pode aplicar os mesmos algoritmos em diferentes tipos de dados e vetores, sem precisar reescrever a l\u00f3gica para cada caso.</p>"},{"location":"aulas/09-thrust/#usando-o-google-colab","title":"Usando o Google Colab","text":"<p>Primeiro, acesse o Google Colab, crie um novo notebook. No Colab, podemos escolher o tipo de hardware que o nosso c\u00f3digo vai usar. Para isso, v\u00e1 no menu \"Runtime\" e clique em \"change runtime type\". Na se\u00e7\u00e3o \u201cHardware accelerator\u201d, selecione \"T4 GPU\". Para que possamos executar o nosso c\u00f3digo diretamente na GPU.</p> <p>Para verificar se a GPU est\u00e1 ativa, rode o seguinte comando na c\u00e9lula do Colab:</p> <pre><code>!nvidia-smi\n</code></pre> <p>Este comando vai mostrar informa\u00e7\u00f5es sobre a GPU que estamos usando, como o modelo e o uso de mem\u00f3ria. Se tudo estiver certo, voc\u00ea ver\u00e1 a GPU listada, o que confirma que o ambiente est\u00e1 pronto.</p>"},{"location":"aulas/09-thrust/#compilacao-com-nvcc","title":"Compila\u00e7\u00e3o com NVCC","text":"<p>Agora que o Colab est\u00e1 configurado, precisamos entender como compilar nosso c\u00f3digo para rodar na GPU. O compilador que usamos para isso \u00e9 o <code>nvcc</code>, que faz parte do pacote de ferramentas da Nvidia do CUDA Toolkit.</p> <p>O <code>nvcc</code> \u00e9 um compilador que identifica quais partes do c\u00f3digo devem rodar na GPU e quais partes ficam na CPU. A grande vantagem dele \u00e9 que, no final, tudo \u00e9 combinado em um \u00fanico execut\u00e1vel que gerencia automaticamente quando a GPU ou CPU devem ser usadas.</p> <p>Vamos compilar um exemplo simples para testar o <code>nvcc</code>. Carreque o arquivo exemplo1.cu no colab, compile e crie um execut\u00e1vel, usando o comando:</p> <pre><code>%%writefile exemplo1.cu\n#include &lt;thrust/device_vector.h&gt; // Inclui a biblioteca para vetores na GPU (device)\n#include &lt;thrust/host_vector.h&gt;   // Inclui a biblioteca para vetores na CPU (host)\n#include &lt;iostream&gt;               // Biblioteca padr\u00e3o para entrada e sa\u00edda de dados\n\nint main() {\n    // Cria um vetor na CPU (host) com 5 elementos, todos inicializados com 0\n    thrust::host_vector&lt;double&gt; host(5, 0);\n    host[4] = 35; // Altera o \u00faltimo elemento do vetor para 35\n\n    /* Os dados do vetor 'host' s\u00e3o copiados para a GPU,\n       criando um vetor equivalente na GPU (device) */\n    thrust::device_vector&lt;double&gt; dev(host);\n\n    /* Altera o vetor na CPU, mas n\u00e3o afeta o vetor na GPU,\n       pois a c\u00f3pia j\u00e1 foi feita anteriormente */\n    host[2] = 12; // Altera o terceiro elemento do vetor na CPU para 12\n\n    // Exibe os elementos do vetor na CPU\n    printf(\"Host vector: \");\n    for (auto i = host.begin(); i != host.end(); i++) {\n        std::cout &lt;&lt; *i &lt;&lt; \" \"; // Acesso r\u00e1pido aos elementos na CPU\n    }\n    printf(\"\\n\");\n\n    // Exibe os elementos do vetor na GPU\n    printf(\"Device vector: \");\n    for (auto i = dev.begin(); i != dev.end(); i++) {\n        std::cout &lt;&lt; *i &lt;&lt; \" \"; // Acesso aos elementos na GPU \u00e9 lento, pois os dados est\u00e3o na GPU\n    }\n    printf(\"\\n\");\n}\n</code></pre> <pre><code>!nvcc -arch=sm_75 -std=c++14 exemplo1.cu -o exemplo1\n</code></pre> <p>Se tudo funcionar corretamente, este comando vai gerar um execut\u00e1vel chamado <code>exemplo1</code>, que podemos rodar para ver os resultados.</p> <pre><code>!./exemplo1\n</code></pre>"},{"location":"aulas/09-thrust/#transformacoes-e-operacoes-matematicas-com-vetores-na-gpu","title":"Transforma\u00e7\u00f5es e Opera\u00e7\u00f5es Matem\u00e1ticas com Vetores na GPU","text":"<p>Uma das grandes vantagens de Thrust \u00e9 a capacidade de aplicar transforma\u00e7\u00f5es e opera\u00e7\u00f5es ponto a ponto de forma eficiente, diretamente na GPU. Isso \u00e9 extremamente \u00fatil para manipula\u00e7\u00f5es de vetores, onde queremos aplicar opera\u00e7\u00f5es como soma, multiplica\u00e7\u00e3o, etc, de forma paralela.</p> <p>Com Thrust, podemos facilmente realizar essas transforma\u00e7\u00f5es entre vetores, utilizando fun\u00e7\u00f5es como <code>thrust::transform</code>, que permite aplicar uma opera\u00e7\u00e3o matem\u00e1tica entre os elementos de dois vetores ou transformar um vetor usando um valor constante. </p> <p>Neste exemplo, vamos criar dois vetores na GPU e aplicar transforma\u00e7\u00f5es entre eles, demonstrando como podemos somar os elementos de um vetor com outro e preencher vetores com valores espec\u00edficos. Essas opera\u00e7\u00f5es s\u00e3o realizadas de maneira otimizada na GPU, aproveitando o paralelismo do hardware para acelerar o processamento.</p> <p><pre><code>%%writefile exemplo2.cu\n#include &lt;thrust/device_vector.h&gt;              // Inclui a biblioteca para vetores na GPU\n#include &lt;thrust/host_vector.h&gt;                // Inclui a biblioteca para vetores na CPU\n#include &lt;thrust/sequence.h&gt;                   // Inclui a fun\u00e7\u00e3o para preencher vetores com uma sequ\u00eancia de n\u00fameros\n#include &lt;thrust/functional.h&gt;                 // Inclui opera\u00e7\u00f5es matem\u00e1ticas padr\u00e3o, como soma e multiplica\u00e7\u00e3o\n#include &lt;thrust/transform.h&gt;                  // Inclui a fun\u00e7\u00e3o para transformar vetores com opera\u00e7\u00f5es ponto a ponto\n#include &lt;thrust/iterator/constant_iterator.h&gt; // Inclui o iterador constante necess\u00e1rio\n#include &lt;iostream&gt;   \n\nint main() {\n    // Cria um vetor na GPU (device_vector) com 10 elementos, todos inicializados com 0\n    thrust::device_vector&lt;double&gt; V1(10, 0);\n    // Preenche V1 com uma sequ\u00eancia de n\u00fameros: {0, 1, 2, ..., 9}\n    thrust::sequence(V1.begin(), V1.end());\n\n    // Cria um vetor na GPU com 5 elementos, todos inicializados com 0\n    thrust::device_vector&lt;double&gt; V2(5, 0);\n    // Preenche os dois primeiros elementos de V2 com 5.5: {5.5, 5.5, 0, 0, 0}\n    thrust::fill(V2.begin(), V2.begin() + 2, 5.5);\n    // Preenche os elementos restantes de V2 com 10: {5.5, 5.5, 10, 10, 10}\n    thrust::fill(V2.begin() + 2, V2.end(), 10);\n\n    // Cria dois vetores na GPU com 10 elementos, para armazenar resultados das opera\u00e7\u00f5es\n    thrust::device_vector&lt;double&gt; V3(10); // Vetor para armazenar o resultado da soma\n    thrust::device_vector&lt;double&gt; V4(10); // Vetor para armazenar o resultado da multiplica\u00e7\u00e3o\n\n    // Aplica a opera\u00e7\u00e3o de soma elemento por elemento entre V1 e V2 e armazena o resultado em V3\n    // Como V2 tem menos elementos, o restante de V1 \u00e9 somado com zeros (elemento padr\u00e3o).\n    // Resultado: V3 = {0+5.5, 1+5.5, 2+10, 3+10, 4+10, 5+0, ..., 9+0}\n    thrust::transform(V1.begin(), V1.end(), V2.begin(), V3.begin(), thrust::plus&lt;double&gt;());\n\n    // Aplica multiplica\u00e7\u00e3o de V1 com o valor constante 0.5\n    // e armazenaria o resultado em V4.\n    thrust::transform(V1.begin(), V1.end(), thrust::constant_iterator&lt;double&gt;(0.5), V4.begin(), thrust::multiplies&lt;double&gt;());\n\n    // Imprime os elementos de V1\n    printf(\"V1: \");\n    for (thrust::device_vector&lt;double&gt;::iterator i = V1.begin(); i != V1.end(); i++) {\n        std::cout &lt;&lt; *i &lt;&lt; \" \"; // Acessa e imprime cada elemento do vetor V1\n    }\n    printf(\"\\n\");\n\n    // Imprime os elementos de V2\n    printf(\"V2: \");\n    for (thrust::device_vector&lt;double&gt;::iterator i = V2.begin(); i != V2.end(); i++) {\n        std::cout &lt;&lt; *i &lt;&lt; \" \"; // Acessa e imprime cada elemento do vetor V2\n    }\n    printf(\"\\n\");\n\n    // Imprime os elementos de V3\n    printf(\"V3: \");\n    for (thrust::device_vector&lt;double&gt;::iterator i = V3.begin(); i != V3.end(); i++) {\n        std::cout &lt;&lt; *i &lt;&lt; \" \"; // Acessa e imprime cada elemento do vetor V3\n    }\n    printf(\"\\n\");\n\n    // Imprime o vetor V4, que foi criado mas n\u00e3o utilizado.\n     printf(\"V4: \");\n    for (thrust::device_vector&lt;double&gt;::iterator i = V4.begin(); i != V4.end(); i++) {\n         std::cout &lt;&lt; *i &lt;&lt; \" \";\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre> Para compilar o exemplo2 no colab</p> <pre><code>!nvcc -arch=sm_75 -std=c++14 exemplo2.cu -o exemplo2\n</code></pre> <p>Para executar o bin\u00e1rio</p> <pre><code>!./exemplo2\n</code></pre>"},{"location":"aulas/09-thrust/#leitura-de-arquivos-pela-gpu","title":"Leitura de arquivos pela GPU","text":"<p>Neste exemplo,o c\u00f3digo faz a leitura de uma s\u00e9rie de valores num\u00e9ricos que representam, por exemplo, os pre\u00e7os hist\u00f3ricos de a\u00e7\u00f5es. Esses valores s\u00e3o inicialmente armazenados em um vetor na mem\u00f3ria da CPU, chamado <code>host_vector</code>. Em seguida, esses dados s\u00e3o copiados para a GPU usando um <code>device_vector</code>.</p> <p>O objetivo do c\u00f3digo \u00e9 medir dois tempos: o tempo de leitura dos dados na CPU e o tempo de c\u00f3pia dos dados para a GPU. Avaliar esses tempos ajuda a identificar como a comunica\u00e7\u00e3o entre a CPU e a GPU pode afetar o desempenho geral do seu programa. </p> <pre><code>%%writefile stocks.cu\n#include &lt;thrust/device_vector.h&gt;   // Inclui a biblioteca Thrust para vetores na GPU\n#include &lt;thrust/host_vector.h&gt;     // Inclui a biblioteca Thrust para vetores na CPU\n#include &lt;iostream&gt;                 // Biblioteca padr\u00e3o para entrada e sa\u00edda de dados\n#include &lt;chrono&gt;                   // Biblioteca para medir o tempo de execu\u00e7\u00e3o do c\u00f3digo\nusing namespace std;\n\nint main() {\n    int n = 2518;                   // Define o tamanho do vetor (2518 elementos)\n    double value = 0.0;             // Vari\u00e1vel auxiliar para armazenar o valor lido da entrada\n    std::chrono::duration&lt;double&gt; diff; // Vari\u00e1vel para armazenar a diferen\u00e7a de tempo calculada\n\n    // Marca o in\u00edcio da medi\u00e7\u00e3o do tempo de leitura dos dados\n    auto leitura_i = std::chrono::steady_clock::now();\n\n    // Cria um vetor na CPU (host_vector) com n elementos, todos inicializados com 0\n    thrust::host_vector&lt;double&gt; host(n, 0);\n\n    // Loop para ler n valores da entrada padr\u00e3o e armazen\u00e1-los no vetor host\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; value;              // L\u00ea um valor da entrada padr\u00e3o\n        host[i] = value;           // Armazena o valor lido no vetor host\n    }\n\n    // Marca o fim da medi\u00e7\u00e3o do tempo de leitura dos dados\n    auto leitura_f = std::chrono::steady_clock::now();\n\n    // Calcula o tempo gasto na leitura dos dados\n    diff = leitura_f - leitura_i;\n\n    // Exibe o tempo de leitura em segundos\n    cout &lt;&lt; \"Tempo de LEITURA (em segundos)  \" &lt;&lt; diff.count() &lt;&lt; endl;\n\n    // Marca o in\u00edcio da medi\u00e7\u00e3o do tempo de c\u00f3pia dos dados da CPU para a GPU\n    auto copia_i = std::chrono::steady_clock::now();\n\n    // Cria um vetor na GPU (device_vector) copiando os dados do vetor host da CPU\n    thrust::device_vector&lt;double&gt; dev(host);\n\n    // Marca o fim da medi\u00e7\u00e3o do tempo de c\u00f3pia dos dados\n    auto copia_f = std::chrono::steady_clock::now();\n\n    // Calcula o tempo gasto na c\u00f3pia dos dados para a GPU\n    diff = copia_f - copia_i;\n\n    // Exibe o tempo de c\u00f3pia em segundos\n    cout &lt;&lt; \"Tempo de C\u00d3PIA (em segundos)  \" &lt;&lt; diff.count() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Para compilar o c\u00f3digo:</p> <p><pre><code>!nvcc -arch=sm_70 -std=c++14 stocks.cu -o stocks\n</code></pre> Fa\u00e7a upload deste arquivo no seu colab para executar o exemplo</p> <pre><code>!./stocks &lt; stocks-google.txt\n</code></pre>"},{"location":"aulas/09-thrust/#operacoes-de-reducao-e-transformacoes","title":"Opera\u00e7\u00f5es de Redu\u00e7\u00e3o e Transforma\u00e7\u00f5es","text":"<p>Al\u00e9m de gerenciar a transfer\u00eancia de dados, a Thrust tamb\u00e9m facilita opera\u00e7\u00f5es complexas como redu\u00e7\u00f5es (soma, m\u00e1ximo, m\u00ednimo) e transforma\u00e7\u00f5es entre vetores. Esses tipos de opera\u00e7\u00f5es s\u00e3o muito \u00fateis em c\u00e1lculos intensivos, como an\u00e1lise de s\u00e9ries temporais de pre\u00e7os de a\u00e7\u00f5es.</p> <p>Redu\u00e7\u00f5es com Thrust:</p> <p>Redu\u00e7\u00f5es s\u00e3o opera\u00e7\u00f5es que reduzem um vetor a um \u00fanico valor. Por exemplo, podemos calcular a soma, o m\u00e1ximo ou a m\u00e9dia dos elementos de um vetor. A fun\u00e7\u00e3o <code>thrust::reduce</code> \u00e9 usada para esse tipo de opera\u00e7\u00e3o.</p> <p>Um exemplo para calcular a soma dos elementos de um vetor:</p> <pre><code>#include &lt;thrust/device_vector.h&gt;\n#include &lt;thrust/reduce.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Criando um vetor na GPU com 5 elementos: {10, 20, 30, 40, 50}\n    thrust::device_vector&lt;int&gt; vec_gpu(5);\n    thrust::sequence(vec_gpu.begin(), vec_gpu.end(), 10, 10);\n\n    // Calculando a soma dos elementos\n    int soma = thrust::reduce(vec_gpu.begin(), vec_gpu.end(), 0, thrust::plus&lt;int&gt;());\n\n    std::cout &lt;&lt; \"Soma dos elementos: \" &lt;&lt; soma &lt;&lt; std::endl; // Sa\u00edda: 150\n\n    return 0;\n}\n</code></pre> <p>Aqui, usamos <code>thrust::sequence</code> para preencher o vetor e <code>thrust::reduce</code> para somar todos os elementos. O valor <code>0</code> \u00e9 o valor inicial da soma e <code>thrust::plus&lt;int&gt;</code> \u00e9 a opera\u00e7\u00e3o de adi\u00e7\u00e3o.</p> <p>Transforma\u00e7\u00f5es entre Vetores:</p> <p>Al\u00e9m das redu\u00e7\u00f5es, podemos realizar transforma\u00e7\u00f5es entre vetores, que envolvem modificar um vetor com base em opera\u00e7\u00f5es ponto a ponto, ou at\u00e9 mesmo combinar dois vetores em um.</p> <p>Por exemplo, vamos calcular a diferen\u00e7a ponto a ponto entre os pre\u00e7os das a\u00e7\u00f5es da Apple e da Microsoft usando <code>thrust::transform</code>:</p> <pre><code>#include &lt;thrust/device_vector.h&gt;\n#include &lt;thrust/transform.h&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    // Criando vetores de pre\u00e7os na GPU\n    thrust::device_vector&lt;double&gt; AAPL(5, 150.0);  // Exemplo com pre\u00e7o fixo\n    thrust::device_vector&lt;double&gt; MSFT(5, 140.0);  // Exemplo com pre\u00e7o fixo\n    thrust::device_vector&lt;double&gt; diff(5);         // Para armazenar as diferen\u00e7as\n\n    // Calculando a diferen\u00e7a ponto a ponto entre os pre\u00e7os\n    thrust::transform(AAPL.begin(), AAPL.end(), MSFT.begin(), diff.begin(), thrust::minus&lt;double&gt;());\n\n    // Exibindo as diferen\u00e7as\n    for (int i = 0; i &lt; diff.size(); i++) {\n        std::cout &lt;&lt; \"Diferen\u00e7a \" &lt;&lt; i &lt;&lt; \": \" &lt;&lt; diff[i] &lt;&lt; std::endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, <code>thrust::minus&lt;double&gt;</code> \u00e9 a opera\u00e7\u00e3o usada para calcular a diferen\u00e7a entre os elementos correspondentes dos dois vetores.</p> <p>Para entender mais sobre as funcionalidades da Thrust, verifique a documenta\u00e7\u00e3o oficial dispon\u00edvel no site da Thrust. </p>"},{"location":"aulas/09-thrust/#atividade","title":"Atividade","text":"<p>Vamos trabalhar com um arquivo que cont\u00e9m os pre\u00e7os das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos, stocks-google.txt. A ideia \u00e9 ler esses dados com um <code>thrust::host_vector</code>, transferir para a GPU e, em seguida, process\u00e1-los. </p> <p>Exerc\u00edcio 1: Leitura e Transfer\u00eancia de Dados</p> <ol> <li>Leia os pre\u00e7os das a\u00e7\u00f5es de stocks-google.txt e armazenem em um <code>host_vector</code>.</li> <li>Crie um <code>device_vector</code> e transfiram os dados do <code>host_vector</code> para ele.</li> <li>Me\u00e7a o tempo de aloca\u00e7\u00e3o e c\u00f3pia dos dados usando a biblioteca <code>std::chrono</code> e imprimam esse tempo para ver quanto tempo a opera\u00e7\u00e3o leva.</li> </ol> <p>Exerc\u00edcio 2: C\u00e1lculo de M\u00e9dias e Extremos</p> <p>Agora que os dados est\u00e3o na GPU, vamos realizar algumas opera\u00e7\u00f5es de redu\u00e7\u00e3o. As opera\u00e7\u00f5es de redu\u00e7\u00e3o s\u00e3o aquelas que transformam um vetor em um \u00fanico valor, como calcular a soma ou o m\u00e1ximo dos elementos.</p> <ol> <li>Calcule o pre\u00e7o m\u00e9dio das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos.</li> <li>Calcule o pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 365 dias.</li> <li>Encontre o maior e o menor pre\u00e7o do per\u00edodo total e do \u00faltimo ano.</li> </ol> <p>Exerc\u00edcio 3: Transforma\u00e7\u00f5es entre Vetores</p> <p>Vamos trabalhar com outro arquivo, stocks2.txt, que cont\u00e9m os pre\u00e7os das a\u00e7\u00f5es da Apple e Microsoft. O objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es das duas empresas.</p> <p>O dataset cont\u00e9m pre\u00e7os simulados das a\u00e7\u00f5es da Apple (AAPL) e da Microsoft (MSFT) ao longo dos \u00faltimos 10 anos, com cerca de 3520 registros, representando aproximadamente 352 dias de negocia\u00e7\u00e3o por ano. Cada linha do arquivo tem dois valores separados por v\u00edrgula: o primeiro \u00e9 o pre\u00e7o da a\u00e7\u00e3o da Apple e o segundo \u00e9 o pre\u00e7o da a\u00e7\u00e3o da Microsoft.</p> <ol> <li>Leia os pre\u00e7os das a\u00e7\u00f5es de ambas as empresas e armazenem em dois <code>device_vectors</code>.</li> <li>Calcule a diferen\u00e7a ponto a ponto entre os dois vetores e armazenem as diferen\u00e7as em um terceiro vetor.</li> <li>Calcule a m\u00e9dia das diferen\u00e7as para entender qual empresa teve, em m\u00e9dia, um pre\u00e7o maior.</li> </ol> <p>Entrega do relat\u00f3rio para 24/03 as 23h59</p>"},{"location":"aulas/09-thrust/revisao/","title":"Revis\u00e3o para P1","text":"<p>Um investidor possui um or\u00e7amento de R$ 100.000,00 para aplicar no mercado de a\u00e7\u00f5es. Uma institui\u00e7\u00e3o financeira lhe d\u00e1 as seguintes op\u00e7\u00f5es para construir o seu portif\u00f3lio de investimentos, a ser composto por lotes de a\u00e7\u00f5es:</p> A\u00c7\u00c3O VALOR DO LOTE RETORNO DO LOTE IMPOSTO A PAGAR PETR4 R$ 30.000,00 R$ 2.700,00 R$ 640,00 DELL6 R$ 60.000,00 R$ 4.500,00 R$ 900,00 MICR7 R$ 30.000,00 R$ 6.400,00 R$ 1.200,00 IBMC3 R$ 40.000,00 R$ 4.600,00 R$ 940,00 <p>N\u00e3o \u00e9 poss\u00edvel comprar a\u00e7\u00f5es fracionadas, somente o lote inteiro. Com base neste cen\u00e1rio:</p> <ol> <li>Modele este problema como um problema de otimiza\u00e7\u00e3o.</li> <li>Crie uma entrada de dados para a inst\u00e2ncia do problema como mostrado acima.</li> <li>Implemente em C++ uma busca exaustiva para montar uma proposta de portif\u00f3lio para o cliente.</li> <li>Implemente uma estrat\u00e9gia do tipo branch-and-bound em C++ para a busca exaustiva da quest\u00e3o 3.</li> <li>Implemente em C++ uma heur\u00edstica para acelerar a busca exaustiva da quest\u00e3o 3.</li> <li>Obtenha e compare os tempos de execu\u00e7\u00e3o das tr\u00eas implementa\u00e7\u00f5es anteriores.</li> </ol>"},{"location":"aulas/10-iteradores/","title":"Aula 10: Iteradores e fun\u00e7\u00f5es customizadas","text":"<p>J\u00e1 vimos que, para valer a pena usar a GPU, precisamos tratar grandes volumes de dados ou realizar c\u00e1lculos complexos. Hoje, nosso foco ser\u00e1 calcular a vari\u00e2ncia e analisar as varia\u00e7\u00f5es di\u00e1rias de a\u00e7\u00f5es de maneira otimizada, usando iteradores din\u00e2micos e fun\u00e7\u00f5es customizadas.</p>"},{"location":"aulas/10-iteradores/#calculo-da-variancia-usando-iteradores-dinamicos","title":"C\u00e1lculo da Vari\u00e2ncia usando Iteradores Din\u00e2micos","text":"<p>Vamos calcular a vari\u00e2ncia das diferen\u00e7as entre os pre\u00e7os de a\u00e7\u00f5es. A f\u00f3rmula da vari\u00e2ncia \u00e9 dada por:</p>  \\text{Vari\u00e2ncia} = \\frac{1}{n} \\sum_{i=0}^{n} (x_i - \\mu)^2  <p>onde  \\mu  \u00e9 a m\u00e9dia. Sugerimos que voc\u00ea consulte a documenta\u00e7\u00e3o de thrust::constant_iterator e utilize este iterador para gerar dinamicamente o vetor de m\u00e9dias durante o c\u00e1lculo, evitando assim o uso excessivo de mem\u00f3ria. Isso permite calcular a vari\u00e2ncia sem precisar alocar espa\u00e7o adicional na GPU.</p>"},{"location":"aulas/10-iteradores/#analise-de-variacao-diaria-dos-precos-de-acoes","title":"An\u00e1lise de Varia\u00e7\u00e3o Di\u00e1ria dos Pre\u00e7os de A\u00e7\u00f5es","text":"<p>Em seguida, vamos trabalhar com o arquivo stocks-google.txt. A ideia \u00e9 criar um vetor que contenha a diferen\u00e7a di\u00e1ria entre o pre\u00e7o de um dia e o anterior. Se o vetor original se chama <code>stocks</code>, o vetor de sa\u00edda <code>ganho_diario</code> ser\u00e1 calculado de forma que:</p>  \\text{ganho\\_diario}[i] = \\text{stocks}[i+1] - \\text{stocks}[i]  <p>Lembre-se que o tamanho de <code>ganho_diario</code> ser\u00e1 um elemento a menos que <code>stocks</code>. Utilize a opera\u00e7\u00e3o thrust::transform para calcular essas diferen\u00e7as, prestando aten\u00e7\u00e3o nas condi\u00e7\u00f5es de tamanho dos vetores.</p>"},{"location":"aulas/10-iteradores/#contagem-de-dias-com-aumento-no-preco-das-acoes","title":"Contagem de Dias com Aumento no Pre\u00e7o das A\u00e7\u00f5es","text":"<p>Ap\u00f3s calcular as diferen\u00e7as di\u00e1rias, vamos descobrir quantas vezes o pre\u00e7o das a\u00e7\u00f5es subiu. Para isso, utilize a fun\u00e7\u00e3o thrust::count_if com uma fun\u00e7\u00e3o customizada para contar apenas os elementos positivos de <code>ganho_diario</code>. </p>"},{"location":"aulas/10-iteradores/#calculo-do-aumento-medio-nos-dias-em-que-o-preco-subiu","title":"C\u00e1lculo do Aumento M\u00e9dio nos Dias em que o Pre\u00e7o Subiu","text":"<p>Com a contagem em m\u00e3os, vamos calcular o aumento m\u00e9dio, mas apenas nos dias em que o pre\u00e7o subiu. Primeiro, voc\u00ea deve substituir todos os valores negativos de <code>ganho_diario</code> por zero, usando a fun\u00e7\u00e3o thrust::replace_if. Depois, calcule a soma desses valores para obter o total dos aumentos, e divida pelo n\u00famero de aumentos, obtido anteriormente com <code>count_if</code>. Isso permitir\u00e1 calcular a m\u00e9dia apenas dos valores positivos, filtrando os dias em que o pre\u00e7o das a\u00e7\u00f5es realmente aumentou.</p>"},{"location":"aulas/10-iteradores/#discussao-de-resultados","title":"Discuss\u00e3o de Resultados","text":"<p>Ao longo desses exerc\u00edcios, queremos que voc\u00ea reflita sobre a efici\u00eancia de usar a GPU para esses c\u00e1lculos. Observe o tempo de execu\u00e7\u00e3o e o uso de mem\u00f3ria, e considere como iteradores din\u00e2micos e fun\u00e7\u00f5es de transforma\u00e7\u00e3o ajudam a otimizar o processamento. </p> <p>A atividade deve ser entregue via BlackBoard at\u00e9 as 23h59 de 20/09 </p>"},{"location":"aulas/11-funcoes-customizadas/","title":"Fun\u00e7\u00f5es Customizadas e Otimiza\u00e7\u00e3o com Fusion Kernel","text":"<p>Nesta aula, vamos criar opera\u00e7\u00f5es customizadas usando functors, entender como combinar transforma\u00e7\u00f5es e redu\u00e7\u00f5es, e explorar a otimiza\u00e7\u00e3o com fusion kernel, uma t\u00e9cnica que melhora o desempenho ao combinar v\u00e1rias opera\u00e7\u00f5es em uma \u00fanica execu\u00e7\u00e3o na GPU.</p>"},{"location":"aulas/11-funcoes-customizadas/#introducao-a-operacoes-customizadas","title":"Introdu\u00e7\u00e3o a Opera\u00e7\u00f5es Customizadas","text":"<p>A principal vantagem de trabalhar com Thrust \u00e9 que podemos criar nossas pr\u00f3prias opera\u00e7\u00f5es customizadas, conhecidas como functors. Functors nada mais s\u00e3o do que structs ou classes que sobrecarregam o operador <code>()</code> para aplicar uma fun\u00e7\u00e3o sobre os elementos de um vetor. Vamos come\u00e7ar com um exemplo cl\u00e1ssico, o c\u00e1lculo Saxpy.</p> <p>O Saxpy (Single precision A X Plus Y) calcula a seguinte f\u00f3rmula para cada elemento dos vetores <code>x</code> e <code>y</code>: </p>  z = a \\cdot x + y  <p>onde <code>a</code> \u00e9 uma constante e <code>x</code> e <code>y</code> s\u00e3o vetores. Podemos implementar o Saxpy como um functor da seguinte maneira:</p> <pre><code>struct saxpy\n{\n    int a;    \n    saxpy(int a_) : a(a_) {};  // Construtor que inicializa a constante 'a'\n\n    __host__ __device__\n    double operator()(const int&amp; x, const int&amp; y) const {\n        return a * x + y;  // Opera\u00e7\u00e3o que ser\u00e1 aplicada a cada elemento de x e y\n    }\n};\n</code></pre> <p>Criamos um struct chamado <code>saxpy</code> que recebe a constante <code>a</code> no construtor. Dentro do functor, sobrecarregamos o operador <code>()</code> para aplicar a f\u00f3rmula  a \\cdot x + y . A anota\u00e7\u00e3o <code>__host__ __device__</code> indica que essa opera\u00e7\u00e3o pode ser executada tanto na CPU quanto na GPU.</p> <p>Uma vez criado o functor, podemos us\u00e1-lo em uma fun\u00e7\u00e3o de transforma\u00e7\u00e3o que processa dois vetores e combina os elementos de forma paralela. Isso \u00e9 feito com a fun\u00e7\u00e3o <code>thrust::transform</code>:</p> <pre><code>thrust::transform(d_a.begin(), d_a.end(), d_b.begin(), d_c.begin(), saxpy(m));\n</code></pre> <p>Aqui, <code>d_a</code> e <code>d_b</code> s\u00e3o os vetores de entrada, e <code>d_c</code> \u00e9 o vetor de sa\u00edda. A opera\u00e7\u00e3o definida pelo functor <code>saxpy(m)</code> ser\u00e1 aplicada a cada par de elementos de <code>d_a</code> e <code>d_b</code>. Esse tipo de opera\u00e7\u00e3o \u00e9 chamado de transforma\u00e7\u00e3o bin\u00e1ria, pois estamos combinando dois vetores.</p> <p>Ap\u00f3s a transforma\u00e7\u00e3o, podemos copiar o vetor <code>d_c</code> de volta para a CPU, e o resultado final de cada opera\u00e7\u00e3o ser\u00e1 armazenado e exibido.</p>"},{"location":"aulas/11-funcoes-customizadas/#exercicio-pratico","title":"Exerc\u00edcio Pr\u00e1tico:","text":"<p>Implemente o c\u00e1lculo Saxpy para dois vetores aleat\u00f3rios, experimente diferentes valores para a constante <code>a</code> e observe os resultados.</p>"},{"location":"aulas/11-funcoes-customizadas/#transformacoes-unarias-e-binarias","title":"Transforma\u00e7\u00f5es Un\u00e1rias e Bin\u00e1rias","text":"<p>Nem todas as transforma\u00e7\u00f5es operam sobre dois vetores. Algumas vezes, queremos realizar uma opera\u00e7\u00e3o em apenas um vetor, o que chamamos de transforma\u00e7\u00e3o un\u00e1ria. Um exemplo seria elevar cada elemento de um vetor ao quadrado. Para isso, usamos um functor diferente, que aceita apenas um argumento:</p> <pre><code>struct square\n{\n    __host__ __device__\n    float operator()(const float&amp; x) const {\n        return x * x;  // Elevar ao quadrado\n    }\n};\n</code></pre> <p>Com esse functor, podemos aplicar a fun\u00e7\u00e3o <code>thrust::transform</code> para processar cada elemento de um vetor:</p> <pre><code>thrust::transform(d_v.begin(), d_v.end(), d_v.begin(), square());\n</code></pre> <p>Aqui, <code>d_v</code> \u00e9 tanto o vetor de entrada quanto de sa\u00edda. Cada elemento de <code>d_v</code> ser\u00e1 elevado ao quadrado.</p> <p>Agora que entendemos a ideia de transformar vetores, podemos explorar um problema mais avan\u00e7ado: calcular a magnitude de um vetor.</p>"},{"location":"aulas/11-funcoes-customizadas/#calculando-a-magnitude-de-um-vetor","title":"Calculando a Magnitude de um Vetor","text":"<p>A magnitude (ou norma) de um vetor  v  \u00e9 uma medida de seu comprimento no espa\u00e7o. A f\u00f3rmula para a magnitude \u00e9:</p>  \\text{magnitude}(v) = \\sqrt{\\sum{v_i^2}}  <p>Podemos implementar esse c\u00e1lculo usando dois passos: primeiro, elevamos cada elemento ao quadrado (com uma transforma\u00e7\u00e3o un\u00e1ria); depois, somamos os resultados (usando uma redu\u00e7\u00e3o). Em vez de aplicar essas opera\u00e7\u00f5es separadamente, podemos usar <code>thrust::transform_reduce</code>, que combina a transforma\u00e7\u00e3o e a redu\u00e7\u00e3o em uma \u00fanica opera\u00e7\u00e3o.</p> <p>Um exemplo de como implementar isso:</p> <pre><code>struct square\n{\n    __host__ __device__\n    float operator()(const float&amp; x) const {\n        return x * x;  // Fun\u00e7\u00e3o de eleva\u00e7\u00e3o ao quadrado\n    }\n};\n\nfloat magnitude(thrust::device_vector&lt;float&gt;&amp; v) {\n    float sum_of_squares = thrust::transform_reduce(v.begin(), v.end(), square(), 0.0f, thrust::plus&lt;float&gt;());\n    return std::sqrt(sum_of_squares);\n}\n</code></pre> <p>O <code>thrust::transform_reduce</code> faz duas coisas: aplica o functor <code>square</code> para transformar os elementos e depois usa <code>thrust::plus&lt;float&gt;()</code> para somar os resultados. O valor inicial da soma \u00e9 <code>0.0f</code>.</p> <p>Neste exemplo, calculamos a soma dos quadrados dos elementos do vetor e, em seguida, aplicamos a fun\u00e7\u00e3o <code>std::sqrt()</code> para obter a magnitude.</p>"},{"location":"aulas/11-funcoes-customizadas/#exercicio-pratico_1","title":"Exerc\u00edcio Pr\u00e1tico:","text":"<p>Implemente uma fun\u00e7\u00e3o que calcula a magnitude de um vetor de floats. Compare os resultados com uma implementa\u00e7\u00e3o em C++ feita na CPU para ver a diferen\u00e7a no tempo de execu\u00e7\u00e3o.</p>"},{"location":"aulas/11-funcoes-customizadas/#otimizacao-com-fusion-kernel","title":"Otimiza\u00e7\u00e3o com Fusion Kernel","text":"<p>Muitas vezes, quando executamos opera\u00e7\u00f5es na GPU, estamos gastando mais tempo do que o necess\u00e1rio movendo dados entre a CPU e a GPU, ou entre diferentes partes da GPU. Isso acontece quando realizamos v\u00e1rias opera\u00e7\u00f5es separadas que poderiam ser combinadas em uma \u00fanica etapa. A t\u00e9cnica chamada fusion kernel resolve esse problema ao combinar m\u00faltiplas opera\u00e7\u00f5es em um \u00fanico kernel, economizando tempo.</p> <p>Em vez de calcular a magnitude de um vetor com duas opera\u00e7\u00f5es (uma transforma\u00e7\u00e3o para elevar ao quadrado e outra para somar), podemos fazer isso com uma \u00fanica chamada de fun\u00e7\u00e3o, combinando tudo com <code>thrust::transform_reduce</code>. A fus\u00e3o de kernels elimina a necessidade de mover dados entre diferentes opera\u00e7\u00f5es.</p> <p>Para ilustrar o conceito, vamos calcular a vari\u00e2ncia de um conjunto de dados. A f\u00f3rmula para a vari\u00e2ncia \u00e9:</p>  \\text{Var}(X) = \\frac{1}{n} \\sum_{i=1}^{n} (x_i - \\mu)^2  <p>onde  \\mu  \u00e9 a m\u00e9dia do vetor. Em vez de calcular a m\u00e9dia e, em seguida, calcular a vari\u00e2ncia, podemos usar o fusion kernel para fazer tudo em uma \u00fanica etapa.</p> <p>Um exemplo de como implementar isso:</p> <pre><code>struct variance_op\n{\n    float mean;\n    variance_op(float mean_) : mean(mean_) {}  // Construtor que armazena a m\u00e9dia\n\n    __host__ __device__\n    float operator()(const float&amp; x) const {\n        float diff = x - mean;  // Diferen\u00e7a em rela\u00e7\u00e3o \u00e0 m\u00e9dia\n        return diff * diff;  // Elevar ao quadrado a diferen\u00e7a\n    }\n};\n\nfloat calculate_variance(const thrust::device_vector&lt;float&gt;&amp; d_vec, float mean) {\n    return thrust::transform_reduce(d_vec.begin(), d_vec.end(), variance_op(mean), 0.0f, thrust::plus&lt;float&gt;()) / d_vec.size();\n}\n</code></pre> <p>Neste c\u00f3digo, usamos <code>thrust::transform_reduce</code> para calcular a soma das diferen\u00e7as ao quadrado em uma \u00fanica etapa. A opera\u00e7\u00e3o <code>variance_op</code> subtrai a m\u00e9dia de cada elemento e eleva o resultado ao quadrado, e <code>thrust::plus&lt;float&gt;()</code> soma os resultados. Tudo isso ocorre em uma \u00fanica chamada de kernel, sem necessidade de transferir os dados entre a CPU e a GPU repetidamente.</p>"},{"location":"aulas/11-funcoes-customizadas/#exercicio-pratico_2","title":"Exerc\u00edcio Pr\u00e1tico:","text":"<p>Implemente o c\u00e1lculo da vari\u00e2ncia usando a t\u00e9cnica de fusion kernel. Compare o desempenho com a implementa\u00e7\u00e3o que calcula a m\u00e9dia e a vari\u00e2ncia em etapas separadas. Use diferentes tamanhos de vetor e observe as diferen\u00e7as de desempenho.</p> <p>A atividade deve ser entregue at\u00e9 as 23h59 de 07/04 </p>"},{"location":"aulas/12-openmp/for_paralelo/","title":"Atividade 13: Paralelizando C\u00f3digos Recursivos","text":""},{"location":"aulas/12-openmp/for_paralelo/#paralelizando-codigos-recursivos","title":"Paralelizando C\u00f3digos Recursivos","text":"<p>Vamos agora focar na paraleliza\u00e7\u00e3o de c\u00f3digo recursivo, como o c\u00e1lculo do Pi.</p> <p>Examine o c\u00f3digo <code>pi_recursivo.cpp</code> e identifique oportunidades de paralelismo:</p> <pre><code>#include &lt;omp.h&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nstatic long num_steps = 1024l*1024*1024*2;\n\n#define MIN_BLK  1024*1024*256\n\ndouble sum = 0;\n\nvoid pi_r(long Nstart, long Nfinish, double step) {\n    long i,iblk;\n    if (Nfinish-Nstart &lt; MIN_BLK){\n        for (i = Nstart; i &lt; Nfinish; i++){\n            double x = (i+0.5)*step;\n            sum += 4.0/(1.0+x*x); \n        }\n    } else {\n        iblk = Nfinish-Nstart;\n        pi_r(Nstart,         Nfinish-iblk/2,step);\n        pi_r(Nfinish-iblk/2, Nfinish,       step);\n    }\n}\n\nint main () {\n    long i;\n    double step, pi;\n    double init_time, final_time;\n    step = 1.0/(double) num_steps;\n    init_time = omp_get_wtime();\n    pi_r(0, num_steps, step);\n    pi = step * sum;\n    final_time = omp_get_wtime() - init_time;\n\n    std::cout &lt;&lt; \"for \" &lt;&lt; num_steps &lt;&lt; \" steps pi = \" &lt;&lt; std::setprecision(15) &lt;&lt; pi &lt;&lt; \" in \" &lt;&lt; final_time &lt;&lt; \" secs\\n\";\n}\n</code></pre> <p>Para refletir:</p> <ol> <li> <p>Existem depend\u00eancias que dificultam a paraleliza\u00e7\u00e3o?</p> </li> <li> <p>Quantas chamadas recursivas s\u00e3o feitas?</p> </li> <li> <p>Onde \u00e9 poss\u00edvel inserir paralelismo no c\u00f3digo?</p> </li> </ol>"},{"location":"aulas/12-openmp/for_paralelo/#paralelizando-com-for-parallel","title":"Paralelizando com <code>for parallel</code>","text":"<p>Analise onde o loop pode ser paralelizado e adicione a diretiva <code>#pragma omp parallel for</code>. Me\u00e7a o tempo de execu\u00e7\u00e3o com diferentes valores de <code>MIN_BLK</code> e veja o impacto no desempenho.</p> <p>Dica: O valor de <code>MIN_BLK</code> pode influenciar significativamente o desempenho, j\u00e1 que um valor muito baixo aumenta a sobrecarga de cria\u00e7\u00e3o de tarefas, enquanto um valor muito alto reduz o paralelismo.</p>"},{"location":"aulas/12-openmp/for_paralelo/#paralelizando-com-task","title":"Paralelizando com <code>task</code>","text":"<p>Adicione a diretiva <code>#pragma omp task</code> para paralelizar as chamadas recursivas no c\u00f3digo. Utilize <code>#pragma omp taskwait</code> para garantir que todas as tarefas sejam conclu\u00eddas antes de seguir em frente.</p> <p>Experimente diferentes n\u00fameros de tarefas e compare os ganhos de desempenho com a vers\u00e3o paralela utilizando <code>for</code>.</p>"},{"location":"aulas/12-openmp/for_paralelo/#lidando-com-efeitos-colaterais","title":"Lidando com Efeitos Colaterais","text":"<p>Programas paralelos podem ter efeitos colaterais, como no caso de modifica\u00e7\u00f5es em estruturas compartilhadas entre threads (por exemplo, o vetor <code>vec</code> no c\u00f3digo <code>vetor_insert.cpp</code>).</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unistd.h&gt;\n\n\ndouble conta_complexa(int i) {\n    return 2 * i;\n}\n\nint main() {\n    int N = 10000; \n    std::vector&lt;double&gt; vec;\n    for (int i = 0; i &lt; N; i++) {\n        vec.push_back(conta_complexa(i));\n    }\n\n    for (int i = 0; i &lt; N; i++) {\n        std::cout &lt;&lt; i &lt;&lt; \" \";\n    }\n\n    return 0;\n}\n</code></pre> <p>Para evitar conflitos, podemos usar regi\u00f5es cr\u00edticas:</p> <pre><code>#pragma omp critical\n{\n    vec.push_back(conta_complexa(i));\n}\n</code></pre> <p>Mas cuidado! Incluir c\u00f3digo demais dentro de uma se\u00e7\u00e3o cr\u00edtica pode anular os ganhos de paralelismo. Procure isolar apenas a parte que realmente necessita de exclusividade.</p>"},{"location":"aulas/12-openmp/for_paralelo/#pre-alocacao-de-memoria","title":"Pr\u00e9-Aloca\u00e7\u00e3o de Mem\u00f3ria","text":"<p>Uma estrat\u00e9gia mais eficiente \u00e9 alocar mem\u00f3ria previamente, evitando o uso de <code>push_back</code> em regi\u00f5es cr\u00edticas. Isso pode ser feito da seguinte maneira:</p> <pre><code>vec.resize(N);\n#pragma omp parallel for\nfor (int i = 0; i &lt; N; i++) {\n    vec[i] = conta_complexa(i);\n}\n</code></pre> <p>Com isso, voc\u00ea elimina a necessidade de sincroniza\u00e7\u00e3o entre threads, melhorando o desempenho.</p>"},{"location":"aulas/12-openmp/for_paralelo/#calculo-do-pi","title":"Calculo do PI","text":"<ol> <li> <p>Paralelize o c\u00e1lculo recursivo de Pi usando <code>parallel for</code> e me\u00e7a o tempo de execu\u00e7\u00e3o. Execute o c\u00f3digo pelo menos 3 vezes com diferentes valores de <code>MIN_BLK</code> e registre os tempos.</p> </li> <li> <p>Paralelize o c\u00e1lculo recursivo de Pi usando <code>#pragma omp task</code> e me\u00e7a o tempo de execu\u00e7\u00e3o. Execute o c\u00f3digo pelo menos 3 vezes com diferentes n\u00fameros de tarefas e registre os tempos.</p> </li> </ol> <p>Para Analisar:</p> <ul> <li> <p>Qual abordagem (<code>parallel for</code> ou <code>tasks</code>) apresentou melhor desempenho? </p> </li> <li> <p>O valor de <code>MIN_BLK</code> ou o n\u00famero de tarefas influenciou significativamente o tempo de execu\u00e7\u00e3o?</p> </li> <li> <p>Alguma abordagem teve varia\u00e7\u00e3o maior entre execu\u00e7\u00f5es? Por qu\u00ea?</p> </li> </ul>"},{"location":"aulas/12-openmp/for_paralelo/#3-manipulacao-de-efeitos-colaterais-no-vetor","title":"3. Manipula\u00e7\u00e3o de Efeitos Colaterais no Vetor","text":"<ol> <li> <p>Paralelize o c\u00f3digo que modifica um vetor com <code>#pragma omp critical</code> para evitar acessos simult\u00e2neos ao vetor e registre os tempos de execu\u00e7\u00e3o. Execute o c\u00f3digo pelo menos 3 vezes e registre os tempos.</p> </li> <li> <p>Modifique o c\u00f3digo para pr\u00e9-alocar a mem\u00f3ria do vetor, evitando o uso de <code>push_back</code>, e me\u00e7a o tempo. Execute o c\u00f3digo pelo menos 3 vezes e registre os tempos.</p> </li> </ol> <p>Para Analisar:</p> <ul> <li> <p>Qual abordagem teve melhor desempenho: <code>omp critical</code> ou pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria?</p> </li> <li> <p>O uso de <code>omp critical</code> adicionou muito overhead? Como voc\u00ea pode justificar isso?</p> </li> <li> <p>A ordem dos dados no vetor foi mantida em ambas as abordagens?</p> </li> </ul>"},{"location":"aulas/12-openmp/for_paralelo/#entrega-da-atividade","title":"Entrega da Atividade","text":"<ul> <li> <p>Apresente suas an\u00e1lises com base nos resultados obtidos nos testes.</p> </li> <li> <p>Qual abordagem voc\u00ea considera mais eficiente para problemas recursivos? e com efeitos colaterais?</p> </li> <li> <p>Alguma t\u00e9cnica apresentou resultados inesperados? O que poderia explicar isso?</p> </li> </ul> <p>Fa\u00e7a a subimiss\u00e3o do seu relat\u00f3rio  at\u00e9 as 23h59 de 24/04 </p>"},{"location":"aulas/12-openmp/schedule/","title":"Trabalhando com Schedulers no OpenMP","text":"<p>No OpenMP, schedulers controlam a distribui\u00e7\u00e3o de itera\u00e7\u00f5es de loops entre threads. A primeira tarefa ser\u00e1 entender como diferentes schedulers funcionam.</p> <p>Tenha o c\u00f3digo abaixo dispon\u00edvel na sua pasta scratch no Cluster Franky</p> <p>omp_schedulers.cpp</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;omp.h&gt;\nvoid print_iterations(const std::string&amp; description,\nconst std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nconst int n)\n{\n    std::vector&lt; std::string &gt; strings(4, std::string());\nfor (int i = 0; i != n; i++)\n    {\nfor (int j = 0; j != 4; j++)\n        {\nconst auto&amp; vector = vectors[j];\nauto it = std::find(vector.begin(), vector.end(), i);\nif (it != vector.end())\n            {\n                strings[j] += \"*\";\n            }\nelse \n            { \n                strings[j] += \" \";\n            }\n        }\n    }\n    std::cout &lt;&lt; description &lt;&lt; std::endl;\nfor (auto&amp; s : strings)\n    {\n        std::cout &lt;&lt; s &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; std::endl;\n}\ntemplate &lt;typename T&gt;\nvoid schedule(T function, \nconst std::string&amp; description, \nconst int n)\n{\n    std::vector&lt; std::vector&lt;int&gt; &gt; vectors(4, std::vector&lt;int&gt;());\nfunction(vectors, n);\nprint_iterations(description, vectors, n);\n}\nvoid scheduleDefault(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for \nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleStatic(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n        #pragma omp for schedule(static)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleStatic4(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(static, 4)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleStatic8(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(static, 8)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleDynamic(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(dynamic)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleDynamic1(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(dynamic, 1)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleDynamic4(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(dynamic, 4)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleDynamic8(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(dynamic, 8)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleGuided(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(guided)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleGuided2(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(guided, 2)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleGuided4(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(guided, 4)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleGuided8(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(guided, 8)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleAuto(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(auto)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nvoid scheduleRuntime(std::vector&lt; std::vector&lt;int&gt; &gt;&amp; vectors,\nint n)\n{\n#pragma omp parallel num_threads(4), shared(vectors, n)\n    {    \n#pragma omp for schedule(auto)\nfor (int i = 0; i &lt; n; i++)\n        {\n            vectors[omp_get_thread_num()].push_back(i);\n        }\n    }\n}\nint main()\n{\nconst int n = 64;\nschedule(scheduleDefault,  \"default:               \", n);\nschedule(scheduleStatic,   \"schedule(static):      \", n);\nschedule(scheduleStatic4,  \"schedule(static, 4):   \", n);\nschedule(scheduleStatic8,  \"schedule(static, 8):   \", n);\nschedule(scheduleDynamic,  \"schedule(dynamic):     \", n);\nschedule(scheduleDynamic1, \"schedule(dynamic, 1):  \", n);\nschedule(scheduleDynamic4, \"schedule(dynamic, 4):  \", n);\nschedule(scheduleDynamic8, \"schedule(dynamic, 8):  \", n);\nschedule(scheduleGuided,   \"schedule(guided):      \", n);\nschedule(scheduleGuided2,  \"schedule(guided, 2):   \", n);\nschedule(scheduleGuided4,  \"schedule(guided, 4):   \", n);\nschedule(scheduleGuided8,  \"schedule(guided, 8):   \", n);\nschedule(scheduleAuto,     \"schedule(auto):        \", n);\nschedule(scheduleRuntime,  \"schedule(runtime):     \", n);\nreturn 0;\n}\n</code></pre> <p>Compile o c\u00f3digo no cluster com suporte ao OpenMP:</p> <pre><code>g++ -fopenmp omp_schedulers.cpp -o omp_schedulers\n</code></pre> <p>Crie um arquivo de submiss\u00e3o de job (<code>submit_job.sh</code>) com o seguinte conte\u00fado:</p> <pre><code>#!/bin/bash\n#SBATCH --job-name=omp_scheduler_test\n#SBATCH --output=output_omp_schedulers.txt\n#SBATCH --ntasks=1\n#SBATCH --cpus-per-task=4\n#SBATCH --time=00:05:00\n\n./omp_schedulers\n</code></pre> <p>Submeta o job ao Slurm:</p> <pre><code>sbatch submit_job.sh\n</code></pre> <p>Verifique os resultados no arquivo <code>output_omp_schedulers.txt</code>. Compare o output obtido com o exemplo fornecido, analisando como cada tipo de <code>scheduler</code> distribui as itera\u00e7\u00f5es dos loops.</p>"},{"location":"aulas/12-openmp/schedule/#analisando-os-schedulers-no-openmp","title":"Analisando os Schedulers no OpenMP","text":"<p>Cada scheduler do OpenMP se comporta de maneira diferente, e voc\u00ea deve observar o impacto de cada um:</p> <p>static: As itera\u00e7\u00f5es s\u00e3o divididas igualmente entre as threads.</p> <p>dynamic: As threads pegam blocos de itera\u00e7\u00f5es conforme terminam o trabalho.</p> <p>guided: Distribui blocos maiores no in\u00edcio e menores no final, equilibrando a carga.</p> <p>auto: Deixa o compilador escolher a melhor estrat\u00e9gia.</p> <p>runtime: Usa a estrat\u00e9gia definida em tempo de execu\u00e7\u00e3o.</p>"},{"location":"aulas/12-openmp/schedule/#entrega-da-atividade","title":"Entrega da Atividade","text":""},{"location":"aulas/12-openmp/schedule/#schedules","title":"Schedules","text":"<ol> <li> <p>Execute o c\u00f3digo com diferentes schedulers (static, dynamic, guided, auto) e registre o tempo necess\u00e1rio para cada execu\u00e7\u00e3o, fa\u00e7a ao menos 3 execu\u00e7\u00f5es para cada teste.</p> </li> <li> <p>Compare os tempos m\u00e9dios de execu\u00e7\u00e3o para cada scheduler.</p> </li> </ol> <p>Perguntas de An\u00e1lise:</p> <ul> <li> <p>Qual scheduler apresentou o menor tempo m\u00e9dio?</p> </li> <li> <p>Algum scheduler teve varia\u00e7\u00f5es significativas entre as execu\u00e7\u00f5es? Se sim, por qu\u00ea?</p> </li> <li> <p>Alguma caracter\u00edstica espec\u00edfica do trabalho (como carga de dados, balanceamento) parece ter influenciado o comportamento de um scheduler em particular?</p> </li> </ul> <p>Fa\u00e7a um relat\u00f3rio com as suas an\u00e1lises e entregue at\u00e9 as 23h59 de 24/04 </p>"},{"location":"aulas/15-gpu-iteradores/","title":"18 - Iteradores em Thrust","text":"<p>Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados.</p> <p>Warning</p> <p>Nesta aula trabalharemos extensivamente com a API da <code>thrust</code> e pediremos para que voc\u00eas consultem a documenta\u00e7\u00e3o oficial da biblioteca. Tamb\u00e9m pode ser \u00fatil ver a se\u00e7\u00e3o de exemplos do reposit\u00f3rio.</p>"},{"location":"aulas/15-gpu-iteradores/#iteradores","title":"Iteradores","text":"<p>Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por</p> \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 <p>Example</p> <p>J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando <code>thrust::fill</code>) e compute a vari\u00e2ncia usando a f\u00f3rmula acima.</p> <p>Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores.</p> <p>Example</p> <p>Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima.</p> <p>Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo <code>stocks.txt</code>.</p> <p>Example</p> <p>Leia o arquivo <code>stocks.txt</code> e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome <code>ganho_diario</code> e o de entrada <code>stocks</code>, temos que</p> <p><code>ganho_diario[i] = stocks[i+1] - stocks[i]</code></p> <p>Claramente <code>ganho_diario.size() == stocks.size() - 1</code>. Leve isto em conta ao utilizar a opera\u00e7\u00e3o <code>transform</code> para criar o vetor <code>ganho_diario</code>.</p>"},{"location":"aulas/15-gpu-iteradores/#operacoes-customizaveis","title":"Opera\u00e7\u00f5es customiz\u00e1veis","text":"<p>Com o vetor <code>ganho_diario</code> acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem:</p> <ol> <li>quantas vezes o valor subiu?</li> <li>qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato?</li> </ol> <p>Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Apesar de ser poss\u00edvel escrever essas fun\u00e7\u00f5es do zero, a <code>thrust</code> j\u00e1 possui diversas fun\u00e7\u00f5es de redu\u00e7\u00f5es customiz\u00e1veis.</p> <p>Warning</p> <p>\u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido.</p> <p>Question</p> <p>A <code>thrust</code> j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link. Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de <code>ganhos_diarios</code>?</p> <p>Warning</p> <p>A fun\u00e7\u00e3o <code>count_if</code> est\u00e1 atualmente com um erro em sua documenta\u00e7\u00e3o (link da issue). N\u00e3o se esque\u00e7a de colocar <code>const</code> no par\u00e2metro de <code>operator()</code>.</p> <p>Example</p> <p>Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu.</p> Resposta <p><code>1309</code></p> <p>Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma.</p> <p>Question</p> <p>A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana?</p> <p>Details</p> <p><code>replace_if</code></p> <p>Example</p> <p>Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por <code>0</code> em <code>ganhos_diarios</code>.</p> <p>\u00df</p> <p>Example</p> <p>Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos.</p> Resposta <p><code>5,25179</code></p>"},{"location":"aulas/16-gpu-customizacao/","title":"Thrust - Opera\u00e7\u00f5es customizadas","text":"<p>Vamos conhecer como criar opera\u00e7\u00f5es customizadas com Thrust. Para isso, vamos resolver um problema cl\u00e1ssico denominado <code>Saxpy</code>, o que significa <code>Single precision A X plus Y</code> . Na pr\u00e1tica, consiste em calcular um valor <code>z</code>, que \u00e9 dado por <code>ax + y</code>, onde <code>a</code> \u00e9 uma constante e <code>x</code> e <code>y</code> s\u00e3o vetores.</p> <p>O c\u00f3digo-fonte abaixo resolve o <code>Saxpy</code> em C++/Thrust. Vamos avali\u00e1-lo.</p> <pre><code> #include &lt;thrust/host_vector.h&gt;\n #include &lt;thrust/device_vector.h&gt;\n #include &lt;thrust/generate.h&gt;\n #include &lt;thrust/functional.h&gt;\n #include &lt;thrust/copy.h&gt;\n #include &lt;cstdlib&gt;\n #include &lt;algorithm&gt;\n #include &lt;iostream&gt;\n #include &lt;iomanip&gt;\n\n using namespace  std;\n\nstruct saxpy\n{\n    int a;    \n    saxpy(int a_) : a(a_) {};\n    __host__ __device__\n    double operator()(const int&amp; x, const int&amp; y) {\n           return a * x + y;\n    }\n};\n\nint main(int argc, char* argv[]) {\n     if (argc != 3) {\n         cerr &lt;&lt;\n          \"***Numero incorreto de argumentos ***\\n\";\n         return 1;\n     }\n\n     int n = atoi(argv[1]);\n     int m = atoi(argv[2]);\n\n     //gerar numeros aleatorios\n     thrust::host_vector&lt;int&gt; a(n);\n     thrust::host_vector&lt;int&gt; b(n);\n     thrust::host_vector&lt;int&gt; c(n);\n     thrust::generate(a.begin(), a.end(), rand);\n     thrust::generate(b.begin(), b.end(), rand);\n\n     //transferimos para a GPU\n     thrust::device_vector&lt;int&gt; d_a = a;\n     thrust::device_vector&lt;int&gt; d_b = b;\n\n     //transformacao\n\n     thrust::transform(d_a.begin(), d_a.end(),\n                       d_b.begin(), d_b.end(),\n                       saxpy(m));\n\n     thrust::copy(d_b.begin(), d_b.end(),\n     c.begin()); \n\n     for (int i = 0; i &lt; n; i++ )\n         cout &lt;&lt; setw(6) &lt;&lt; c[i] &lt;&lt; \" = \" \n          &lt;&lt; setw(2) &lt;&lt; m\n          &lt;&lt; \"*\" &lt;&lt; setw(5) &lt;&lt; a[i]\n          &lt;&lt; \"+\" &lt;&lt; setw(5) &lt;&lt; b[i]\n          &lt;&lt; endl;\n\n}\n</code></pre>"},{"location":"aulas/16-gpu-customizacao/#operacoes-customizadas-em-transform","title":"Opera\u00e7\u00f5es customizadas em <code>transform</code>","text":"<p>Para criar nossas pr\u00f3prias opera\u00e7\u00f5es usamos a seguinte sintaxe:</p> <pre><code>struct custom_transform\n{\n    // essas marca\u00e7\u00f5es indicam que o c\u00f3digo deve ser compilado para CPU (host) \n    // e GPU (device)\n    // IMPORTANTE: somente c\u00f3digo com a marca\u00e7\u00e3o __device__ \u00e9 compilado para GPU\n    __host__ __device__\n\n        double operator()(const double&amp; x, const double&amp; y) {\n            // isto pode ser usado com um transform que usa dois vetores \n            // e coloca o resultado em um terceiro.\n\n            // x \u00e9 um elemento do primeiro vetor\n            // y \u00e9 o elemento correspondente do segundo vetor\n\n            // o valor retornado \u00e9 colocado no vetor de resultados\n\n            // para fazer opera\u00e7\u00f5es un\u00e1rias basta receber somente um argumento.\n        }\n};\n</code></pre> <p>A opera\u00e7\u00e3o acima seria aceita em um transform como o abaixo:</p> <pre><code>thrust::device_vector&lt;double&gt; A, B, C;\nthrust::transform(A.begin(), A.end(), B.begin(), C.begin(), custom_transform());\n</code></pre> <p>Note que os tipos dos vetores devem bater com os tipos declarados no <code>struct</code>. Por vezes precisamos receber par\u00e2metros para a opera\u00e7\u00e3o customizada funcionar. Um truque comum \u00e9 adicionar atributos no <code>struct</code> usado como opera\u00e7\u00e3o:</p> <pre><code>struct T {\n    int attr;\n\n    T(int a): attr(a) {};\n\n    // TODO: opera\u00e7\u00e3o customizada aqui\n};\n</code></pre> <p>O valor <code>attr</code> estar\u00e1 dispon\u00edvel para uso dentro da opera\u00e7\u00e3o customizada. A linha <code>T(int a): attr(a) {}</code> declara o construtor do <code>struct T</code>. Ela faz com que o atributo <code>attr</code> seja inicializado com o valor do par\u00e2metro <code>a</code>. Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar <code>,</code> para separar as inicializa\u00e7\u00f5es. </p>"},{"location":"aulas/16-gpu-customizacao/#calculando-a-norma-magnitude-de-um-vetor","title":"Calculando a norma / magnitude de um vetor","text":"<p>A magnitude de um vetor consiste na raiz quadrada da soma do quadrado de seus elementos. Dessa forma, voc\u00ea deve complementar o c\u00f3digo abaixo, de modo a criar uma transforma\u00e7\u00e3o customizada <code>square</code>, a qual faz uma transforma\u00e7\u00e3o no vetor transformando os seus elementos ao quadrado, e posteriormente voc\u00ea deve fazer uma redu\u00e7\u00e3o, de modo a obter a magnitude do vetor.</p> <pre><code> #include &lt;iostream&gt;\n #include &lt;iomanip&gt;\n #include &lt;cstdlib&gt;\n #include &lt;chrono&gt;\n #include &lt;cstdlib&gt;\n #include &lt;algorithm&gt;\n//INSIRA AS IMPORTACOES NECESSARIAS DA THRUST\n #include &lt;cmath&gt;\n #include &lt;random&gt;\n\n using namespace std::chrono;\n\n void reportTime(const char* msg, steady_clock::duration span) {\n     auto ms = duration_cast&lt;milliseconds&gt;(span);\n     std::cout &lt;&lt; msg &lt;&lt; \" - levou - \" &lt;&lt;\n      ms.count() &lt;&lt; \" milisegundos\" &lt;&lt; std::endl;\n }\n\n // CRIE UMA FUNCTOR PARA CALCULAR A SQUARE\n\n\n\n // IMPLEMENTE O CALCULO DA MAGNITUDE COM THRUST\n float magnitude(                    ) {\n     float result;\n\n     // ... add Thrust calls\n     // AQUI VAO AS CHAMADAS THRUST \n\n     return result;\n }\n\n int main(int argc, char** argv) {\n     if (argc != 2) {\n         std::cerr &lt;&lt; argv[0] &lt;&lt; \": numero invalido de argumentos\\n\"; \n         std::cerr &lt;&lt; \"uso: \" &lt;&lt; argv[0] &lt;&lt; \"  tamanho do vetor\\n\"; \n         return 1;\n     }\n     int n = std::atoi(argv[1]); //numero de elementos\n     steady_clock::time_point ts, te;\n\n     // Fa\u00e7a um  vector em thrust \n\n\n\n     // inicilize o  vector\n     ts = steady_clock::now();\n\n     std::generate(                ,                      , std::rand);\n\n\n     te = steady_clock::now();\n     reportTime(\"Inicializacao\", te - ts);\n\n     // Calcule a magnitude do vetor\n     ts = steady_clock::now();\n     float len = magnitude(v_d);\n     te = steady_clock::now();\n     reportTime(\"Tempo para calculo\", te - ts);\n\n\n     std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4);\n     std::cout &lt;&lt; \"Magnitude : \" &lt;&lt; len &lt;&lt; std::endl;\n }\n</code></pre>"},{"location":"aulas/16-gpu-customizacao/#fusion","title":"Fusion","text":"<p>H\u00e1 opera\u00e7\u00f5es de transforma\u00e7\u00e3o e redu\u00e7\u00e3o feitas anteriormente que realizam muita troca de dados. Seria poss\u00edvel otimizar isso?</p> <p>A resposta \u00e9 sim. A Thrust possui o conceito de <code>fusion kernel</code>, o que representa uma estrat\u00e9gia para otimizar transforma\u00e7\u00f5es e redu\u00e7\u00f5es. Modifique o c\u00f3digo anteriormente desenvolvido, agora fazendo uso da transforma\u00e7\u00e3o abaixo:</p> <pre><code>std::sqrt(thrust::transform_reduce( v.begin(), v.end(), unary_op, init, binary_op));\n</code></pre> <p>Pergunta: para o problema da magnitude, quem \u00e9 a <code>unary_op</code> e a <code>binary_op</code>? Qual o valor de <code>init</code>? </p>"},{"location":"aulas/17-gpu-aleatoriedade/","title":"17 - GPU e n\u00fameros aleat\u00f3rios","text":""},{"location":"aulas/17-gpu-aleatoriedade/#revisao-de-numeros-aleatorios","title":"Revis\u00e3o de n\u00fameros aleat\u00f3rios","text":"<p>Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar:</p> <ul> <li>determin\u00edstico: Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed. Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada (seed).</li> <li>parece aleat\u00f3ria: Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG.</li> </ul> <p>Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio</p> <ol> <li>que o programa permita escolher o seed da simula\u00e7\u00e3o;</li> <li>que o seed usado seja publicado junto com os resultados.</li> </ol> <p>Muitas implementa\u00e7\u00f5es de RNGs  s\u00e3o divididas em duas partes:</p> <ol> <li>engine: algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria.</li> <li>distribution: utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme).</li> </ol> <p>A <code>thrust</code> cont\u00e9m uma API de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios muito parecida com a API da biblioteca padr\u00e3o de C++.</p> <p>Question</p> <p>Consulte a documenta\u00e7\u00e3o oficial da <code>thrust</code> e encontre as p\u00e1ginas que descrevem os engines e distributions implementados.</p> <p>Resposta</p> <pre><code>Abaixo temos um trecho de um c\u00f3digo-fonte que nos mostra como gerar n\u00fameros aleat\u00f3rios com thrust.\n</code></pre> <pre><code>#include &lt;thrust/random.h&gt;\n#include &lt;thrust/device_vector.h&gt;\n#include &lt;thrust/transform.h&gt;\n#include &lt;thrust/iterator/counting_iterator.h&gt;\n#include &lt;vector&gt;\n\nint main() {\nthrust::default_random_engine eng(10);\nthrust::uniform_real_distribution&lt;double&gt; d(20, 30);\n\nfor (int i = 0; i &lt; 10; i++) {\n    std::cout &lt;&lt; d(eng) &lt;&lt; \"\\n\";\n}\n\n}\n</code></pre> <p>Vamos agora fazer um uso b\u00e1sico dessas fun\u00e7\u00f5es.</p> <p>Example</p> <p>Crie um programa que leia um inteiro seed do terminal e:</p> <ol> <li>crie um objeto <code>default_random_engine</code> que o utilize como seed.</li> <li>mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme <code>[25, 40]</code>.</li> </ol> <p>Seu programa dever\u00e1 estar implementado usando os tipos definidos em <code>thrust::random</code>.</p> <p>Um ponto importante da API <code>thrust</code> para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 que essas fun\u00e7\u00f5es podem ser chamadas dentro de opera\u00e7\u00f5es customizadas! Nosso pr\u00f3ximo exerc\u00edcio trata justamente deste uso.</p> <p>Example</p> <p>Fa\u00e7a um programa que cria um vetor com 10 elementos e aplica uma opera\u00e7\u00e3o customizada que seta cada elemento com um valor aleat\u00f3rio. Use as mesmas configura\u00e7\u00f5es do exerc\u00edcio anterior. </p> <p>Resposta</p> <p>Use o trecho de c\u00f3digo disponibilizado neste gist para ver a estrutura da sua fun\u00e7\u00e3o customizada e como voc\u00ea pode criar uma transforma\u00e7\u00e3o que a invoca para cada elemento de um vetor. </p> <p>Warning</p> <p>Voc\u00ea pode prosseguir mesmo se seu vetor tem 10 n\u00fameros iguais.</p>"},{"location":"aulas/17-gpu-aleatoriedade/#gerando-numeros-pseudo-aleatorios-em-gpu","title":"Gerando n\u00fameros pseudo-aleat\u00f3rios em GPU","text":"<p>Um desafio em programas paralelos \u00e9 gerar sequ\u00eancias pseudo-aleat\u00f3rias de qualidade. Se n\u00e3o tormarmos cuidado acabamos gerando os mesmos n\u00fameros em threads diferentes e desperdi\u00e7amos grande quantidade de trabalho!</p> <p>Question</p> <p>Que abordagem voc\u00ea usou para gerar n\u00fameros aleat\u00f3rios em paralelo com OpenMP?</p> <p>Resposta</p> <p>Se voc\u00ea realizou todas as tarefas, deve ter criado um gerador de n\u00fameros pseudo-aleat\u00f3rios para cada thread para calcular o valor de \\pi usando Monte Carlo.</p> <p>Question</p> <p>Voc\u00ea acha que poder\u00edamos aplicar a mesma abordagem para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em GPU? Por qu\u00ea?</p> <p>Resposta</p> <p>Sem cuidados adicionais, n\u00e3o obter\u00edamos bons resultados. A abordagem usada na aula de openMP pressup\u00f5e um n\u00famero relativamente pequeno de threads, de forma que a sequ\u00eancia criada por cada gerador \u00e9 menor, por\u00e9m grande o suficiente para ter qualidade. No caso de usarmos uma GPU, o n\u00famero de threads pode ser muito grande, de forma que cada gerador geraria sequ\u00eancias muito curtas, e por isso perder\u00edamos em qualidade da sequ\u00eancia. </p>"},{"location":"aulas/17-gpu-aleatoriedade/#seeds-em-programas-massivamente-paralelos","title":"Seeds em programas massivamente paralelos","text":"<p>Em computa\u00e7\u00e3o massivamente paralela, em geral, existem duas abordagens.</p> <p>Abordagem 1: usar seeds diferentes em cada thread.</p> <p>Abordagem 2: usar a mesma seed em todas as threads, mas cada uma come\u00e7a em um ponto diferente da sequ\u00eancia daquela seed.</p> <p>Note que em ambos os casos os resultados dependem do n\u00famero de threads usadas! Como vimos em aulas anteriores, um RNG tem estado interno e n\u00e3o pode ser facilmente compartilhado entre v\u00e1rias threads.</p> <p>Example</p> <p>Implemente a abordagem 1 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode usar a estrat\u00e9gia de acesso direto aos dados e usar o \u00edndice recebido como seed. Lembre-se que a seed \u00e9 definida ao criar o <code>default_random_engine</code>. No exemplo abaixo, voc\u00ea pode ver que ela \u00e9 definida com o valor <code>10</code>. </p> <p><pre><code>    thrust::default_random_engine eng(10);\n</code></pre> Voc\u00ea deve ter percebido que todos os n\u00fameros gerados s\u00e3o parecidos, mas n\u00e3o id\u00eanticos. Isso ocorre pois geradores com *seed*s pr\u00f3ximos geram sequ\u00eancias que s\u00e3o inicialmente parecidas (e depois diferem). Podemos consertar isto usando seeds mais distantes.</p> <p>Example</p> <p>Multiplique <code>i</code> por um valor grande e tente de novo. Verifique que agora os n\u00fameros s\u00e3o diferentes</p>"},{"location":"aulas/17-gpu-aleatoriedade/#exercicio-pratico","title":"Exerc\u00edcio pr\u00e1tico","text":"<p>Vamos trabalhar com um m\u00e9todo probabil\u00edstico de estima\u00e7\u00e3o do <code>pi</code> neste \u00faltimo exerc\u00edcio. O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado <code>2</code>. Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi. </p> <ol> <li><code>sum = 0</code></li> <li>De <code>i=0</code> at\u00e9 <code>N</code>:<ol> <li>sorteie pontos x,y \\in [0,1]</li> <li>se x^2 + y^2 \\leq 1, <code>sum += 1</code></li> </ol> </li> <li>devolva <code>4 * sum / N</code></li> </ol> <p>Example</p> <p>Resgate a implementa\u00e7\u00e3o sequencial deste algoritmo realizada na aula (dispon\u00edvel neste gist) e rode-a para <code>N=100000000</code></p> <p>Example</p> <p>Paralelize o c\u00f3digo acima em GPU. Use ambas as abordagens acima em programas distintos para lidar com os geradores de n\u00fameros aleat\u00f3rios.</p>"},{"location":"aulas/21-SLURM/","title":"CLUSTERS - SLURM","text":""},{"location":"aulas/Broadcasting-mpi/","title":"20 - COMUNICA\u00c7\u00c3O COLETIVA E BROADCASTING","text":"<p>Nas aulas passadas, examinamos a comunica\u00e7\u00e3o ponto a ponto, que \u00e9 a comunica\u00e7\u00e3o entre dois processos. Nesta aula, estudaremos os mecanismos de comunica\u00e7\u00e3o coletiva em MPI. A comunica\u00e7\u00e3o coletiva \u00e9 um m\u00e9todo de comunica\u00e7\u00e3o que envolve a participa\u00e7\u00e3o de todos os processos em um comunicador.</p> <p>Broadcasting Dica: Fa\u00e7a uma c\u00f3pia do notebook para a sua conta do Colab, no menu File (ou Arquivo), op\u00e7\u00e3o Save a Copy in Drive (Salvar uma c\u00f3pia no Drive). </p>"},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/","title":"MPI AULA3","text":"<pre><code>!apt install simgrid\n</code></pre> <pre>\n<code>Reading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nNote, selecting 'libsimgrid-dev' instead of 'simgrid'\nThe following additional packages will be installed:\n  libsimgrid3.24 lua5.1 simgrid-java\nSuggested packages:\n  java-virtual-machine\nThe following NEW packages will be installed:\n  libsimgrid-dev libsimgrid3.24 lua5.1 simgrid-java\n0 upgraded, 4 newly installed, 0 to remove and 24 not upgraded.\nNeed to get 1,644 kB of archives.\nAfter this operation, 5,797 kB of additional disk space will be used.\nGet:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid3.24 amd64 3.24+dfsg-3 [1,328 kB]\nGet:2 http://archive.ubuntu.com/ubuntu focal/universe amd64 lua5.1 amd64 5.1.5-8.1build4 [94.6 kB]\nGet:3 http://archive.ubuntu.com/ubuntu focal/universe amd64 simgrid-java amd64 3.24+dfsg-3 [76.5 kB]\nGet:4 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid-dev amd64 3.24+dfsg-3 [145 kB]\nFetched 1,644 kB in 1s (1,369 kB/s)\nSelecting previously unselected package libsimgrid3.24.\n(Reading database ... 122531 files and directories currently installed.)\nPreparing to unpack .../libsimgrid3.24_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid3.24 (3.24+dfsg-3) ...\nSelecting previously unselected package lua5.1.\nPreparing to unpack .../lua5.1_5.1.5-8.1build4_amd64.deb ...\nUnpacking lua5.1 (5.1.5-8.1build4) ...\nSelecting previously unselected package simgrid-java.\nPreparing to unpack .../simgrid-java_3.24+dfsg-3_amd64.deb ...\nUnpacking simgrid-java (3.24+dfsg-3) ...\nSelecting previously unselected package libsimgrid-dev.\nPreparing to unpack .../libsimgrid-dev_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid-dev (3.24+dfsg-3) ...\nSetting up libsimgrid3.24 (3.24+dfsg-3) ...\nSetting up lua5.1 (5.1.5-8.1build4) ...\nupdate-alternatives: using /usr/bin/lua5.1 to provide /usr/bin/lua (lua-interpreter) in auto mode\nupdate-alternatives: using /usr/bin/luac5.1 to provide /usr/bin/luac (lua-compiler) in auto mode\nSetting up simgrid-java (3.24+dfsg-3) ...\nSetting up libsimgrid-dev (3.24+dfsg-3) ...\nProcessing triggers for man-db (2.9.1-1) ...\nProcessing triggers for libc-bin (2.31-0ubuntu9.9) ...\n</code>\n</pre> <pre><code>!git clone https://framagit.org/simgrid/simgrid-template-smpi.git\n</code></pre> <pre>\n<code>Cloning into 'simgrid-template-smpi'...\nremote: Enumerating objects: 482, done.\nremote: Counting objects: 100% (482/482), done.\nremote: Compressing objects: 100% (338/338), done.\nremote: Total 482 (delta 180), reused 435 (delta 139), pack-reused 0\nReceiving objects: 100% (482/482), 967.66 KiB | 1.48 MiB/s, done.\nResolving deltas: 100% (180/180), done.\n</code>\n</pre> <p>Uma das coisas a lembrar sobre a comunica\u00e7\u00e3o coletiva \u00e9 que ela implica um ponto de sincroniza\u00e7\u00e3o entre os processos. Isso significa que todos os processos devem atingir um ponto em seu c\u00f3digo antes que possam come\u00e7ar a executar novamente.</p> <p>Antes de entrar em detalhes sobre as rotinas de comunica\u00e7\u00e3o coletiva, vamos examinar a sincroniza\u00e7\u00e3o com mais detalhes. Acontece que o MPI possui uma fun\u00e7\u00e3o especial dedicada \u00e0 sincroniza\u00e7\u00e3o de processos:</p> <p>MPI_Barrier(MPI_Comm communicator)</p> <p>O nome da fun\u00e7\u00e3o \u00e9 bastante descritivo - a fun\u00e7\u00e3o forma uma barreira e nenhum processo no comunicador pode ultrapassar a barreira at\u00e9 que todos chamem a fun\u00e7\u00e3o. Imagine que o eixo horizontal representa a execu\u00e7\u00e3o do programa e os c\u00edrculos representam diferentes processos:</p> <p></p> <p>O processo zero primeiro chama MPI_Barrier no primeiro instante (T 1). Enquanto o processo zero est\u00e1 parado na barreira, o processo um e tr\u00eas eventualmente o fazem (T 2). Quando o processo dois finalmente chega \u00e0 barreira (T 3), todos os processos iniciam a execu\u00e7\u00e3o novamente (T 4).</p> <p>Lembre-se sempre de que todas as chamadas coletivas que voc\u00ea fizer s\u00e3o sincronizadas. Em outras palavras, se voc\u00ea n\u00e3o conseguir concluir com \u00eaxito um MPI_Barrier, tamb\u00e9m n\u00e3o poder\u00e1 concluir com \u00eaxito nenhuma chamada coletiva. Se voc\u00ea tentar chamar MPI_Barrier ou outras rotinas coletivas sem garantir que todos os processos no comunicador tamb\u00e9m o chamem, seu programa ficar\u00e1 ocioso. Isso pode ser muito confuso para iniciantes, ent\u00e3o tome cuidado!</p> <p></p> <p>Neste exemplo, o processo zero \u00e9 o processo-raiz e possui a c\u00f3pia inicial dos dados. Todos os outros processos recebem a c\u00f3pia dos dados.</p> <p>Em MPI, a transmiss\u00e3o pode ser realizada usando MPI_Bcast. O prot\u00f3tipo da fun\u00e7\u00e3o \u00e9 mostrado a seguir:</p> <p>MPI_Bcast(     void* data,     int count,     MPI_Datatype datatype,     int root,     MPI_Comm communicator)</p> <p>Embora o processo raiz e os processos receptores executem tarefas diferentes, todos eles chamam a mesma fun\u00e7\u00e3o MPI_Bcast. Quando o processo raiz (no nosso exemplo era o processo zero) chamar MPI_Bcast, a vari\u00e1vel de dados ser\u00e1 enviada para todos os outros processos. Quando todos os processos receptores chamarem MPI_Bcast, a vari\u00e1vel data ser\u00e1 preenchida com os dados do processo raiz.</p> <p>A transmiss\u00e3o pode ser implementada com as primitivas MPI_Send e MPI_Recv, conforme mostrado no programa abaixo:</p> <pre><code>%%writefile mybcast.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n\nvoid my_bcast(void* data, int count, MPI_Datatype datatype, int root,\n              MPI_Comm communicator) {\n  int world_rank;\n  MPI_Comm_rank(communicator, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(communicator, &amp;amp;world_size);\n\n  if (world_rank == root) {\n    // If we are the root process, send our data to everyone\n    int i;\n    for (i = 0; i &amp;lt; world_size; i++) {\n      if (i != world_rank) {\n        MPI_Send(data, count, datatype, i, 0, communicator);\n      }\n    }\n  } else {\n    // If we are a receiver process, receive the data from the root\n    MPI_Recv(data, count, datatype, root, 0, communicator, MPI_STATUS_IGNORE);\n  }\n}\n\nint main(int argc, char** argv) {\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n\n  int data;\n  if (world_rank == 0) {\n    data = 100;\n    printf(\"Process 0 broadcasting data %d\\n\", data);\n    my_bcast(&amp;amp;data, 1, MPI_INT, 0, MPI_COMM_WORLD);\n  } else {\n    my_bcast(&amp;amp;data, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    printf(\"Process %d received data %d from root process\\n\", world_rank, data);\n  }\n\n  MPI_Finalize();\n}\n</code></pre> <pre>\n<code>Writing mybcast.c\n</code>\n</pre> <pre><code>!smpicc mybcast.c -o mybcast\n</code></pre> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./mybcast\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nProcess 0 broadcasting data 100\nProcess 15 received data 100 from root process\nProcess 14 received data 100 from root process\nProcess 13 received data 100 from root process\nProcess 12 received data 100 from root process\nProcess 11 received data 100 from root process\nProcess 10 received data 100 from root process\nProcess 9 received data 100 from root process\nProcess 8 received data 100 from root process\nProcess 7 received data 100 from root process\nProcess 6 received data 100 from root process\nProcess 5 received data 100 from root process\nProcess 4 received data 100 from root process\nProcess 3 received data 100 from root process\nProcess 2 received data 100 from root process\nProcess 1 received data 100 from root process\n</code>\n</pre> <p>Acredite ou n\u00e3o, nossa fun\u00e7\u00e3o \u00e9 realmente muito ineficiente! Imagine que cada processo tenha apenas um link de rede de entrada/sa\u00edda. Nossa fun\u00e7\u00e3o \u00e9 usar apenas um link de rede do processo zero para enviar todos os dados. Uma implementa\u00e7\u00e3o mais inteligente \u00e9 um algoritmo de comunica\u00e7\u00e3o baseado em \u00e1rvore que pode usar mais links de rede dispon\u00edveis de uma s\u00f3 vez. Por exemplo:</p> <p></p> <p>O processo zero come\u00e7a com os dados e os envia para o processo um. Semelhante ao nosso exemplo anterior, o processo zero tamb\u00e9m envia os dados para o processo dois no segundo est\u00e1gio. A diferen\u00e7a com este exemplo \u00e9 que o processo um agora est\u00e1 ajudando o processo raiz encaminhando os dados para o processo tr\u00eas. Durante o segundo est\u00e1gio, duas conex\u00f5es de rede est\u00e3o sendo utilizadas por vez. A utiliza\u00e7\u00e3o da rede dobra em cada est\u00e1gio subseq\u00fcente da \u00e1rvore de comunica\u00e7\u00e3o at\u00e9 que todos os processos tenham recebido os dados.</p> <p>A implementa\u00e7\u00e3o do MPI_Bcast utiliza um algoritmo de transmiss\u00e3o em \u00e1rvore semelhante para uma boa utiliza\u00e7\u00e3o da rede. Abaixo temos o c\u00f3digo anterior comparado com a chamada de MPI_Bcast:</p> <pre><code>%%writefile mpibcast.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;assert.h&gt;\n\nvoid my_bcast(void* data, int count, MPI_Datatype datatype, int root,\n              MPI_Comm communicator) {\n  int world_rank;\n  MPI_Comm_rank(communicator, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(communicator, &amp;amp;world_size);\n\n  if (world_rank == root) {\n    // If we are the root process, send our data to everyone\n    int i;\n    for (i = 0; i &amp;lt; world_size; i++) {\n      if (i != world_rank) {\n        MPI_Send(data, count, datatype, i, 0, communicator);\n      }\n    }\n  } else {\n    // If we are a receiver process, receive the data from the root\n    MPI_Recv(data, count, datatype, root, 0, communicator, MPI_STATUS_IGNORE);\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc != 3) {\n    fprintf(stderr, \"Usage: compare_bcast num_elements num_trials\\n\");\n    exit(1);\n  }\n\n  int num_elements = atoi(argv[1]);\n  int num_trials = atoi(argv[2]);\n\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n\n  double total_my_bcast_time = 0.0;\n  double total_mpi_bcast_time = 0.0;\n  int i;\n  int* data = (int*)malloc(sizeof(int) * num_elements);\n  assert(data != NULL);\n\n  for (i = 0; i &amp;lt; num_trials; i++) {\n    // Time my_bcast\n    // Synchronize before starting timing\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_my_bcast_time -= MPI_Wtime();\n    my_bcast(data, num_elements, MPI_INT, 0, MPI_COMM_WORLD);\n    // Synchronize again before obtaining final time\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_my_bcast_time += MPI_Wtime();\n\n    // Time MPI_Bcast\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_mpi_bcast_time -= MPI_Wtime();\n    MPI_Bcast(data, num_elements, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_mpi_bcast_time += MPI_Wtime();\n  }\n\n  // Print off timing information\n  if (world_rank == 0) {\n    printf(\"Data size = %d, Trials = %d\\n\", num_elements * (int)sizeof(int),\n           num_trials);\n    printf(\"Avg my_bcast time = %lf\\n\", total_my_bcast_time / num_trials);\n    printf(\"Avg MPI_Bcast time = %lf\\n\", total_mpi_bcast_time / num_trials);\n  }\n\n  free(data);\n  MPI_Finalize();\n}\n</code></pre> <pre>\n<code>Writing mpibcast.c\n</code>\n</pre> <pre><code>!smpicc mpibcast.c -o mpibcast\n</code></pre> <p>Vamos, agora, rodar um experimento comparativo entre a nossa implementa\u00e7\u00e3o de transmiss\u00e3o e a do MPI, enviando 10 vezes um vetor de 100000 n\u00fameros do processo-mestre para os processos-escravos:</p> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./mpibcast 100000 10\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nData size = 400000, Trials = 10\nAvg my_bcast time = 0.068692\nAvg MPI_Bcast time = 0.018464\n</code>\n</pre> <pre><code>#COLOQUE SUA IMPLEMENTA\u00c7\u00c3O AQUI\n</code></pre> <pre><code>%%writefile pi.c\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;mpi.h&gt;\n\n/* We define pi here so we can check and see how accurate our computation is. */\n#define PI 3.141592653589793238462643\n\nint main(int argc, char **argv) {\n    MPI_Init(&amp;amp;argc, &amp;amp;argv);\n\n    int processes, myid;\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;processes);\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myid);\n\n\n    int intervals;\n    if (myid == 0) {\n        printf(\"Number of intervals: \");\n        fflush(stdout);\n        scanf(\"%d\", &amp;amp;intervals);\n    }\n\n    double time1 = MPI_Wtime();\n\n    MPI_Bcast(**********************************************************);\n\n    int count = intervals / processes;\n    int start = count * myid;\n    int end = count * myid + count;\n\n    int i;\n    double subtotal, total = 0;\n    for (i = start; i &amp;lt; end; ++i) {\n        subtotal += pow(-1, i) / (2 * i + 1);\n    }\n\n    MPI_Reduce(***********************************************************);\n\n    double time2 = MPI_Wtime();\n\n    if (myid == 0) {\n        total = total * 4;\n        printf(\"Result:   %.10lf\\n\", total);\n        printf(\"Accuracy: %.10lf\\n\", PI - total);\n        printf(\"Time:     %.10lf\\n\", time2 - time1);\n    }\n\n    MPI_Finalize();\n}\n</code></pre> <pre><code># PROPONHA SUA IMPLEMENTA\u00c7\u00c3O AQUI\n</code></pre>"},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/#message-passing-interface-aula-3","title":"MESSAGE PASSING INTERFACE (AULA 3)","text":""},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/#comunicacao-de-grupo-em-mpi","title":"COMUNICA\u00c7\u00c3O DE GRUPO EM MPI","text":"<p>Nas aulas passadas, examinamos a comunica\u00e7\u00e3o ponto a ponto, que \u00e9 a comunica\u00e7\u00e3o entre dois processos. Nesta aula, estudaremos os mecanismos de comunica\u00e7\u00e3o coletiva em MPI. A comunica\u00e7\u00e3o coletiva \u00e9 um m\u00e9todo de comunica\u00e7\u00e3o que envolve a participa\u00e7\u00e3o de todos os processos em um comunicador.</p> <p>Novamente, vamos reinstalar o simgrid e fazer o download do modelos de clusters:</p>"},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/#broadcasting-transmissao-em-mpi","title":"BROADCASTING (TRANSMISS\u00c3O) EM MPI","text":"<p>Uma transmiss\u00e3o \u00e9 uma das t\u00e9cnicas padr\u00e3o de comunica\u00e7\u00e3o coletiva. Durante uma transmiss\u00e3o, um processo envia os mesmos dados para todos os processos em um comunicador. Um dos principais usos da transmiss\u00e3o \u00e9 enviar a entrada do usu\u00e1rio para um programa paralelo ou enviar par\u00e2metros de configura\u00e7\u00e3o para todos os processos.</p> <p>O padr\u00e3o de comunica\u00e7\u00e3o de uma transmiss\u00e3o \u00e9 da seguinte forma:</p>"},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/#exercicio-1","title":"EXERC\u00cdCIO 1","text":"<p>Varie o n\u00famero de processadores, trials e n\u00fameros de elementos do c\u00f3digo anterior e compare os resultados.</p>"},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/#exercicio-2","title":"EXERC\u00cdCIO 2","text":"<p>Considere o c\u00f3digo abaixo, que produz uma aproxima\u00e7\u00e3o de PI usando as primitivas MPI_Bcast e MPI_Reduce. Neste c\u00f3digo:</p> <ul> <li>o mestre l\u00ea o n\u00famero de intervalos e o envia a todos os escravos</li> <li>os escravos calculam as suas aproxima\u00e7\u00f5es para PI usando a F\u00f3rmula de Leibiniz (subtotal)</li> <li>o mestre reduz o resultado usando uma soma dos subtotais</li> </ul> <p>Com base nesta descri\u00e7\u00e3o, complete (em ****) o c\u00f3digo fornecido:</p>"},{"location":"aulas/Broadcasting-mpi/MPI_AULA3/#exercicio-3","title":"EXERC\u00cdCIO 3","text":"<p>Ap\u00f3s o estudo de todas as primitivas de MPI realizadas at\u00e9 aqui, proponha o esquema de uma implementa\u00e7\u00e3o para resolver o problema da mochila.</p> <p>DESAFIO: implemente o esquema em MPI.</p>"},{"location":"aulas/Introducao-mpi/","title":"Introdu\u00e7\u00e3o a MPI","text":"<p>Message Passing Interface (MPI) \u00e9 um padr\u00e3o para comunica\u00e7\u00e3o de dados em computa\u00e7\u00e3o paralela. Existem v\u00e1rias modalidades de computa\u00e7\u00e3o paralela, e dependendo do problema que se est\u00e1 tentando resolver, pode ser necess\u00e1rio passar informa\u00e7\u00f5es entre os v\u00e1rios processadores ou n\u00f3s de um cluster, e o MPI oferece uma infraestrutura para essa tarefa.</p> <p>Para iniciarmos o nosso estudo de MPI, implemente os desafios abaixo, entendendo como encadear <code>sends</code> e <code>receives</code>, e o impacto nos resultados.</p>"},{"location":"aulas/Introducao-mpi/#exercicios-mpi","title":"Exerc\u00edcios MPI","text":""},{"location":"aulas/Introducao-mpi/#exercicio-1-comunicacao-entre-dois-processos","title":"Exerc\u00edcio 1: Comunica\u00e7\u00e3o entre Dois Processos","text":"<p>Descri\u00e7\u00e3o: Escreva um programa MPI em que o processo de rank 0 envia uma mensagem <code>\"Ol\u00e1\"</code> para o processo de rank 1, e o processo 1 responde com <code>\"Oi\"</code> ao processo 0.</p> <p>Instru\u00e7\u00f5es:</p> <ol> <li> <p>O processo com rank 0 envia uma mensagem <code>\"Ol\u00e1\"</code> para o processo com rank 1.</p> </li> <li> <p>O processo com rank 1 responde com <code>\"Oi\"</code> para o processo com rank 0.</p> </li> <li> <p>Exiba as mensagens trocadas no terminal.</p> </li> </ol>"},{"location":"aulas/Introducao-mpi/#exercicio-2-anel-de-processos","title":"Exerc\u00edcio 2: Anel de Processos","text":"<p>Descri\u00e7\u00e3o: Crie um programa MPI onde cada processo envia uma mensagem para o pr\u00f3ximo processo, formando um anel. O \u00faltimo processo envia a mensagem de volta ao primeiro.</p> <p>Instru\u00e7\u00f5es:</p> <ol> <li> <p>Cada processo com rank <code>i</code> envia uma mensagem para o processo de rank <code>i+1</code>.</p> </li> <li> <p>O \u00faltimo processo (com o maior rank) envia de volta ao processo com rank 0.</p> </li> <li> <p>O n\u00famero de processos deve ser maior que 2.</p> </li> <li> <p>Exiba a mensagem recebida por cada processo no terminal.</p> </li> </ol> <p>Dicas: - O processo com rank 0 envia e recebe por \u00faltimo para fechar o anel.</p>"},{"location":"aulas/Introducao-mpi/#exercicio-3-difusao-linear","title":"Exerc\u00edcio 3: Difus\u00e3o Linear","text":"<p>Descri\u00e7\u00e3o: O processo com rank 0 inicia enviando uma mensagem para o processo 1. O processo 1, ao receber a mensagem, envia-a para o processo 2, e assim sucessivamente, at\u00e9 que todos os processos tenham recebido a mensagem.</p> <p>Instru\u00e7\u00f5es:</p> <ol> <li> <p>O processo com rank 0 envia uma mensagem inicial para o processo com rank 1.</p> </li> <li> <p>Cada processo recebe a mensagem do processo anterior e a envia para o pr\u00f3ximo.</p> </li> <li> <p>O \u00faltimo processo exibe a mensagem no terminal.</p> </li> </ol> <p>Dicas: - Cada processo (exceto o \u00faltimo) deve executar um <code>MPI_Recv</code> seguido de um <code>MPI_Send</code>.</p>"},{"location":"aulas/Introducao-mpi/#exercicio-4-comunicacao-multipla","title":"Exerc\u00edcio 4: Comunica\u00e7\u00e3o M\u00faltipla","text":"<p>Descri\u00e7\u00e3o: Implemente um programa MPI onde o processo com rank 0 envia diferentes mensagens para cada um dos outros processos. Cada processo (exceto o 0) recebe sua mensagem e imprime o conte\u00fado.</p> <p>Instru\u00e7\u00f5es:</p> <ol> <li> <p>O processo com rank 0 envia mensagens exclusivas para cada processo, incluindo o n\u00famero do processo na mensagem (ex: \"Mensagem para o processo X\").</p> </li> <li> <p>Cada processo, ao receber sua mensagem, imprime no terminal o que recebeu.</p> </li> <li> <p>Use um la\u00e7o no processo 0 para enviar as mensagens para todos os outros.</p> </li> </ol> <p>Dicas: Lembre-se de utilizar tags nas mensagens para diferenci\u00e1-las, se necess\u00e1rio.</p>"},{"location":"aulas/Introducao-mpi/#exercicio-5-somas-paralelas","title":"Exerc\u00edcio 5: Somas Paralelas","text":"<p>Descri\u00e7\u00e3o: Crie um programa MPI em que cada processo recebe um valor num\u00e9rico exclusivo, soma-o ao valor de um processo anterior, e o \u00faltimo processo exibe a soma total de todos os processos.</p> <p>Instru\u00e7\u00f5es:</p> <ol> <li> <p>O processo 0 inicia com um valor inicial e o envia para o processo 1.</p> </li> <li> <p>Cada processo soma seu valor ao que recebeu do processo anterior e envia a soma para o pr\u00f3ximo processo.</p> </li> <li> <p>O \u00faltimo processo imprime a soma total.</p> </li> </ol> <p>Dicas: Cada processo realiza uma soma antes de enviar o resultado ao pr\u00f3ximo.</p>"},{"location":"aulas/Introducao-mpi/#exercicio-6-alternancia-de-mensagens","title":"Exerc\u00edcio 6: Altern\u00e2ncia de Mensagens","text":"<p>Descri\u00e7\u00e3o:  Escreva um programa em que o processo 0 envia uma mensagem para o processo 1, o qual envia uma mensagem de volta para o processo 0. O processo 0, ent\u00e3o, envia uma segunda mensagem para o processo 2, e assim sucessivamente at\u00e9 que todos os processos tenham sido envolvidos na comunica\u00e7\u00e3o.</p> <p>Instru\u00e7\u00f5es:</p> <ol> <li> <p>O processo com rank 0 envia uma mensagem para o processo 1.</p> </li> <li> <p>O processo 1 responde ao processo 0.</p> </li> <li> <p>O processo 0 ent\u00e3o envia uma segunda mensagem para o processo 2, que responde.</p> </li> <li> <p>Continue este padr\u00e3o at\u00e9 o \u00faltimo processo.</p> </li> </ol>"},{"location":"aulas/Introducao-mpi/#entrega","title":"Entrega","text":"<p>Para cada exerc\u00edcio, entregue seu c\u00f3digo, o arquivo <code>.slurm</code>, o output do seu resultado.</p> <p>Fa\u00e7a a sua subimiss\u00e3o at\u00e9 as 23h59 de 05/05 </p>"},{"location":"aulas/MPI/","title":"MPI","text":""},{"location":"aulas/MPI-OpenMP/","title":"MPI e OpenMP","text":""},{"location":"aulas/MPI-REDUCE/","title":"Opera\u00e7\u00f5es de Redu\u00e7\u00e3o em MPI","text":"<p>Reduzir \u00e9 um conceito cl\u00e1ssico da programa\u00e7\u00e3o funcional. A redu\u00e7\u00e3o de dados envolve a redu\u00e7\u00e3o de um conjunto de n\u00fameros em um conjunto menor de n\u00fameros por meio de uma fun\u00e7\u00e3o. Por exemplo, digamos que temos uma lista de n\u00fameros [1, 2, 3, 4, 5]. Reduzir esta lista de n\u00fameros com a fun\u00e7\u00e3o sum produziria sum([1, 2, 3, 4, 5]) = 15. Da mesma forma, a redu\u00e7\u00e3o da multiplica\u00e7\u00e3o resultaria em multiplicar([1, 2, 3, 4, 5]) = 120.</p> <p>Como voc\u00ea deve ter imaginado, pode ser muito complicado aplicar fun\u00e7\u00f5es de redu\u00e7\u00e3o em um conjunto de n\u00fameros distribu\u00eddos. Junto com isso, \u00e9 dif\u00edcil programar de forma eficiente redu\u00e7\u00f5es n\u00e3o comutativas, ou seja, redu\u00e7\u00f5es que devem ocorrer em uma ordem definida. Felizmente, o MPI tem uma fun\u00e7\u00e3o \u00fatil chamada MPI_Reduce que ir\u00e1 lidar com quase todas as redu\u00e7\u00f5es comuns que um programador precisa fazer em um aplicativo paralelo.</p> <p>Para iniciarmos o nosso estudo de redu\u00e7\u00f5es em MPI, abra o seguinte notebook no Google Colab e siga as instru\u00e7\u00f5es contidas:</p> <p>Redu\u00e7\u00f5es em MPI Dica: Fa\u00e7a uma c\u00f3pia do notebook para a sua conta do Colab, no menu File (ou Arquivo), op\u00e7\u00e3o Save a Copy in Drive (Salvar uma c\u00f3pia no Drive). </p>"},{"location":"aulas/MPI-REDUCE/MPI_AULA2/","title":"MPI AULA2","text":"<pre><code>!apt install simgrid\n</code></pre> <pre>\n<code>Reading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nNote, selecting 'libsimgrid-dev' instead of 'simgrid'\nThe following additional packages will be installed:\n  libsimgrid3.24 lua5.1 simgrid-java\nSuggested packages:\n  java-virtual-machine\nThe following NEW packages will be installed:\n  libsimgrid-dev libsimgrid3.24 lua5.1 simgrid-java\n0 upgraded, 4 newly installed, 0 to remove and 24 not upgraded.\nNeed to get 1,644 kB of archives.\nAfter this operation, 5,797 kB of additional disk space will be used.\nGet:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid3.24 amd64 3.24+dfsg-3 [1,328 kB]\nGet:2 http://archive.ubuntu.com/ubuntu focal/universe amd64 lua5.1 amd64 5.1.5-8.1build4 [94.6 kB]\nGet:3 http://archive.ubuntu.com/ubuntu focal/universe amd64 simgrid-java amd64 3.24+dfsg-3 [76.5 kB]\nGet:4 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid-dev amd64 3.24+dfsg-3 [145 kB]\nFetched 1,644 kB in 3s (587 kB/s)\nSelecting previously unselected package libsimgrid3.24.\n(Reading database ... 122520 files and directories currently installed.)\nPreparing to unpack .../libsimgrid3.24_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid3.24 (3.24+dfsg-3) ...\nSelecting previously unselected package lua5.1.\nPreparing to unpack .../lua5.1_5.1.5-8.1build4_amd64.deb ...\nUnpacking lua5.1 (5.1.5-8.1build4) ...\nSelecting previously unselected package simgrid-java.\nPreparing to unpack .../simgrid-java_3.24+dfsg-3_amd64.deb ...\nUnpacking simgrid-java (3.24+dfsg-3) ...\nSelecting previously unselected package libsimgrid-dev.\nPreparing to unpack .../libsimgrid-dev_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid-dev (3.24+dfsg-3) ...\nSetting up libsimgrid3.24 (3.24+dfsg-3) ...\nSetting up lua5.1 (5.1.5-8.1build4) ...\nupdate-alternatives: using /usr/bin/lua5.1 to provide /usr/bin/lua (lua-interpreter) in auto mode\nupdate-alternatives: using /usr/bin/luac5.1 to provide /usr/bin/luac (lua-compiler) in auto mode\nSetting up simgrid-java (3.24+dfsg-3) ...\nSetting up libsimgrid-dev (3.24+dfsg-3) ...\nProcessing triggers for man-db (2.9.1-1) ...\nProcessing triggers for libc-bin (2.31-0ubuntu9.9) ...\n</code>\n</pre> <pre><code>!git clone https://framagit.org/simgrid/simgrid-template-smpi.git\n</code></pre> <pre>\n<code>Cloning into 'simgrid-template-smpi'...\nremote: Enumerating objects: 482, done.\nremote: Counting objects: 100% (482/482), done.\nremote: Compressing objects: 100% (338/338), done.\nremote: Total 482 (delta 181), reused 434 (delta 139), pack-reused 0\nReceiving objects: 100% (482/482), 967.28 KiB | 1.92 MiB/s, done.\nResolving deltas: 100% (181/181), done.\n</code>\n</pre> <p>Na aula passada, implementamos um c\u00f3digo para aproxima\u00e7\u00e3o de PI usando MPI com 8 e 16 nodos de um cluster, utilizando as primitivas de comunica\u00e7\u00e3o MPI_Send e MPI_Recv.</p> <pre><code>%%writefile pi_send_receive.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"mpi.h\"\n#include &lt;math.h&gt;\n#define SEED_MPI 35791246\n\nint main(int argc, char* argv[])\n{\n    long niter = 10000000;\n    int myid;                       //holds process's rank id\n    double x,y;                     //x,y value for the random coordinate\n    int i, count=0;                 //Count holds all the number of how many good coordinates\n    double z;                       //Used to check if x^2+y^2&amp;lt;=1\n    double pi;                      //holds approx value of pi\n    int nodenum;\n\n    MPI_Init(&amp;amp;argc, &amp;amp;argv);                 //Start MPI\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myid);           //get rank of node's process\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;nodenum);\n    int recieved[nodenum];\n    long recvniter[nodenum];\n    srand(SEED_MPI+myid);                       //Give rand() a seed value. Needs to be different on each node\n\n    if(myid != 0)\n    {\n        for (i=0; i&lt;niter; %f\\n\",=\"\" (myid=\"0)\" (z&lt;=\"1)\" +=\"recvniter[i];\" ++i)=\"\" 0;=\"\" &lt;=\"\" ```=\"\" a=\"\" calculated=\"\" checks=\"\" circle=\"\" close=\"\" cluster.=\"\" consider=\"\" coordinate=\"\" count++;=\"\" crossbar=\"\" div=\"\" else=\"\" explanations=\"\" finalcount=\"\" finalniter=\"\" for(i=\"0;\" gets=\"\" i&lt;nodenum;=\"\" if=\"\" in=\"\" inside=\"\" instance=\"\" int=\"\" is,=\"\" it=\"\" long=\"\" loop=\"\" main=\"\" master=\"\" mpi=\"\" mpi_finalize();=\"\" mpi_recv(&amp;recieved[i],nodenum,mpi_int,mpi_any_source,1,mpi_comm_world,mpi_status_ignore);=\"\" mpi_recv(&amp;recvniter[i],nodenum,mpi_long,mpi_any_source,2,mpi_comm_world,mpi_status_ignore);=\"\" mpi_send(&amp;count,1,mpi_int,0,1,mpi_comm_world);=\"\" mpi_send(&amp;niter,1,mpi_long,0,2,mpi_comm_world);=\"\" number=\"\" of=\"\" on=\"\" p=\"4(m/n)\" pi=\"\" pi);=\"\" point=\"\" print=\"\" printf(\"pi:=\"\" process=\"\" program=\"\" random=\"\" return=\"\" see=\"\" simulate=\"\" text.=\"\" the=\"\" this=\"\" to=\"\" unit=\"\" valid=\"\" value=\"\" we=\"\" will=\"\" x=\"\" y=\"\" z=\"sqrt(x*x+y*y);\" {=\"\" }=\"\"&gt;\n&lt;div class=\"output_wrapper\" markdown=\"1\"&gt;\n&lt;div class=\"output\" markdown=\"1\"&gt;\n&lt;div class=\"output_area\" markdown=\"1\"&gt;\n&lt;div class=\"output_subarea output_stream output_stdout output_text\"&gt;\n&lt;pre&gt;\n&lt;code&gt;Overwriting pi_send_receive.c\n&lt;/code&gt;\n&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/niter;&gt;&lt;/math.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;&lt;/div&gt;\n&lt;div class=\"cell border-box-sizing text_cell rendered\" markdown=\"1\"&gt;\n&lt;div class=\"inner_cell\" markdown=\"1\"&gt;\n&lt;div class=\"text_cell_render border-box-sizing rendered_html\" markdown=\"1\"&gt;\nObserve que, nesta solu\u00e7\u00e3o, cada escravo est\u00e1 enviando um n\u00famero de mensagens igual ao n\u00famero de n\u00f3s do cluster. Isto \u00e9 necess\u00e1rio porque vamos simular a execu\u00e7\u00e3o numa topologia de cluster do tipo crossbar:\n\nhttps://simgrid.github.io/SMPI_CourseWare/topic_getting_started/platforms/\n\nNesta arquitetura, cada n\u00f3 potencialmente pode ser um mestre e s\u00f3 vamos saber qual n\u00f3 \u00e9 o mestre no momento da execu\u00e7\u00e3o. Se us\u00e1ssemos uma topologia do tipo estrela, com o mestre j\u00e1 conhecido, bastariam somente 2 mensagens de cada escravo.\n\nObserve, tamb\u00e9m, que o mestre indica que pode receber mensagens de qualquer processo remoto pelo uso do par\u00e2metro MPI_ANY_SOURCE.\n\nAgora, vamos compilar e executar este programa no nosso cluster crossbar:\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"cell border-box-sizing code_cell rendered\" markdown=\"1\"&gt;\n&lt;div class=\"input\"&gt;\n\n```python\n!smpicc pi_send_receive.c -o pi_send_receive -lm\n</code></pre> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./pi_send_receive\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nPi: 3.142268\n</code>\n</pre> <p>Observe que todas as comunica\u00e7\u00f5es acima s\u00e3o do tipo ponto-a-ponto: cada processo-escravo envia mensagens diretamente para o nodo de rank 0 (mestre), informando a contagem de pontos que ca\u00edram dentro do quarto de c\u00edrculo e o n\u00famero de intera\u00e7\u00f5es realizado. O mestre, ent\u00e3o, recebe as mensagens de todos os escravos e sumariza os resultados. Neste caso, dizemos que o mestre reduziu os dados coletados dos escravos. </p> <p>O trecho de c\u00f3digo abaixo mostra como aplicar MPI_REDUCE para calcular uma m\u00e9dia de valores produzidos por processos-escravos:</p> <pre><code>%%writefile avg.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;time.h&gt;\n\n// Creates an array of random numbers. Each number has a value from 0 - 1\nfloat *create_rand_nums(int num_elements) {\n  float *rand_nums = (float *)malloc(sizeof(float) * num_elements);\n  assert(rand_nums != NULL);\n  int i;\n  for (i = 0; i &amp;lt; num_elements; i++) {\n    rand_nums[i] = (rand() / (float)RAND_MAX);\n  }\n  return rand_nums;\n}\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: avg num_elements_per_proc\\n\");\n    exit(1);\n  }\n\n  int num_elements_per_proc = atoi(argv[1]);\n\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;world_size);\n\n  // Create a random array of elements on all processes.\n  srand(time(NULL)*world_rank);   // Seed the random number generator to get different results each time for each processor\n  float *rand_nums = NULL;\n  rand_nums = create_rand_nums(num_elements_per_proc);\n\n  // Sum the numbers locally\n  float local_sum = 0;\n  int i;\n  for (i = 0; i &amp;lt; num_elements_per_proc; i++) {\n    local_sum += rand_nums[i];\n  }\n\n  // Print the random numbers on each process\n  printf(\"Local sum for process %d - %f, avg = %f\\n\",\n         world_rank, local_sum, local_sum / num_elements_per_proc);\n\n  // Reduce all of the local sums into the global sum\n  float global_sum;\n  MPI_Reduce(&amp;amp;local_sum, &amp;amp;global_sum, 1, MPI_FLOAT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // Print the result\n  if (world_rank == 0) {\n    printf(\"Total sum = %f, avg = %f\\n\", global_sum,\n           global_sum / (world_size * num_elements_per_proc));\n  }\n\n  // Clean up\n  free(rand_nums);\n\n  MPI_Barrier(MPI_COMM_WORLD);\n  MPI_Finalize();\n}\n</code></pre> <pre>\n<code>Writing avg.c\n</code>\n</pre> <p>EXERC\u00cdCIO 1</p> <p>Compile e teste o programa acima. </p> <pre><code>!smpicc avg.c -o avg -lm\n</code></pre> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./avg 100\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nLocal sum for process 0 - 54.682476, avg = 0.546825\nLocal sum for process 1 - 53.733265, avg = 0.537333\nLocal sum for process 2 - 50.004021, avg = 0.500040\nLocal sum for process 3 - 48.533802, avg = 0.485338\nLocal sum for process 4 - 53.392612, avg = 0.533926\nLocal sum for process 5 - 52.567123, avg = 0.525671\nLocal sum for process 6 - 46.119843, avg = 0.461198\nLocal sum for process 7 - 46.484497, avg = 0.464845\nLocal sum for process 8 - 51.973499, avg = 0.519735\nLocal sum for process 9 - 50.640781, avg = 0.506408\nLocal sum for process 10 - 46.569996, avg = 0.465700\nLocal sum for process 11 - 57.496677, avg = 0.574967\nLocal sum for process 12 - 52.161461, avg = 0.521615\nLocal sum for process 13 - 48.333683, avg = 0.483337\nLocal sum for process 14 - 46.418041, avg = 0.464180\nLocal sum for process 15 - 54.174198, avg = 0.541742\nTotal sum = 813.286011, avg = 0.508304\n</code>\n</pre> <p>Muitos aplicativos paralelos exigir\u00e3o o acesso aos resultados reduzidos em todos os processos, em vez do processo-mestre. MPI_Allreduce \u00e9 uma primitiva de comunica\u00e7\u00e3o MPI que reduzir\u00e1 os valores e distribuir\u00e1 os resultados para todos os processos. O prot\u00f3tipo da fun\u00e7\u00e3o \u00e9 o seguinte:</p> <p>MPI_Allreduce(     void* send_data,     void* recv_data,     int count,     MPI_Datatype datatype,     MPI_Op op,     MPI_Comm communicator)</p> <p>Como voc\u00ea deve ter notado, MPI_Allreduce \u00e9 id\u00eantico a MPI_Reduce com a exce\u00e7\u00e3o de que n\u00e3o precisa de um ID de processo raiz (j\u00e1 que os resultados s\u00e3o distribu\u00eddos para todos os processos). A pr\u00f3xima imagem ilustra o padr\u00e3o de comunica\u00e7\u00e3o de MPI_Allreduce:</p> <p></p> <p>Muitos problemas computacionais requerem redu\u00e7\u00f5es m\u00faltiplas para resolver problemas. Um desses problemas \u00e9 encontrar o desvio padr\u00e3o de um conjunto distribu\u00eddo de n\u00fameros. Para aqueles que podem ter esquecido, o desvio padr\u00e3o \u00e9 uma medida da dispers\u00e3o dos n\u00fameros de sua m\u00e9dia. Um desvio padr\u00e3o mais baixo significa que os n\u00fameros est\u00e3o mais pr\u00f3ximos e vice-versa para desvios padr\u00e3o mais altos.</p> <p>Para encontrar o desvio padr\u00e3o, deve-se primeiro calcular a m\u00e9dia de todos os n\u00fameros. Depois que a m\u00e9dia \u00e9 calculada, as somas da diferen\u00e7a quadrada da m\u00e9dia s\u00e3o calculadas. A raiz quadrada da m\u00e9dia das somas \u00e9 o resultado final. Dada a descri\u00e7\u00e3o do problema, sabemos que haver\u00e1 pelo menos duas somas de todos os n\u00fameros, traduzindo-se em duas redu\u00e7\u00f5es.</p> <p>O c\u00f3digo para fazer isto encontra-se abaixo:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;math.h&gt;\n#include &lt;assert.h&gt;\n\n// Creates an array of random numbers. Each number has a value from 0 - 1\n\nfloat *create_rand_nums(int num_elements) {\n  float *rand_nums = (float *)malloc(sizeof(float) * num_elements);\n  assert(rand_nums != NULL);\n  int i;\n  for (i = 0; i &amp;lt; num_elements; i++) {\n    rand_nums[i] = (rand() / (float)RAND_MAX);\n  }\n  return rand_nums;\n}\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: avg num_elements_per_proc\\n\");\n    exit(1);\n  }\n\n  int num_elements_per_proc = atoi(argv[1]);\n\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;world_size);\n\n  // Create a random array of elements on all processes.\n  srand(time(NULL)*world_rank); // Seed the random number generator of processes uniquely\n  float *rand_nums = NULL;\n  rand_nums = create_rand_nums(num_elements_per_proc);\n\n  // Sum the numbers locally\n  float local_sum = 0;\n  int i;\n  for (i = 0; i &amp;lt; num_elements_per_proc; i++) {\n    local_sum += rand_nums[i];\n  }\n\n  // Reduce all of the local sums into the global sum in order to\n  // calculate the mean\n  float global_sum;\n  MPI_Allreduce(&amp;amp;local_sum, &amp;amp;global_sum, 1, MPI_FLOAT, MPI_SUM,\n                MPI_COMM_WORLD);\n  float mean = global_sum / (num_elements_per_proc * world_size);\n\n  // Compute the local sum of the squared differences from the mean\n  float local_sq_diff = 0;\n  for (i = 0; i &amp;lt; num_elements_per_proc; i++) {\n    local_sq_diff += (rand_nums[i] - mean) * (rand_nums[i] - mean);\n  }\n\n  // Reduce the global sum of the squared differences to the root process\n  // and print off the answer\n  float global_sq_diff;\n  MPI_Reduce(&amp;amp;local_sq_diff, &amp;amp;global_sq_diff, 1, MPI_FLOAT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // The standard deviation is the square root of the mean of the squared\n  // differences.\n  if (world_rank == 0) {\n    float stddev = sqrt(global_sq_diff /\n                        (num_elements_per_proc * world_size));\n    printf(\"Mean - %f, Standard deviation = %f\\n\", mean, stddev);\n  }\n\n  // Clean up\n  free(rand_nums);\n\n  MPI_Barrier(MPI_COMM_WORLD);\n  MPI_Finalize();\n}\n</code></pre> <p>EXERC\u00cdCIO 2</p> <p>Compile e teste o programa acima. </p> <pre><code>#IMPLEMENTE SEU C\u00d3DIGO AQUI\n</code></pre> <p>EXERC\u00cdCIO 3</p> <p>Refatore o c\u00f3digo pi_send_receive.c para utilizar a primitiva MPI_Reduce ao inv\u00e9s de MPI_Send e MPI_Recv.</p> <pre><code>#IMPLEMENTE SEU C\u00d3DIGO AQUI\n</code></pre> <p>EXERC\u00cdCIO 4</p> <p>Refatore o c\u00f3digo anterior produzindo um c\u00f3digo paralelo h\u00edbrido:</p> <ul> <li>O nodo-mestre calcular\u00e1 o n\u00fameros de pontos via OpenMP com 16 threads</li> <li>Os resultados dos nodos-escravos ser\u00e3o coletados via MPI_Reduce e reduzidos no nodo-mestre.</li> </ul> <pre><code>#IMPLEMENTE SEU C\u00d3DIGO AQUI\n</code></pre>"},{"location":"aulas/MPI-REDUCE/MPI_AULA2/#message-passing-interface-aula-2","title":"MESSAGE PASSING INTERFACE (AULA 2)","text":""},{"location":"aulas/MPI-REDUCE/MPI_AULA2/#reducao-distribuida-de-processamento","title":"REDU\u00c7\u00c3O DISTRIBU\u00cdDA DE PROCESSAMENTO","text":"<p>Inicialmente, vamos reinstalar o simgrid e fazer o download do modelos de clusters:</p>"},{"location":"aulas/MPI-REDUCE/MPI_AULA2/#mpi_reduce-e-mpi_allreduce","title":"MPI_REDUCE e MPI_ALLREDUCE","text":"<p>MPI_Reduce \u00e9 uma primitiva de comunica\u00e7\u00e3o MPI que coleta valores calculados por cada processo-escravo e os repassa para o processo-mestre para que possam ser reduzidos. A sintaxe de MPI_Reduce \u00e9 mostrada abaixo:</p> <p>MPI_Reduce(     void* send_data,     void* recv_data,     int count,     MPI_Datatype datatype,     MPI_Op op,     int root,     MPI_Comm communicator)</p> <p>O par\u00e2metro send_data \u00e9 um array de elementos do tipo datatype que cada processo deseja reduzir. O recv_data s\u00f3 \u00e9 relevante no processo com rank root. A matriz recv_data cont\u00e9m o resultado reduzido e tem um tamanho de sizeof(datatype) * count. O par\u00e2metro op \u00e9 a opera\u00e7\u00e3o que voc\u00ea deseja aplicar aos seus dados. O MPI cont\u00e9m um conjunto de opera\u00e7\u00f5es de redu\u00e7\u00e3o comuns que podem ser usadas. Embora as opera\u00e7\u00f5es de redu\u00e7\u00e3o personalizadas possam ser definidas, isso est\u00e1 al\u00e9m do escopo desta aula. As opera\u00e7\u00f5es de redu\u00e7\u00e3o definidas pela MPI incluem:</p> <ul> <li>MPI_MAX - Retorna o elemento m\u00e1ximo.</li> <li>MPI_MIN - Retorna o elemento m\u00ednimo.</li> <li>MPI_SUM - Soma os elementos.</li> <li>MPI_PROD - Multiplica todos os elementos.</li> <li>MPI_LAND - AND l\u00f3gico entre os elementos.</li> <li>MPI_LOR - OR l\u00f3gico entre os elementos.</li> <li>MPI_BAND - AND bit-a-bit dos elementos.</li> <li>MPI_BOR - OR bit-a-bit dos elementos.</li> <li>MPI_MAXLOC - Retorna o valor m\u00e1ximo e o rank do processo que o possui.</li> <li>MPI_MINLOC - Retorna o valor m\u00ednimo e o rank do processo que o possui.</li> </ul> <p>Abaixo est\u00e1 uma ilustra\u00e7\u00e3o do padr\u00e3o de comunica\u00e7\u00e3o do MPI_Reduce para o operador de soma:</p> <p></p> <p>Tamb\u00e9m \u00e9 \u00fatil ver o que acontece quando os processos cont\u00eam v\u00e1rios elementos. A ilustra\u00e7\u00e3o abaixo mostra a redu\u00e7\u00e3o de v\u00e1rios n\u00fameros por processo:</p> <p></p> <p>Cada um dos processos da ilustra\u00e7\u00e3o acima tem dois elementos. A soma resultante ocorre por elemento. Em outras palavras, em vez de somar todos os elementos de todas as matrizes em um \u00fanico elemento, o i-\u00e9simo elemento de cada matriz \u00e9 somado ao i-\u00e9simo elemento na matriz de resultados do processo 0.</p>"},{"location":"aulas/efeitos-colaterais-II/","title":"Efeitos colaterais II","text":"<p>Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o <code>pi</code>. Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlo. Um bom v\u00eddeo para compreender essa t\u00e9cnica, est\u00e1 dispon\u00edvel aqui.</p> <p>O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado <code>2</code>. Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi. Veja abaixo um resumo do algoritmo.</p> <p></p> <ol> <li><code>sum = 0</code></li> <li>De <code>i=0</code> at\u00e9 <code>N</code>:<ol> <li>sorteie pontos x,y \\in [0,1]</li> <li>se x^2 + y^2 \\leq 1, <code>sum += 1</code></li> </ol> </li> <li>devolva <code>4 * sum / N</code></li> </ol> <p>Example</p> <p>Fa\u00e7a uma implementa\u00e7\u00e3o sequencial desse algoritmo. Chama seu programa de <code>pi_montecarlo.cpp</code>. Para fins de debug das pr\u00f3ximas vers\u00f5es, mostre o valor de <code>sum</code> na sa\u00edda de erros. Adote <code>N=100 000</code>.</p>"},{"location":"aulas/efeitos-colaterais-II/#e-possivel-paralelizar-o-problema","title":"\u00c9 poss\u00edvel paralelizar o problema?","text":"<p>Vamos iniciar pensando um pouco sobre o problema acima.</p> <p>Question</p> <p>O algoritmo acima \u00e9 paraleliz\u00e1vel? Qual t\u00e9cnica voc\u00ea utilizaria para paraleliz\u00e1-lo?</p> <p>Resposta</p> <p>O <code>for</code> paralelo parece encaixar muito bem neste problema, com a vari\u00e1vel <code>sum</code> sendo usada na op\u00e7\u00e3o <code>reduction</code></p> <p>Question</p> <p>Al\u00e9m da vari\u00e1vel <code>sum</code>, existe outra opera\u00e7\u00e3o que gera efeitos colaterais no c\u00f3digo acima? Qual?</p> <p>Resposta</p> <p>O sorteio de pontos! Lembramos da aula 06 que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial que depende dos n\u00fameros anteriormente sorteados.</p> <p>Progress</p> <p>Continuar</p> <p>Agora que sabemos que gerar n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial, vamos considerar o quanto isso atrapalha nosso programa. Nas pr\u00f3ximas quest\u00f5es leve em conta que o gerador de n\u00fameros aleat\u00f3rios \u00e9 uma vari\u00e1vel compartilhada.</p> <p>Question</p> <p>Como evitar\u00edamos problemas ao compartilhar o gerador de n\u00fameros aleat\u00f3rios?</p> <p>Resposta</p> <p>Podemos envolver o passo 2a do algoritmo em uma se\u00e7\u00e3o cr\u00edtica usando <code>omp critical</code></p> <p>Question</p> <p>Se o <code>for</code> acima rodar em uma ordem completamente diferente os resultados se alterar\u00e3o?</p> <p>Resposta</p> <p>Desde de que os pares <code>x,y</code> sorteados sejam os mesmos ent\u00e3o n\u00e3o haver\u00e1 problema.</p> <p>Example</p> <p>Com base em todas as suas respostas dos exerc\u00edcios anteriores, fa\u00e7a uma implementa\u00e7\u00e3o paralela do <code>pi_montecarlo.cpp</code>. Verifique que o valor de <code>sum</code> \u00e9 igual ao sequencial. Por enquanto, n\u00e3o se preocupe com o tempo de execu\u00e7\u00e3o.</p> <p>Question</p> <p>Anote o tempo de execu\u00e7\u00e3o sequencial e paralelo para o programa acima.</p> <p>Progress</p> <p>Vamos discutir esse resultado juntos!</p>"},{"location":"aulas/efeitos-colaterais-II/#paralelizando-processos-inerentemente-sequenciais","title":"Paralelizando processos inerentemente sequenciais","text":"<p>Como discutimos agora h\u00e1 pouco, a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo inerentemente sequencial. N\u00e3o \u00e9 que seja imposs\u00edvel paraleliz\u00e1-lo eficientemente, \u00e9 que \u00e9 imposs\u00edvel paraleliz\u00e1-lo at all. Vamos tentar contornar isso ent\u00e3o usando a resposta da Quest\u00e3o 4:</p> <p>O <code>for</code> do algoritmo depende dos pontos gerados, n\u00e3o da ordem que eles foram gerados.</p> <p>Vamos ent\u00e3o adotar uma solu\u00e7\u00e3o simples: a cada itera\u00e7\u00e3o do <code>for</code> criamos um novo gerador de n\u00fameros aleat\u00f3rios e sorteamos um par de pontos dele.</p>"},{"location":"aulas/efeitos-colaterais-II/#primeira-tentativa","title":"Primeira tentativa","text":"<p>Question</p> <p>Sabemos que um gerador de n\u00fameros aleat\u00f3rios gera sempre a mesma sequ\u00eancia de n\u00fameros, dado um par\u00e2metro <code>seed</code> fixo. O qu\u00ea acontece se usarmos o mesmo <code>seed</code> em todas as itera\u00e7\u00f5es? Como consertar isso?</p> <p>Resposta</p> <p>Sortearemos o mesmo ponto em todas as itera\u00e7\u00f5es. Para consertar isso podemos fazer o <code>seed</code> ser baseado no <code>i</code> da itera\u00e7\u00e3o atual.</p> <p>Example</p> <p>Crie uma implementa\u00e7\u00e3o baseada na ideia acima.</p> <p>Question</p> <p>Anote abaixo o valor do pi encontrado e o tempo de execu\u00e7\u00e3o.</p> <p>Question</p> <p>Os resultados obtidos s\u00e3o id\u00eanticos aos do programa original? S\u00e3o pr\u00f3ximos?</p> <p>Progress</p> <p>Vamos discutir esse resultado.</p>"},{"location":"aulas/efeitos-colaterais-II/#segunda-tentativa","title":"Segunda tentativa","text":"<p>O problema da nossa tentativa anterior \u00e9 que n\u00e3o temos de verdade sequ\u00eancias de pontos aleat\u00f3rias. Bom, na verdade nunca temos, mas o problema \u00e9 que violamos a promessa que o <code>RNG</code> faz. Ele promete que</p> <p>dado um seed fixo, a sequ\u00eancia de n\u00fameros geradas \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria de verdade</p> <p>Ele n\u00e3o promete que, se criarmos v\u00e1rios <code>RNG</code>s, a sequ\u00eancia formada pelo primeiro par de n\u00fameros gerados por cada um ser\u00e1 aleat\u00f3ria.</p> <p>Vamos agora tentar uma nova ideia:</p> <p>Cada thread ir\u00e1 gerar <code>N/NUM_THREADS</code> n\u00fameros aleat\u00f3rios, atualizando <code>sum</code> com os pontos dentro do semi-c\u00edrculo.</p> <p>Question</p> <p>Como esta ideia melhora o algoritmo acima?</p> <p>Resposta</p> <p>Agora teremos <code>NUM_THREADS</code> sequ\u00eancias pseudo-aleat\u00f3rias \"v\u00e1lidas\" e junt\u00e1-las passa a ser um problema menor. Continuamos precisando usar uma <code>seed</code> para cada, mas ao menos agora temos um n\u00famero pequeno de <code>RNG</code>s.</p> <p>Example</p> <p>Fa\u00e7a uma implementa\u00e7\u00e3o da ideia acima. Voc\u00ea pode usar os comandos do OpenMP que quiser. </p> <p>Question</p> <p>Anote o tempo de execu\u00e7\u00e3o e o pi encontrado.</p>"},{"location":"aulas/pi/","title":"Pi pelo m\u00e9todo de Monte Carlo","text":"<p>Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o pi. Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlo. Um bom v\u00eddeo para compreender essa t\u00e9cnica, est\u00e1 dispon\u00edvel aqui.</p> <p></p> <p>O m\u00e9todo consiste em sorteios aleat\u00f3rios de pontos em um quadrado, que a propor\u00e7\u00e3o de pontos que caem dentro de um c\u00edrculo inscrito nesse quadrado \u00e9 usada para aproximar o valor de pi. </p>  \\pi \\approx 4 \\times \\frac{\\text{n\u00famero de pontos dentro do c\u00edrculo}}{\\text{n\u00famero total de pontos}}"},{"location":"aulas/pi/#parte-1-implementacao-sequencial","title":"Parte 1: Implementa\u00e7\u00e3o Sequencial","text":"<p>Implemente a vers\u00e3o sequencial do algoritmo de Monte Carlo. Escreva um c\u00f3digo C++ que gera N = 100000 pontos aleat\u00f3rios, calcule quantos caem dentro do c\u00edrculo, e estime o valor de pi. </p> <p>Ap\u00f3s implementar, execute o programa e anote os resultados. No seu relat\u00f3rio, inclua:</p> <ul> <li> <p>O valor de pi estimado.</p> </li> <li> <p>O tempo de execu\u00e7\u00e3o. </p> </li> </ul> <p>Reflex\u00e3o: No relat\u00f3rio, reflita sobre a implementa\u00e7\u00e3o. A sequ\u00eancia de n\u00fameros aleat\u00f3rios foi gerada corretamente? Houve alguma dificuldade na implementa\u00e7\u00e3o?</p>"},{"location":"aulas/pi/#parte-2-primeira-tentativa-de-paralelizacao","title":"Parte 2: Primeira Tentativa de Paraleliza\u00e7\u00e3o","text":"<p>Agora que voc\u00ea tem a vers\u00e3o sequencial, tente paralelizar o algoritmo. Use a t\u00e9cnica de <code>for</code> paralelo para distribuir o sorteio de pontos entre v\u00e1rias threads. A paraleliza\u00e7\u00e3o, neste caso, deve focar em garantir que v\u00e1rias threads possam trabalhar simultaneamente no sorteio dos pontos, enquanto a vari\u00e1vel <code>sum</code> (n\u00famero de pontos dentro do c\u00edrculo) \u00e9 tratada com uma opera\u00e7\u00e3o de redu\u00e7\u00e3o para evitar conflitos entre threads.</p> <p>Reflex\u00e3o: Discuta no relat\u00f3rio por que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios pode ser um obst\u00e1culo em um ambiente paralelo? Como voc\u00ea resolveu esse problema? A sua solu\u00e7\u00e3o impactou o desempenho do c\u00f3digo?</p> <p>Depois de paralelizar o c\u00f3digo, rode e compare com a vers\u00e3o sequencial. No seu relat\u00f3rio, inclua:</p> <ul> <li> <p>O valor de pi estimado pela vers\u00e3o paralela.</p> </li> <li> <p>O tempo de execu\u00e7\u00e3o da vers\u00e3o paralela.</p> </li> </ul>"},{"location":"aulas/pi/#parte-3-melhorando-a-paralelizacao","title":"Parte 3: Melhorando a Paraleliza\u00e7\u00e3o","text":"<p>Agora, vamos melhorar a paraleliza\u00e7\u00e3o abordando o problema da gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios de uma forma mais eficiente. Em vez de usar <code>omp critical</code> para proteger o sorteio de n\u00fameros aleat\u00f3rios (o que pode ser lento), voc\u00ea pode dar a cada thread o seu pr\u00f3prio gerador de n\u00fameros aleat\u00f3rios.</p> <p>Para isso, baseie o seed de cada gerador de n\u00fameros no \u00edndice da itera\u00e7\u00e3o ou em outra vari\u00e1vel \u00fanica para cada thread. Isso evita que os n\u00fameros sorteados sejam repetidos.</p> <p>Reflex\u00e3o: No relat\u00f3rio, discuta os efeitos dessa mudan\u00e7a. A gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios foi paralelizada de maneira eficaz? O valor de pi mudou de forma significativa? Houve melhoria no tempo de execu\u00e7\u00e3o? Registre suas observa\u00e7\u00f5es.</p> <p>Depois de executar essa nova vers\u00e3o do algoritmo, inclua no seu relat\u00f3rio:</p> <ul> <li> <p>O valor de pi estimado com essa melhoria.</p> </li> <li> <p>O tempo de execu\u00e7\u00e3o da nova vers\u00e3o paralela.</p> </li> </ul>"},{"location":"aulas/pi/#conclusao-e-comparacao","title":"Conclus\u00e3o e Compara\u00e7\u00e3o","text":"<p>No final do seu relat\u00f3rio, inclua uma tabela comparando o valor de pi e o tempo de execu\u00e7\u00e3o de cada vers\u00e3o (sequencial, primeira tentativa paralela, e segunda tentativa paralela). Depois, resposta as perguntas a seguir: </p> <pre><code>1.  Houve uma melhoria significativa no tempo de execu\u00e7\u00e3o entre a vers\u00e3o sequencial e as vers\u00f5es paralelas?\n\n2.  A estimativa de pi permaneceu precisa em todas as vers\u00f5es?\n\n3.  Quais foram os maiores desafios ao paralelizar o algoritmo, especialmente em rela\u00e7\u00e3o aos n\u00fameros aleat\u00f3rios?\n\n4.  O uso de threads trouxe benef\u00edcios claros para este problema espec\u00edfico?\n</code></pre> <p>Fa\u00e7a a subimiss\u00e3o do seu relat\u00f3rio  at\u00e9 as 23h59 de 28/04 </p>"},{"location":"projetos/","title":"Projeto da disciplina","text":"<p>O projeto da nossa disciplina est\u00e1 dispon\u00edvel nesse link</p>"},{"location":"projetos/exaustiva/","title":"Busca Exaustiva para Alinhamento de Sequencias","text":"<p>A busca exaustiva, conforme vista aula, gera todas as solu\u00e7\u00f5es vi\u00e1veis para um problema e, de acordo com um crit\u00e9rio de otimalidade, elege uma solu\u00e7\u00e3o \u00f3tima para o problema. Especificamente para o problema de alinhamento de sequencias, ele pode ser especificado da seguinte forma:</p> <pre><code>ALGORITMO BUSCA EXAUSTIVA\nEntrada: Duas sequencias de DNA a e b\n        Pesos wmat, wmis e wgap para match, mismatch e gap respectivamente\nSa\u00edda: Score de um alinhamento das sequencias\n      Subsequencias alinhadas\n\n1. Gerar todas as subsequencias a\u00b4 e b\u00b4 n\u00e3o-nulas de a e b, respectivamente.\n2. Calcular os alinhamentos de cada par de subsequencias (a\u00b4, b\u00b4) com os pesos wmat, wmis e wgap\n3. Devolver o score m\u00e1ximo m entre os scores do passo (2) e as subsequencias associadas a ele\n</code></pre> <p>Observe que, no passo (2), as subsequencias podem n\u00e3o ter o mesmo tamanho. Assim, n\u00e3o ser\u00e1 poss\u00edvel calcular diretamente um score simples. Podemos usar, por exemplo:</p> <ul> <li> a estrat\u00e9gia vista no primeiro projeto (Alinhamento Local de Smith-Waterman) para comparar duas subsequencias          <li> um truncamento da subsequencia maior pelo tamanho da subsequencia menor e calcular o score simples entre as duas subsequencias resultantes          <li> o Alinhamento Local de Smith-Waterman quando as subsequencias forem de tamanhos diferentes e, quando forem de tamanho igual, a estrat\u00e9gia aleat\u00f3ria do Projeto II.                    <p>A partir desta descri\u00e7\u00e3o, nosso terceiro projeto ter\u00e1 duas tarefas:</p> <ul> <li> Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo utilizando o algoritmo acima, assim como as subsequencias associadas a ele.    <li> Implementar duas estrat\u00e9gias diferentes para calcular os alinhamentos entre os pares de subsequencias do passo (2).  No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Como se trata de uma busca exaustiva, recomenda-se come\u00e7ar a testar com tamanhos pequenos e      ir aumentando gradativamente at\u00e9 atingir o tamanho m\u00e1ximo que a sua plataforma ainda consiga executar."},{"location":"projetos/gpu/","title":"Paralelismo com GPU","text":"<p>Esta etapa do projeto consiste em resolver nosso problema por meio da biblioteca Thrust. Vamos come\u00e7ar revendo a formaliza\u00e7\u00e3o de nosso problema:</p> <p>Entrada:</p> <p>Um inteiro N representando o n\u00famero de filmes dispon\u00edveis para assistir. Tr\u00eas vetores H, F e C de tamanho N, onde H[i] \u00e9 a hora de in\u00edcio, F[i] \u00e9 a hora de t\u00e9rmino e C[i] \u00e9 a categoria do i-\u00e9simo filme. Um inteiro M representando o n\u00famero de categorias. Um vetor L de tamanho M, onde L[j] \u00e9 o n\u00famero m\u00e1ximo de filmes que podem ser assistidos na categoria j.</p> <p>Sa\u00edda:</p> <p>Um inteiro representando o n\u00famero m\u00e1ximo de filmes que podem ser assistidos de acordo com as restri\u00e7\u00f5es de hor\u00e1rios e n\u00famero m\u00e1ximo por categoria.</p> <p>Para resolver esse problema utilizando a biblioteca thrust, podemos utilizar um algoritmo de programa\u00e7\u00e3o din\u00e2mica para construir a solu\u00e7\u00e3o de forma eficiente. O algoritmo consiste em criar uma matriz dp de tamanho (N+1) x (M+1) para armazenar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos at\u00e9 o filme i e a categoria j.</p> <p>Segue abaixo um pseudo-c\u00f3digo (incompleto) para resolver o problema</p> <pre><code>// Carregar os dados do arquivo de entrada na mem\u00f3ria da GPU\nthrust::device_vector&lt;int&gt; start_times(N);\nthrust::device_vector&lt;int&gt; end_times(N);\nthrust::device_vector&lt;int&gt; categories(N);\n\n// Ler os dados do arquivo de entrada\n// ...\n\n// Criar a matriz de programa\u00e7\u00e3o din\u00e2mica\nthrust::device_vector&lt;int&gt; dp((N+1) * (M+1), 0);\n\n// Inicializar a primeira linha da matriz com zeros\nthrust::fill(dp.begin(), dp.begin() + M + 1, 0);\n\n// Preencher a matriz com as solu\u00e7\u00f5es para subproblemas menores\nfor (int i = 1; i &lt;= N; i++) {\n  for (int j = 1; j &lt;= M; j++) {\n    // Encontrar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos at\u00e9 o filme i e categoria j\n    int max_count = 0;\n    for (int k = 0; k &lt; i; k++) {\n      if (categories[k] == j &amp;&amp; end_times[k] &lt;= start_times[i] &amp;&amp; dp[(k*(M+1)) + j-1] + 1 &lt;= L[j-1]) {\n        max_count = max(max_count, dp[(k*(M+1)) + j-1] + 1);\n      } else {\n        max_count = max(max_count, dp[(k*(M+1)) + j]);\n      }\n    }\n    dp[(i*(M+1)) + j] = max_count;\n  }\n}\n\n// Encontrar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos\nint max_count = 0;\nfor (int j = 1; j &lt;= M; j++) {\n  max_count = max(max_count, dp[(N*(M+1)) + j]);\n}\n\n// Escrever o resultado no arquivo de sa\u00edda\n// ...\n</code></pre> <p>A ideia do algoritmo \u00e9 criar uma matriz dp de tamanho (N+1) x (M+1) para armazenar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos at\u00e9 o filme i e a categoria j. O algoritmo preenche a matriz com as solu\u00e7\u00f5es para subproblemas menores, at\u00e9 chegar na solu\u00e7\u00e3o do problema original.</p> <p>Para cada c\u00e9lula (i,j) da matriz dp, o algoritmo verifica se \u00e9 poss\u00edvel adicionar o filme i \u00e0 categoria j, respeitando as restri\u00e7\u00f5es de hor\u00e1rio e limite m\u00e1ximo de filmes por categoria. Em seguida, o algoritmo verifica se \u00e9 melhor adicionar o filme i \u00e0 categoria j ou manter a solu\u00e7\u00e3o anterior sem o filme i. O n\u00famero m\u00e1ximo de filmes que podem ser assistidos \u00e9 o valor da c\u00e9lula (N, j) da matriz dp, onde j \u00e9 a categoria que maximiza o n\u00famero de filmes assistidos.</p> <p>Sua tarefa \u00e9 realizar essa implementa\u00e7\u00e3o em C++ com a Thrust e comparar o desempenho frente as demais implementa\u00e7\u00f5es. </p>"},{"location":"projetos/heuristico/","title":"Heur\u00edstica Gulosa","text":"<p>A primeira implementa\u00e7\u00e3o da heur\u00edstica para nosso projeto consiste em uma implementa\u00e7\u00e3o gulosa (Greedy).</p> <p>Implemente uma vers\u00e3o gulosa que ordena os filmes por hora de fim crescente e escolhe aqueles que come\u00e7am primeiro e n\u00e3o conflitam com os filmes j\u00e1 escolhidos, al\u00e9m de verificar se h\u00e1 vagas dispon\u00edveis na categoria do filme.</p>"},{"location":"projetos/local/","title":"Aleatoriedade","text":"<p>Como vimos em aula, aleatoriedade \u00e9 uma estrat\u00e9gia bastante comum para constru\u00e7\u00e3o de algoritmos de busca local, podendo ser usada de forma isolada ou de forma complementar a outra estrat\u00e9gia de varredura de um espa\u00e7o de solu\u00e7\u00f5es. </p> <p>Essa implementa\u00e7\u00e3o consiste na adapta\u00e7\u00e3o da heur\u00edstica gulosa de nosso projeto. A proposta \u00e9 que voc\u00ea modifique a sua heur\u00edstica gulosa de modo que ao longo da sele\u00e7\u00e3o de um filme voc\u00ea tenha 25% de chance de pegar outro filme qualquer que respeite o hor\u00e1rio. Isso far\u00e1 com que sua heur\u00edstica tenha um pouco mais de exploration e possamos ter alguns resultados melhores. </p> <p>Importante: \u00e9 essencial que voc\u00ea guarde todos os inputs usados ao longo do projeto, para que possa comparar o desempenho de seus algoritmos conforme mudamos a heur\u00edstica. Ou seja, todas as heur\u00edsticas devem ser submetidas aos mesmos arquivos de input. O seu resultado deve ser comparado sob duas perspectivas, no m\u00ednimo: (i) tempo de execu\u00e7\u00e3o em fun\u00e7\u00e3o do aumento de filmes e de categorias e (ii) tempo de tela (isto \u00e9, ser\u00e1 que estamos conseguindo ocupar bem as 24h do dia assitindo filmes?).</p>"},{"location":"projetos/openmp/","title":"Paralelismo com OpenMP","text":"<p>At\u00e9 agora experimentamos heur\u00edsticas que buscaram resolver o nosso problema em um tempo razo\u00e1vel, sem garantias de otimalidade. \u00c9 chegado o momento de incorporar o paralelismo de tarefas em nossas alternativas de resolu\u00e7\u00e3o.</p> <p>Para isso, voc\u00ea deve modificar a vers\u00e3o exaustiva de sua implementa\u00e7\u00e3o. Voc\u00ea pode fazer uso da diretiva <code>#pragma omp parallel for</code> para distribuir as itera\u00e7\u00f5es de um loop entre as threads dispon\u00edveis. Dentro do loop, voc\u00ea pode fazer a verifica\u00e7\u00e3o de cada filme e, caso ele esteja dentro das restri\u00e7\u00f5es de hor\u00e1rio e categoria, incrementar uma vari\u00e1vel compartilhada <code>count</code>. Observe que por ser uma vari\u00e1vel compartilhada, voc\u00ea precisa preservar essa regi\u00e3o cr\u00edtica entre as threads. </p> <p>Vale ressaltar que o uso do OpenMP n\u00e3o necessariamente ir\u00e1 garantir um desempenho melhor, pois a paraleliza\u00e7\u00e3o tem um overhead que pode acabar diminuindo a performance do programa em alguns casos. \u00c9 importante fazer testes para verificar se a utiliza\u00e7\u00e3o do OpenMP \u00e9 realmente ben\u00e9fica para o problema em quest\u00e3o.</p>"},{"location":"projetos/relatorio_parcial/","title":"Relat\u00f3rio Parcial","text":"<p>O relat\u00f3rio parcial \u00e9 a entrega intermedi\u00e1ria do projeto, a qual deve ser feita pelo blackboard at\u00e9 a data da prova intermedi\u00e1ria.</p> <p>Seu relat\u00f3rio dever\u00e1 conter as implementa\u00e7\u00f5es gulosa e aleat\u00f3ria. </p> <p>O que voc\u00ea dever\u00e1 fazer:</p> <ul> <li> <p>No blackboard, voc\u00ea deve fazer upload de todos os c\u00f3digos-fonte, arquivos de input, arquivos de output para cada heur\u00edtica. Caso opte por enviar um link do github com o reposit\u00f3rio completo, tamb\u00e9m poder\u00e1 faze-lo, desde que garanta que teremos acesso aos arquivos no seu reposit\u00f3rio;</p> </li> <li> <p>Voc\u00ea deve elaborar um relat\u00f3rio parcial contendo as seguintes se\u00e7\u00f5es:</p> <ul> <li> <p>Para cada heur\u00edstica voc\u00ea deve explicar como implementou a heur\u00edstica (detalhe como voc\u00ea tratou o input, qual a l\u00f3gica do seu output, quais invariantes existem em suas heur\u00edsticas), apresentar (i) o c\u00f3digo-fonte comentado, (ii) fazer considera\u00e7\u00f5es sobre o profiling (valgrind) do c\u00f3digo-fonte (use apenas 1 arquivo de input para isso, n\u00e3o h\u00e1 necessidade de fazer esse profiling para v\u00e1rios inputs), (iii) o resultado compartivo entre as heur\u00edsticas quando voc\u00ea varia o input (o input deve variar na quantidade de filmes e de categorias).</p> </li> <li> <p>Seu relat\u00f3rio deve ser gr\u00e1ficos e tabelas que subsidem as suas considera\u00e7\u00f5es</p> </li> <li> <p>\u00c9 permitido criar um programa em python ou outra linguagem que automatize a gera\u00e7\u00e3o de seus resultados, isto \u00e9, que execute seus c\u00f3digos C++ em fun\u00e7\u00e3o dos diferentes inputs.</p> </li> </ul> </li> </ul> <p>Preferencialmente o relat\u00f3rio deve ser apresentado em formato html. </p>"},{"location":"projetos/2021-2/","title":"Alinhamento de Sequencias de DNA","text":"<p>Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es.</p> <p>O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch). Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade:</p> <p></p> <p>Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch). Assim, teremos o seguinte n\u00edvel de similaridade:</p> <p>23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7</p> <p>Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma:</p> <pre><code>Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, \nencontrar o alinhamento que maximize o n\u00edvel de similaridade. \n</code></pre> <p>Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. </p> <p>Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros <code>n</code> e <code>m</code>, onde <code>n</code> \u00e9 o tamanho da primeira sequencia e, <code>m</code>, o tamanho da segunda. Assuma <code>n \u2264 200</code> e <code>m \u2264 200</code>. A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda.</p> <pre><code>5 7\nAT-CC\nTTTCCAA\n</code></pre> <p>A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade.</p> <p><pre><code>2\n</code></pre> Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes.</p> <pre><code>import random\nn = 10 # tamanho da primeira sequ\u00eancia\nm = 40 # tamanho da segunda sequ\u00eancia\nfile = 'dna.seq' # nome do arquivo a ser gerado\nf = open(file, 'w')\nseq=[str(n)+'\\n',\n     str(m)+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=n))+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=m))]\nf.writelines(seq)\nf.close()\nprint(''.join(seq))\n</code></pre> <p>Um poss\u00edvel output para este c\u00f3digo acima \u00e9:</p> <pre><code>10\n40\nTGGCGAT--C\nAGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A\n</code></pre>"},{"location":"projetos/2021-2/#estrategias-a-serem-estudadas-e-correcao-automatica","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica","text":"<p>Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior.</p> <ol> <li>Solu\u00e7\u00e3o Heur\u00edstica (18/03)</li> <li>Busca Local (01/04)</li> <li>Busca Exaustiva (15/04)</li> <li>Relat\u00f3rio Preliminar (29/04)</li> <li>Paralelismo Multicore (13/05)</li> <li>Paralelismo GPU (27/05)</li> <li>Relat\u00f3rio Final (03/06)</li> </ol>"},{"location":"projetos/2021-2/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.</p>"},{"location":"projetos/2021-2/#conceito-d","title":"Conceito D","text":"<p>Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final).</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2021-2/#conceito-c","title":"Conceito C","text":"<p>Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida.</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2021-2/#conceito-c_1","title":"Conceito C+","text":"<p>Al\u00e9m do j\u00e1 validado no conceito C, os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.</p>"},{"location":"projetos/2021-2/#conceitos-avancados","title":"Conceitos avan\u00e7ados","text":"<p>A partir do  conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.</p>"},{"location":"projetos/2021-2/busca-exaustiva/","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound","text":"<p>Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. </p> <p>Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. </p> <p>Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique. </p> <p></p>"},{"location":"projetos/2021-2/busca-local/","title":"Solu\u00e7\u00e3o Busca local","text":"<p>A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior.</p> <p>A solu\u00e7\u00e3o por busca local  tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness. Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos.</p> <p>Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto:</p> <ol> <li>Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover;</li> <li>Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. </li> <li>Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. </li> </ol> <p>Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada.  Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima.</p> <p>Para a entrega, usaremos o site codePost, voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.</p>"},{"location":"projetos/2021-2/heuristico/","title":"Solu\u00e7\u00e3o heur\u00edstica","text":"<p>Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes.</p> <p>Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos.</p> <p>Veja abaixo um pseudo-c\u00f3digo da estrat\u00e9gia gulosa que voc\u00ea deve implementar.</p> <p></p> <p>Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n &gt; 250).</p> <p>Voc\u00ea deve entregar, al\u00e9m de c\u00f3digo-fonte e todas as entradas e sa\u00eddas geradas para o seu programa, um arquivo contendo o resultado do programa <code>verify</code> ( que voc\u00ea implementou ) e comentar sobre o n\u00famero de vezes em que voc\u00ea conseguiu encontrar uma solu\u00e7\u00e3o para o problema. Comente tamb\u00e9m sobre o tempo de execu\u00e7\u00e3o de sua implementa\u00e7\u00e3o. </p> <p>Para a entrega, usaremos o site codePost, voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.</p>"},{"location":"projetos/2021-2/paralelismo-gpu/","title":"Paralelismo em GPU","text":"<p>Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local.</p>"},{"location":"projetos/2021-2/paralelismo-gpu/#compilacao-do-programa","title":"Compila\u00e7\u00e3o do programa","text":"<p>Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com <code>nvcc -O3</code>. </p> <p>Para a entrega, usaremos o site codePost.</p> <p>\u2192</p>"},{"location":"projetos/2021-2/paralelismo-multicore/","title":"Paralelismo multi-core","text":"<p>Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local.</p>"},{"location":"projetos/2021-2/paralelismo-multicore/#compilacao-do-programa","title":"Compila\u00e7\u00e3o do programa","text":"<p>Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com <code>-fopenmp</code> habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo.</p> <pre><code>#ifdef _OPENMP\n    // c\u00f3digo espec\u00edfico para multi-core aqui\n#else\n    // c\u00f3digo espec\u00edfico para sequencia aqui\n#endif\n</code></pre> <p>Para a entrega, usaremos o site codePost.</p>"},{"location":"projetos/2021-2/relatorio-1/","title":"Relat\u00f3rio - v1","text":"<p>Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o </p> <ul> <li>criar entradas de tamanho adequado para os prop\u00f3sitos dos testes</li> <li>estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o)</li> <li>comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas.</li> </ul> <p>Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01) ou usando a ferramenta pweave (recomendado). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link.</p> <p>Data de entrega: 31/10/2021, pelo blackboard.</p> <p></p>"},{"location":"projetos/2022-1/","title":"Alinhamento de Sequencias de DNA","text":"<p>Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es.</p> <p>O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch). Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade:</p> <p></p> <p>Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch). Assim, teremos o seguinte n\u00edvel de similaridade:</p> <p>23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7</p> <p>Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma:</p> <pre><code>Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, \nencontrar o alinhamento que maximize o n\u00edvel de similaridade. \n</code></pre> <p>Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. </p> <p>Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros <code>n</code> e <code>m</code>, onde <code>n</code> \u00e9 o tamanho da primeira sequencia e, <code>m</code>, o tamanho da segunda. Assuma <code>n \u2264 200</code> e <code>m \u2264 200</code>. A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda.</p> <pre><code>5 7\nAT-CC\nTTTCCAA\n</code></pre> <p>A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade.</p> <p><pre><code>2\n</code></pre> Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o notebook SequenceGenerator.ipynb para gerar inst\u00e2ncias aleat\u00f3rias para seus testes.</p>"},{"location":"projetos/2022-1/#estrategias-a-serem-estudadas-e-correcao-automatica","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica","text":"<p>Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior.</p> <ol> <li>Solu\u00e7\u00e3o Heur\u00edstica (18/03)</li> <li>Busca Local(01/04)</li> <li>Busca Exaustiva(15/04)</li> <li>Relat\u00f3rio Preliminar (29/04)</li> <li>Paralelismo Multicore (13/05)</li> <li>Paralelismo GPU (27/05)</li> <li>Relat\u00f3rio Final (03/06)</li> </ol>"},{"location":"projetos/2022-1/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.</p>"},{"location":"projetos/2022-1/#conceito-d","title":"Conceito D","text":"<p>Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final).</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2022-1/#conceito-c","title":"Conceito C","text":"<p>Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida.</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2022-1/#conceito-c_1","title":"Conceito C+","text":"<p>Al\u00e9m do j\u00e1 validado no conceito C, os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.</p>"},{"location":"projetos/2022-1/#conceitos-avancados","title":"Conceitos avan\u00e7ados","text":"<p>A partir do  conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.</p>"},{"location":"projetos/2022-1/SequenceGenerator/","title":"SequenceGenerator","text":"<p>GERADOR DE INST\u00c2NCIAS PARA COMPARA\u00c7\u00c3O DE SEQUENCIAS DE DNA</p> <p>Para usar este gerador, voc\u00ea deve fornecer tr\u00eas par\u00e2metros:</p> <p>n = tamanho da primeira sequencia </p> <p>m = tamanho da segunda inst\u00e2ncia </p> <p>file = nome do arquivo da inst\u00e2ncia a ser gerada</p> <pre><code>import random\nn = 10\nm = 40\nfile = 'dna.seq'\nf = open(file, 'w')\nseq=[str(n)+'\\n',\n     str(m)+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=n))+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=m))]\nf.writelines(seq)\nf.close()\nprint(''.join(seq))\n</code></pre> <pre>\n<code>10\n40\nTGGCGAT--C\nAGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A\n</code>\n</pre>"},{"location":"projetos/2022-1/heuristico/","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman","text":"<p>Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser:</p> <ol> <li>Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia</li> <li>Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores</li> <li>Escolha uma que produza o score m\u00e1ximo</li> </ol> <p>Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA.</p> <p>Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia:</p> <pre>\nALGORITMO SMITH-WATERMAN\nEntrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente\nSa\u00edda: score m\u00e1ximo de alinhamento \n\n1. Inicializar H[i,0]=0, 0\u2264i\u2264n\n2. Inicializar H[0,j]=0, 0\u2264j\u2264m\n3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m:\n4.     Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, \n                           w(a[i],b[j])= -1 se houve mismatch e  \n                           w(a[i],b[j])= -1 se houve gap\n5.     Calcular dele\u00e7\u00e3o  = H[i-1,j] - 1\n6.     Calcular inser\u00e7\u00e3o = H[i,j-1] - 1\n7.     Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o)\n9. Retornar o m\u00e1ximo de H[_,_]\n</pre> <p>Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. </p> <p>No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos:</p> <p>http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman</p> <p>Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA:</p> <p></p> <p>Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0).</p> <p>No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0),</p> <p>Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado.</p> <p>Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap):</p> <pre>\nSequ\u00eancia 1 = A-CACACTA\nSequ\u00eancia 2 = AGCACAC-A\n</pre> <p>A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas:</p> <ul> <li> Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct.   <li> a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias.  <p>No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python.</p> <p>Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf.</p>"},{"location":"projetos/2025-1/","title":"Minera\u00e7\u00e3o de criptomoedas","text":"<p>Este formul\u00e1rio tem como objetivo compreender melhor o seu n\u00edvel de aprendizagem neste momento do curso. As respostas nos ajudar\u00e3o a aprimorar as ferramentas e estrat\u00e9gias de ensino utilizadas na sua forma\u00e7\u00e3o.</p> <p> A minera\u00e7\u00e3o surgiu com o Bitcoin, criado por Satoshi Nakamoto em 2008. A proposta era descentralizar o controle do dinheiro, permitindo que qualquer pessoa pudesse participar da valida\u00e7\u00e3o das transa\u00e7\u00f5es em uma rede p\u00fablica.</p> <p>A valida\u00e7\u00e3o \u00e9 feita por meio de um algoritmo de consenso chamado Proof of Work (PoW). A PoW exige que os n\u00f3s da rede (os mineradores) resolvam um problema matem\u00e1tico dif\u00edcil \u2014 e quem resolve primeiro, tem o direito de adicionar um novo bloco \u00e0 blockchain e receber uma recompensa.</p> <p>Essa \u201cprova\u201d \u00e9 feita atrav\u00e9s de um processo chamado de hashing, e no caso do Bitcoin, utiliza o algoritmo SHA-256.</p>"},{"location":"projetos/2025-1/#o-que-e-sha-256","title":"O que \u00e9 SHA-256","text":"<p>SHA-256 \u00e9 parte da fam\u00edlia de fun\u00e7\u00f5es de hash SHA-2, desenvolvida pela Ag\u00eancia de Seguran\u00e7a Nacional dos Estados Unidos (NSA) em 2001. SHA significa Secure Hash Algorithm.</p>"},{"location":"projetos/2025-1/#caracteristicas-principais","title":"Caracter\u00edsticas principais:","text":"<ul> <li>Gera uma sa\u00edda de 256 bits (64 caracteres hexadecimais)</li> <li>\u00c9 uma fun\u00e7\u00e3o determin\u00edstica: mesma entrada, mesma sa\u00edda</li> <li>\u00c9 unidirecional: n\u00e3o d\u00e1 para \"voltar\" da sa\u00edda para a entrada</li> <li>Pequenas mudan\u00e7as na entrada resultam em mudan\u00e7as dr\u00e1sticas na sa\u00edda (efeito avalanche)</li> <li>Altamente sens\u00edvel \u00e0 colis\u00f5es (duas entradas diferentes que d\u00e3o a mesma sa\u00edda s\u00e3o indesej\u00e1veis)</li> </ul>"},{"location":"projetos/2025-1/#como-o-sha-256-funciona","title":"Como o SHA-256 funciona?","text":"<p>SHA-256 funciona em blocos de 512 bits de entrada, que passam por v\u00e1rias etapas:</p> <ol> <li>Pr\u00e9-processamento:</li> <li>Padding: a mensagem \u00e9 estendida at\u00e9 m\u00faltiplos de 512 bits.</li> <li>Parsing: a mensagem \u00e9 dividida em blocos de 512 bits.</li> <li> <p>Inicializa\u00e7\u00e3o: 8 vari\u00e1veis de 32 bits com constantes iniciais (derivadas da raiz quadrada dos primeiros 8 primos).</p> </li> <li> <p>Fun\u00e7\u00e3o de compress\u00e3o:</p> </li> <li>Cada bloco de 512 bits passa por 64 rodadas de opera\u00e7\u00f5es bit a bit (AND, OR, XOR, ROTR, etc).</li> <li>Usa uma tabela de 64 constantes (derivadas da raiz c\u00fabica dos primeiros 64 primos).</li> <li> <p>A cada rodada, as vari\u00e1veis s\u00e3o atualizadas com fun\u00e7\u00f5es n\u00e3o lineares.</p> </li> <li> <p>Concatena\u00e7\u00e3o final:</p> </li> <li>Ap\u00f3s todos os blocos processados, os 8 valores de 32 bits s\u00e3o concatenados e formam o hash final de 256 bits.</li> </ol>"},{"location":"projetos/2025-1/#mineracao-com-sha-256-o-que-acontece","title":"Minera\u00e7\u00e3o com SHA-256: o que acontece?","text":"<p>O minerador tenta encontrar um valor chamado nonce que, quando combinado com o cabe\u00e7alho do bloco e passado pelo SHA-256 duas vezes (double SHA-256), resulta em um hash menor que o alvo definido pela dificuldade da rede.</p> <p>Ou seja, o minerador est\u00e1 basicamente tentando encontrar um n\u00famero (nonce) que leve o hash a come\u00e7ar com N zeros.</p>"},{"location":"projetos/2025-1/#por-que-e-um-problema-de-hpc","title":"Por que \u00e9 um problema de HPC?","text":"<p>A minera\u00e7\u00e3o \u00e9 um problema de busca exaustiva. Os mineradores testam bilh\u00f5es de nonces por segundo. A performance da minera\u00e7\u00e3o depende da capacidade de realizar SHA-256 o mais r\u00e1pido poss\u00edvel.</p> <p>Por tr\u00e1s da id\u00e9ia de \"minerar bitcoins\", existe um problema computacional intensivo, cuja solu\u00e7\u00e3o depende de capacidade de processamento, efici\u00eancia do c\u00f3digo e uso inteligente dos recursos de hardware.</p> <p>Ent\u00e3o, o que a minera\u00e7\u00e3o tem a ver com HPC?</p> <p>Simples: a minera\u00e7\u00e3o de criptomoedas \u00e9 um problema cl\u00e1ssico de HPC moderno, por envolver:</p> <pre><code>Busca exaustiva de solu\u00e7\u00f5es (nonces)\n\nProcessamento paralelo de dados\n\nUso de algoritmos de hash otimizados (SHA-256)\n\nAproveitamento de CPU, GPU e clusters\n</code></pre> <p>para entender com mais detalhes como SHA-256 se relaciona com um sistema de criptomoedas, assista o v\u00eddeo. Vamos ao projeto...</p> <p>Acesse o seu reposit\u00f3rio do projeto via GitHub Classromm</p>"},{"location":"projetos/2025-1/#projeto-minerador-de-hashes","title":"Projeto - Minerador de Hashes","text":"<p>Este projeto \u00e9 um minerador de hashes em C++ que simula um processo de proof-of-work usado na minera\u00e7\u00e3o de criptomoedas. O c\u00f3digo permite a busca de um hash v\u00e1lida a partir de transa\u00e7\u00f5es lidas de arquivos e a tentativa de encontrar um nonce correto para gerar um hash que atenda a um crit\u00e9rio de dificuldade.</p> <p>No reposit\u00f3rio tem tr\u00eas implementa\u00e7\u00f5es prontas:</p> <ul> <li>Um minerador sequencial de transa\u00e7\u00f5es s\u00edncronas</li> <li>Um gerador de transa\u00e7\u00f5es s\u00edncronas, com 30 transa\u00e7\u00f5es fixas.</li> <li>Um gerador de transa\u00e7\u00f5es ass\u00edncronas, com quantidade e intervalo de transa\u00e7\u00f5es aleat\u00f3rios.</li> </ul>"},{"location":"projetos/2025-1/#para-executar-o-gerador-de-transacoes-sincronas","title":"Para executar o gerador de transa\u00e7\u00f5es s\u00edncronas:","text":"<p>Se voc\u00ea estiver em um ambiente HPC, carregue os m\u00f3dulos</p> <pre><code># Se estiver no SDumont\nmodule load gcc/12.4.0_sequana\n</code></pre> <p>Compile o c\u00f3digo e gere o bin\u00e1rio:</p> <pre><code> g++ sync_generator.cpp -o sync_generator -lssl -lcrypto\n</code></pre> <p>Execute o bin\u00e1rio:</p> <pre><code>./sync_generator\n</code></pre> <p>Voc\u00ea deve ter uma sa\u00edda parecida com essa:</p> <p></p> <p>O conte\u00fado de cada bloco \u00e9:</p> <pre><code>ID: tx_1\nTimestamp: 2025-03-28 11:24:55\nConte\u00fado: txcVfYs819MPNETO9zPS\nHash: 435a03ab073f14a6f80591affbfde6b98d1945de0749e633f1e2c9ff34f8b06d\n...\n...\n...\nID: tx_30\nTimestamp: 2025-03-28 11:24:55\nConte\u00fado: w5sNqOPnBNm4iwnQeXS3\nHash: c96958b686b92597528f3666e56963b62194a4bdaa2ecee3329f4f6c47fb577c\n</code></pre>"},{"location":"projetos/2025-1/#para-o-gerador-de-transacoes-assincronas-siga-o-mesmo-processo-com-o-codigo-async_generatorcpp","title":"Para o gerador de transa\u00e7\u00f5es ass\u00edncronas, siga o mesmo processo com o c\u00f3digo async_generator.cpp","text":""},{"location":"projetos/2025-1/#para-realizar-a-mineracao-sequencial","title":"Para realizar a minera\u00e7\u00e3o sequ\u00eancial","text":"<p>Garanta que os m\u00f3dulos est\u00e3o carregados:</p> <pre><code># Se estiver no SDumont\nmodule load gcc/12.4.0_sequana\n</code></pre> <p>Compile o c\u00f3digo e gere o bin\u00e1rio:</p> <pre><code>g++ miner_sync_seq.cpp -o miner_sync_seq -lssl -lcrypto\n</code></pre> <p>Execute o bin\u00e1rio via srun, o comando abaixo solicita ao slurm:</p> <ul> <li>1 CPU,</li> <li>1 tarefa por CPU,</li> <li>por 20 minutos (tempo m\u00e1ximo dispon\u00edvel na fila sequana_cpu_dev),</li> <li>salva o output em miner_seq_4_c\u00f3digo_do_job</li> <li>Executa o miner_seq com 4 zeros a esquerda</li> </ul> <pre><code>time srun   --partition=sequana_cpu_dev   --nodes=1   --ntasks-per-node=1   --time=00:20:00  --output=miner_seq_5_%j   .\n/miner_seq 4\n</code></pre> <p>Voc\u00ea deve ver algo parecido com:</p> <p></p> <p>E dentro do arquivo de output:</p> <p></p> <p>Se voc\u00ea der o comando no terminal do SDumont:</p> <pre><code>sacctmgr list user $USER -s format=partition%20,MaxJobs,MaxSubmit,MaxNodes,MaxCPUs,MaxWall\n</code></pre> <p>Ter\u00e1 acesso aos recursos habilitados para uso com o seu login:</p> <p></p>"},{"location":"projetos/2025-1/#criterios-de-avaliacao","title":"Crit\u00e9rios de Avalia\u00e7\u00e3o","text":""},{"location":"projetos/2025-1/#rubrica-d","title":"Rubrica D","text":"<ul> <li>Executa o c\u00f3digo minerador s\u00edncrono, no cluster Franky<ul> <li>Com dificuldade 5 zeros,  com pelo menos 5 gera\u00e7\u00f5es diferentes de sync_gen</li> </ul> </li> <li>Gera relat\u00f3rio com explica\u00e7\u00e3o, tempo de execu\u00e7\u00e3o e recursos SLURM utilizados</li> </ul>"},{"location":"projetos/2025-1/#rubrica-d_1","title":"Rubrica D+","text":"<ul> <li>Cumpre todos os requisitos da Rubrica D</li> <li>Com dificuldade 7 zeros , com pelo menos 5 gera\u00e7\u00f5es diferentes de sync_gen</li> <li>Gera relat\u00f3rio com explica\u00e7\u00e3o, tempo de execu\u00e7\u00e3o e recursos SLURM utilizados</li> </ul>"},{"location":"projetos/2025-1/#rubrica-c","title":"R\u00fabrica C","text":"<ul> <li>Executa o c\u00f3digo minerador ass\u00edncrono, no cluster SDumont</li> <li>Com dificuldade 5 zeros, com pelo menos 5 gera\u00e7\u00f5es diferentes de async_gen</li> <li>Gera relat\u00f3rio com explica\u00e7\u00e3o, tempos de execu\u00e7\u00e3o e recursos SLURM utilizados</li> </ul>"},{"location":"projetos/2025-1/#rubrica-b","title":"Rubrica B","text":"<ul> <li>Executa o c\u00f3digo minerador ass\u00edncrono, no cluster SDumont</li> <li>Com dificuldade 6 zeros, com pelo menos 5 gera\u00e7\u00f5es diferentes de async_gen</li> <li>Usa pelo pelo menos uma estrat\u00e9gia de otimiza\u00e7\u00e3o em CPU (MPI e OpenMP) no c\u00f3digo.</li> <li>Gera relat\u00f3rio com explica\u00e7\u00e3o, tempos de execu\u00e7\u00e3o e recursos SLURM utilizados</li> <li>Explica diferen\u00e7as de execu\u00e7\u00e3o, desempenho e configura\u00e7\u00f5es entre os ambientes</li> </ul>"},{"location":"projetos/2025-1/#rubrica-b_1","title":"Rubrica B+","text":"<ul> <li>Cumpre todos os requisitos da Rubrica B</li> <li>Usa as duas estrat\u00e9gias de otimiza\u00e7\u00e3o, MPI e OpenMP</li> </ul>"},{"location":"projetos/2025-1/#rubrica-a","title":"Rubrica A","text":"<ul> <li>Executa o c\u00f3digo minerador ass\u00edncrono, no cluster SDumont</li> <li>Com dificuldade 7 zeros, com pelo menos 5 gera\u00e7\u00f5es diferentes de async_gen</li> <li>Realiza a minera\u00e7\u00e3o em GPU.</li> <li>Gera relat\u00f3rio com explica\u00e7\u00e3o, tempos de execu\u00e7\u00e3o e recursos SLURM utilizados</li> <li>Explica diferen\u00e7as de execu\u00e7\u00e3o, desempenho e configura\u00e7\u00f5es entre os ambientes</li> </ul>"},{"location":"projetos/2025-1/#rubrica-a_1","title":"Rubrica A+","text":"<ul> <li>Cumpre todos os requisitos da Rubrica A</li> <li>Usa uma estrat\u00e9gia de otimiza\u00e7\u00e3o h\u00edbrida, partes do c\u00f3digo paralelizado em CPU, partes do c\u00f3digo em GPU.</li> <li>Apresenta an\u00e1lise comparativa completa entre as estrat\u00e9gias de otimiza\u00e7\u00e3o, ambientes e arquiteturas.</li> </ul>"},{"location":"projetos/2025-1/#entregaveis","title":"\ud83d\udccc Entreg\u00e1veis","text":"<p>GitHub-Classroom contendo:</p> <ul> <li>Implementa\u00e7\u00f5es</li> <li>Scripts SLURM utilizados</li> <li>Evid\u00eancias (prints, logs, etc..)</li> <li> <p>Relat\u00f3rio t\u00e9cnico contendo:</p> <ul> <li> <p>Explica\u00e7\u00e3o do funcionamento do c\u00f3digo</p> </li> <li> <p>Tempo de execu\u00e7\u00e3o</p> </li> <li> <p>Estrat\u00e9gias computacionais utilizadas (CPU/GPU, etc.)</p> </li> <li> <p>Discuss\u00e3o sobre os recursos solicitados via SLURM</p> </li> <li> <p>Compara\u00e7\u00e3o entre ambientes</p> </li> </ul> </li> </ul>"}]}