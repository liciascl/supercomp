{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SuperComputa\u00e7\u00e3o","text":"<p>Bem-vindo ao curso de SuperComputa\u00e7\u00e3o 2024/2!</p> <p>Essa p\u00e1gina cont\u00e9m os materiais de apoio para o curso de SuperComputa\u00e7\u00e3o do Insper.</p>"},{"location":"#horario-das-aulas","title":"Hor\u00e1rio das Aulas","text":"<p>Hor\u00e1rio das Aulas</p> <p>Turma 1 - Ter\u00e7a: 09h45 - Sexta: 13h30</p> <p>Turma 2 - Quarta: 13h30 - Sexta: 07h30</p>"},{"location":"#estrutura-do-curso","title":"Estrutura do Curso","text":"<p>O curso \u00e9 estruturado em tr\u00eas unidades principais, e um projeto:</p> <p>Estrutura do Curso</p> <ol> <li>Programando de forma eficiente computacionalmente</li> <li>Infraestrutura de HPC</li> <li>Programa\u00e7\u00e3o paralela e distribu\u00edda</li> <li>Projeto</li> </ol>"},{"location":"#material","title":"Material","text":"<p>Para alinhar o que esperamos de voc\u00ea, definimos um objetivo e uma entrega para cada aula. Voc\u00ea pode verificar os objetivos e as entregas para cada aula aqui</p>"},{"location":"#notas","title":"Notas","text":"<ul> <li> <p>A somat\u00f3ria de todas as entregas v\u00e1lidas atribui at\u00e9 20% da nota final.</p> </li> <li> <p>O Projeto vale 30%</p> </li> <li>A PI vale 20%</li> <li>A PF vale 30%</li> </ul> <p>Aten\u00e7\u00e3o!</p> <p>A entrega s\u00f3 poder\u00e1 ser realizada at\u00e9 as 23h59 do dia da respectiva aula. </p> <p>Condi\u00e7\u00f5es de barreira</p> <ul> <li>M\u00e9dia de provas &gt;= 4,5</li> <li>PI, PF &gt;= 4,0</li> <li>Projeto &gt;= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados)</li> </ul>"},{"location":"#equipe","title":"Equipe","text":"<p>Equipe atual</p> <ul> <li> Michel Fornaciali Professor</li> <li> L\u00edcia Sales Prof. Auxiliar</li> <li> Tiago Demay T\u00e9cnico do lab.</li> </ul>"},{"location":"index_old/","title":"SuperComputa\u00e7\u00e3o","text":"<p>Bem vindo ao curso de SuperComputa\u00e7\u00e3o 2024/2 </p> <ul> <li> <p>Equipe: </p> <ul> <li>Michel Fornaciali</li> </ul> </li> <li> <p>Hor\u00e1rio das aulas:</p> <ul> <li>Turma 1 - Ter\u00e7a - 09h45, Sexta - 13h30</li> <li>Turma 2 - Quarta - 13h30, Sexta - 07h30</li> </ul> </li> </ul>"},{"location":"index_old/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>A avalia\u00e7\u00e3o da disciplina ser\u00e1 composta por provas, projetos e atividades de acompanhamentos:</p> <ul> <li>Provas Intermedi\u00e1ria (PI) e Final (PF) ser\u00e3o compostas por exerc\u00edcios pr\u00e1ticos a serem feitos durante o tempo de prova;</li> <li>O projeto da disciplina ser\u00e1 composto por m\u00faltiplas partes. </li> </ul> <p>A m\u00e9dia final \u00e9 dada por </p> <ul> <li>55% Projeto</li> <li>45% m\u00e9dia de Provas</li> </ul> <p>Condi\u00e7\u00f5es de barreira</p> <ul> <li>M\u00e9dia de provas &gt;= 4,5</li> <li>PI, PF &gt;= 4,0</li> <li>Projeto &gt;= 5 (n\u00e3o ser\u00e3o aceitos projetos atrasados)</li> </ul> <p>Caso estas condi\u00e7\u00f5es n\u00e3o sejam cumpridas ver detalhes na aula 01</p> <p>Mesmo que todas as condi\u00e7\u00f5es acima sejam satisfeitas \u00e9 poss\u00edvel reprovar. Um desempenho abaixo do esperado em uma atividade precisa ser compensado com um desempenho melhor em outra atividade.</p>"},{"location":"sobre/","title":"Burocracias","text":"<ul> <li>Hor\u00e1rios: <ul> <li>Turma A - Prof. Andr\u00e9 Filipe:  Quarta - 13h30, Sexta - 07h30</li> <li>Turma B - Prof. Luciano Silva:  Ter\u00e7a - 09h45, Sexta - 13h30</li> </ul> </li> </ul> Plano de aulas - Turma A Data Quest\u00e3o/Problema Conte\u00fado/Atividade 08/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 10/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 15/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 17/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 24/02/23 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 01/03/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 03/03/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 08/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 15/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 17/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 22/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 29/03/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 31/03/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 05/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 12/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 14/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 19/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 26/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 28/04/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 03/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 05/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 10/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 12/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 17/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 19/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 24/05/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/06/23 Prova Final Prova Final 07/06/23 Prova Final Prova Final Plano de aulas - Turma B Data Quest\u00e3o/Problema Conte\u00fado/Atividade 07/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Introdu\u00e7\u00e3o ao curso; Princ\u00edpios de C++ 10/02/23 Introdu\u00e7\u00e3o ao curso e a tecnologias de alto desempenho Implementa\u00e7\u00e3o de algoritmos simples; Passagem de argumentos por refer\u00eancia e valor; Recursos de C++ 14/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho C++, Vectors 17/02/23 Considera\u00e7\u00f5es na implementa\u00e7\u00e3o de programas de alto desempenho Utiliza\u00e7\u00e3o de ferramentas de profiling para identificar pontos quentes em um programa 24/02/23 Estrat\u00e9gias para solu\u00e7\u00e3o de problemas dif\u00edceis Apresenta\u00e7\u00e3o do projeto da disciplina; Heur\u00edstica, busca local e global 28/02/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades da solu\u00e7\u00e3o \u00f3tima; vizinhan\u00e7a de solu\u00e7\u00f5es 03/03/23 Solu\u00e7\u00f5es sub-\u00f3timas usando a busca local Propriedades de geradores de n\u00fameros pseudo-aleat\u00f3rios; Algoritmos baseados em sorteios aleat\u00f3rios; Exploration vs Exploitation 07/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 10/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 14/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima Busca global vs Busca local; Enumera\u00e7\u00e3o exaustiva e sua classe de problemas computacionais; Backtracking 17/03/23 Buscando uma solu\u00e7\u00e3o globalmente \u00f3tima gap de otimalidade; Simetrias; Comunica\u00e7\u00e3o de resultados de desempenho 21/03/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 31/03/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 04/04/23 Prova intermedi\u00e1ria Prova intermedi\u00e1ria 11/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a OpenMP 14/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo C\u00f3digo thread-safe e reentr\u00e2ncia 18/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 25/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Introdu\u00e7\u00e3o a problemas IO bound; Constru\u00e7\u00f5es de alto n\u00edvel do OpenMP; Sincroniza\u00e7\u00e3o usando mutex e sem\u00e1foros 28/04/23 Programa\u00e7\u00e3o multi-core: como dividir tarefas e ganhar tempo Aula est\u00fadio para projeto 02/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 05/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Introdu\u00e7\u00e3o a GPGPU 10/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 12/05/23 Programa\u00e7\u00e3o em GPU e quais problemas s\u00e3o massivamente paraleliz\u00e1veis Programando para GPU, Nvidia Thrust 17/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 19/05/23 Programa\u00e7\u00e3o Distribu\u00edda com MPI Exerc\u00edcios de programa\u00e7\u00e3o em MPI 23/05/23 Aula est\u00fadio para projeto Aula est\u00fadio para projeto 02/06/23 Prova Final Prova Final 07/06/23 Prova Final Prova Final"},{"location":"Teoria/","title":"Materiais e Guias para estudo","text":"<p>Material Te\u00f3rico para estudo</p> <p>Contextualizando HPC</p> <p>Cluster Franky</p> <p>SLURM</p> <p>Conceitos B\u00e1sicos de HW</p> <p>Conceitos B\u00e1sicos de C++</p> <p>Como compilar e executar c\u00f3digos em C++</p> <p>Loops e La\u00e7os</p> <p>Passagens de par\u00e2metros (por refer\u00eancia, por ponteiro)</p> <p>Const Correctness em HPC</p> <p>Aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica</p> <p>Sobrecarga de fun\u00e7\u00f5es C++</p> <p>Classes e Objetos</p> <p>Manipula\u00e7\u00e3o de Vetores</p> <p>Flags de compila\u00e7\u00e3o</p> <p>Profiling</p>"},{"location":"Teoria/classes-e-objetos/","title":"Classes e objetos","text":"<p>Uma classe em C++ \u00e9 uma estrutura que define um conjunto de atributos (dados) e m\u00e9todos (fun\u00e7\u00f5es) que operam sobre esses dados. \u00c9 uma forma de agrupar dados e comportamentos relacionados, facilitando a modularidade e a reutiliza\u00e7\u00e3o do c\u00f3digo. Objetos s\u00e3o inst\u00e2ncias de classes. Eles representam entidades espec\u00edficas que possuem os atributos e m\u00e9todos definidos pela classe.</p>"},{"location":"Teoria/classes-e-objetos/#exemplo-pratico-problema-da-mochila","title":"Exemplo Pr\u00e1tico: Problema da Mochila","text":"<p>No exemplo do problema da mochila, criamos uma classe <code>Knapsack</code> para encapsular a l\u00f3gica do problema. Vamos detalhar cada parte do c\u00f3digo para entender como classes e objetos s\u00e3o utilizados.</p>"},{"location":"Teoria/classes-e-objetos/#declaracao-da-classe","title":"Declara\u00e7\u00e3o da Classe","text":"<p>A classe <code>Knapsack</code> \u00e9 definida com atributos e m\u00e9todos necess\u00e1rios para resolver o problema da mochila.</p> <pre><code>#include &lt;iostream&gt;\n\n// Declara\u00e7\u00e3o da classe Knapsack\nclass Knapsack {\npublic:\n    Knapsack(int capacidade, int numItens);       // Construtor que inicializa a mochila\n    ~Knapsack();                                  // Destrutor que libera a mem\u00f3ria alocada\n    void adicionaItem(int peso, int valor);       // M\u00e9todo para adicionar um item\n    int resolve();                                // M\u00e9todo para resolver o problema da mochila\n    void imprimeItens();                          // M\u00e9todo para imprimir os itens adicionados\n\nprivate:\n    int capacidade;                               // Capacidade m\u00e1xima da mochila\n    int numItens;                                 // N\u00famero total de itens\n    int* pesos;                                   // Vetor din\u00e2mico para armazenar os pesos dos itens\n    int* valores;                                 // Vetor din\u00e2mico para armazenar os valores dos itens\n    int contadorItens;                            // Contador de itens adicionados\n};\n</code></pre> <ul> <li>Atributos:<ul> <li><code>capacidade</code>: Capacidade m\u00e1xima da mochila.</li> <li><code>numItens</code>: N\u00famero total de itens.</li> <li><code>pesos</code>: Ponteiro para um vetor que armazena os pesos dos itens.</li> <li><code>valores</code>: Ponteiro para um vetor que armazena os valores dos itens.</li> <li><code>contadorItens</code>: Contador para acompanhar quantos itens foram adicionados.</li> </ul> </li> <li>M\u00e9todos:<ul> <li><code>Knapsack(int capacidade, int numItens)</code>: Construtor que inicializa os atributos e aloca mem\u00f3ria para os vetores.</li> <li><code>~Knapsack()</code>: Destrutor que libera a mem\u00f3ria alocada para os vetores.</li> <li><code>void adicionaItem(int peso, int valor)</code>: M\u00e9todo para adicionar um item \u00e0 mochila.</li> <li><code>int resolve()</code>: M\u00e9todo para resolver o problema da mochila usando programa\u00e7\u00e3o din\u00e2mica.</li> <li><code>void imprimeItens()</code>: M\u00e9todo para imprimir os itens adicionados \u00e0 mochila.</li> </ul> </li> </ul>"},{"location":"Teoria/classes-e-objetos/#implementacao-do-construtor-e-destrutor","title":"Implementa\u00e7\u00e3o do Construtor e Destrutor","text":"<p>O construtor inicializa os atributos e aloca mem\u00f3ria para os vetores de pesos e valores. O destrutor libera essa mem\u00f3ria.</p> <pre><code>// Implementa\u00e7\u00e3o do construtor\nKnapsack::Knapsack(int capacidade, int numItens)\n    : capacidade(capacidade), numItens(numItens), contadorItens(0) {\n    pesos = new int[numItens];                    // Aloca mem\u00f3ria para os pesos dos itens\n    valores = new int[numItens];                  // Aloca mem\u00f3ria para os valores dos itens\n}\n\n// Implementa\u00e7\u00e3o do destrutor\nKnapsack::~Knapsack() {\n    delete[] pesos;                               // Libera a mem\u00f3ria alocada para os pesos\n    delete[] valores;                             // Libera a mem\u00f3ria alocada para os valores\n}\n</code></pre>"},{"location":"Teoria/classes-e-objetos/#metodo-para-adicionar-itens","title":"M\u00e9todo para Adicionar Itens","text":"<p>O m\u00e9todo <code>adicionaItem</code> permite adicionar itens \u00e0 mochila, atualizando os vetores de pesos e valores.</p> <pre><code>// Implementa\u00e7\u00e3o do m\u00e9todo para adicionar um item\nvoid Knapsack::adicionaItem(int peso, int valor) {\n    if (contadorItens &lt; numItens) {\n        pesos[contadorItens] = peso;              // Adiciona o peso do item\n        valores[contadorItens] = valor;           // Adiciona o valor do item\n        contadorItens++;                          // Incrementa o contador de itens\n    } else {\n        std::cerr &lt;&lt; \"N\u00famero m\u00e1ximo de itens excedido!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"Teoria/classes-e-objetos/#metodo-para-resolver-o-problema-da-mochila","title":"M\u00e9todo para Resolver o Problema da Mochila","text":"<p>Programa\u00e7\u00e3o Din\u00e2mica (Dynamic Programming, DP) \u00e9 uma t\u00e9cnica de otimiza\u00e7\u00e3o usada para resolver problemas complexos dividindo-os em subproblemas mais simples. Ela \u00e9 especialmente eficaz para problemas que podem ser divididos em subproblemas menores, onde os resultados de subproblemas anteriores podem ser reutilizados para resolver subproblemas maiores.</p> <p>No problema da mochila, a programa\u00e7\u00e3o din\u00e2mica \u00e9 usada para encontrar a combina\u00e7\u00e3o de itens que maximiza o valor total sem exceder a capacidade da mochila. Construindo uma tabela que armazena os valores m\u00e1ximos poss\u00edveis para diferentes capacidades e conjuntos de itens.</p> <p>A tabela de DP (K) \u00e9 constru\u00edda de forma que cada entrada K[i][w] representa o valor m\u00e1ximo que pode ser obtido usando os primeiros i itens com uma capacidade m\u00e1xima de w.</p>"},{"location":"Teoria/classes-e-objetos/#metodo-resolve","title":"M\u00e9todo resolve","text":"<ol> <li> <p>Inicializa\u00e7\u00e3o da Tabela de DP:</p> <pre><code>int** K = new int*[numItens + 1];             // Aloca mem\u00f3ria para a tabela de DP\nfor (int i = 0; i &lt;= numItens; ++i) {\n    K[i] = new int[capacidade + 1];           // Aloca mem\u00f3ria para cada linha da tabela de DP\n}\n</code></pre> <ul> <li>Alocamos uma tabela <code>K</code> com <code>numItens + 1</code> linhas e <code>capacidade + 1</code> colunas. Cada entrada <code>K[i][w]</code> armazenar\u00e1 o valor m\u00e1ximo poss\u00edvel para a submochila com capacidade <code>w</code> usando os primeiros <code>i</code> itens.</li> <li>Preenchimento da Tabela de DP:</li> </ul> <pre><code>for (int i = 0; i &lt;= numItens; ++i) {\n    for (int w = 0; w &lt;= capacidade; ++w) {\n        if (i == 0 || w == 0) {\n            K[i][w] = 0;                      // Caso base: capacidade 0 ou nenhum item\n        } else if (pesos[i - 1] &lt;= w) {\n            // Escolhe o m\u00e1ximo entre incluir ou n\u00e3o o item atual\n            K[i][w] = std::max(valores[i - 1] + K[i - 1][w - pesos[i - 1]], K[i - 1][w]);\n        } else {\n            K[i][w] = K[i - 1][w];            // N\u00e3o inclui o item atual\n        }\n    }\n}\n</code></pre> <ul> <li>Usamos um loop duplo para preencher a tabela.</li> <li>Caso Base: Se n\u00e3o h\u00e1 itens (<code>i == 0</code>) ou a capacidade \u00e9 zero (<code>w == 0</code>), o valor m\u00e1ximo \u00e9 0.</li> <li>Decis\u00e3o: Para cada item, verificamos se ele pode ser inclu\u00eddo na submochila (<code>pesos[i - 1] &lt;= w</code>). Se puder, escolhemos o m\u00e1ximo entre incluir o item (somando seu valor com o valor da submochila restante) e n\u00e3o inclu\u00ed-lo.</li> <li>Exclus\u00e3o do Item: Se o item n\u00e3o puder ser inclu\u00eddo, simplesmente copiamos o valor da submochila sem ele.</li> <li>Resultado Final:</li> </ul> <pre><code>int resultado = K[numItens][capacidade];      // Resultado final da DP\n</code></pre> <ul> <li>O valor m\u00e1ximo poss\u00edvel para a mochila completa \u00e9 encontrado em <code>K[numItens][capacidade]</code>.</li> <li>Libera\u00e7\u00e3o da Mem\u00f3ria:</li> </ul> <pre><code>for (int i = 0; i &lt;= numItens; ++i) {\n    delete[] K[i];                            // Libera mem\u00f3ria para cada linha\n}\ndelete[] K;                                   // Libera mem\u00f3ria para o vetor de ponteiros\n</code></pre> <ul> <li>Ap\u00f3s o c\u00e1lculo, liberamos a mem\u00f3ria alocada dinamicamente para a tabela <code>K</code>.</li> </ul> </li> </ol> <p>Neste contexto, a programa\u00e7\u00e3o din\u00e2mica (DP) \u00e9 usada para resolver o problema da mochila de maneira eficiente, evitando recomputa\u00e7\u00f5es de subproblemas ao armazenar os resultados intermedi\u00e1rios em uma tabela. A classe <code>Knapsack</code> encapsula a l\u00f3gica do problema, tornando o c\u00f3digo modular e f\u00e1cil de manter. A aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria permite a flexibilidade de lidar com diferentes tamanhos de problemas sem desperdi\u00e7ar mem\u00f3ria.</p>"},{"location":"Teoria/classes-e-objetos/#metodo-para-imprimir-itens","title":"M\u00e9todo para Imprimir Itens","text":"<p>O m\u00e9todo <code>imprimeItens</code> imprime os itens adicionados \u00e0 mochila.</p> <pre><code>// Implementa\u00e7\u00e3o do m\u00e9todo para imprimir os itens adicionados\nvoid Knapsack::imprimeItens() {\n    std::cout &lt;&lt; \"Itens adicionados (peso, valor):\" &lt;&lt; std::endl;\n    for (int i = 0; i &lt; contadorItens; ++i) {\n        std::cout &lt;&lt; \"(\" &lt;&lt; pesos[i] &lt;&lt; \", \" &lt;&lt; valores[i] &lt;&lt; \")\" &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"Teoria/classes-e-objetos/#funcao-main","title":"Fun\u00e7\u00e3o <code>main</code>","text":"<p>A fun\u00e7\u00e3o <code>main</code> cria um objeto <code>Knapsack</code>, adiciona itens \u00e0 mochila, imprime os itens adicionados e resolve o problema da mochila.</p> <pre><code>int main() {\n    int capacidade = 50;                           // Capacidade da mochila\n    int numItens = 3;                              // N\u00famero de itens dispon\u00edveis\n\n    Knapsack mochila(capacidade, numItens);\n\n    mochila.adicionaItem(10, 60);                  // Adiciona item (peso, valor)\n    mochila.adicionaItem(20, 100);                 // Adiciona item (peso, valor)\n    mochila.adicionaItem(30, 120);                 // Adiciona item (peso, valor)\n\n    mochila.imprimeItens();                        // Imprime os itens adicionados\n\n    int valorMaximo = mochila.resolve();           // Resolve o problema da mochila\n\n    std::cout &lt;&lt; \"Valor m\u00e1ximo que pode ser levado: \" &lt;&lt; valorMaximo &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, a classe <code>Knapsack</code> encapsula todos os dados e m\u00e9todos necess\u00e1rios para resolver o problema da mochila. Usamos aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria para gerenciar os vetores de pesos, valores dos itens, e a tabela de programa\u00e7\u00e3o din\u00e2mica utilizada na solu\u00e7\u00e3o do problema.</p>"},{"location":"Teoria/comandos-ssh/","title":"Transfer\u00eancia de Arquivos entre sua m\u00e1quina e o Cluster Franky","text":"<p>O comando <code>scp</code> (Secure Copy Protocol) \u00e9 uma ferramenta segura e eficiente para transferir arquivos entre sua m\u00e1quina local e um servidor remoto, como o cluster Franky. Ele utiliza o protocolo SSH para realizar a transfer\u00eancia de arquivos, garantindo a seguran\u00e7a dos dados durante o processo.</p>"},{"location":"Teoria/comandos-ssh/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<p>Antes de come\u00e7ar, certifique-se de que: - Voc\u00ea tenha acesso ao cluster Franky via SSH. - O comando <code>scp</code> esteja instalado em sua m\u00e1quina (a maioria dos sistemas operacionais baseados em Unix/Linux j\u00e1 possuem o <code>scp</code> por padr\u00e3o).</p>"},{"location":"Teoria/comandos-ssh/#transferindo-um-arquivo-da-sua-maquina-para-o-cluster-franky","title":"Transferindo um Arquivo da Sua M\u00e1quina para o Cluster Franky","text":"<p>Para transferir um arquivo do seu computador para o cluster Franky, voc\u00ea pode usar o seguinte comando:</p> <p><pre><code>scp /caminho/local/do/arquivo.txt usuario@ip_do_cluster:/caminho/remoto/destino/\n</code></pre> Este comando copia o arquivo <code>meu_arquivo.txt</code> do diret\u00f3rio local <code>/home/user/</code> para o diret\u00f3rio <code>/home/usuario/destino/</code> no cluster Franky.</p>"},{"location":"Teoria/comandos-ssh/#explicacao-dos-parametros","title":"Explica\u00e7\u00e3o dos Par\u00e2metros:","text":"<ul> <li><code>/caminho/local/do/arquivo.txt</code>: Caminho completo do arquivo na sua m\u00e1quina local que voc\u00ea deseja transferir.</li> <li><code>usuario@ip_do_cluster</code>: Seu nome de usu\u00e1rio e o endere\u00e7o de ip do cluster Franky.</li> <li><code>/caminho/remoto/destino/</code>: O diret\u00f3rio de destino no cluster Franky onde voc\u00ea deseja salvar o arquivo.</li> </ul>"},{"location":"Teoria/comandos-ssh/#transferindo-um-arquivo-do-cluster-franky-para-sua-maquina","title":"Transferindo um Arquivo do Cluster Franky para sua M\u00e1quina","text":"<p>Para copiar um arquivo do cluster Franky para a sua m\u00e1quina local, use o seguinte comando no seu terminal:</p> <p><pre><code>scp usuario@ip_do_cluster:/caminho/remoto/do/arquivo.txt /caminho/local/destino/\n</code></pre> Este comando copia o arquivo <code>arquivo_remoto.txt</code> do diret\u00f3rio <code>/home/usuario/</code> no cluster Franky para o diret\u00f3rio <code>/home/user/destino_local/</code> na sua m\u00e1quina.</p>"},{"location":"Teoria/comandos-ssh/#explicacao-dos-parametros_1","title":"Explica\u00e7\u00e3o dos Par\u00e2metros:","text":"<ul> <li><code>usuario@franky.cluster:/caminho/remoto/do/arquivo.txt</code>: O caminho completo do arquivo no cluster Franky que voc\u00ea deseja transferir para sua m\u00e1quina local.</li> <li> <p><code>/caminho/local/destino/</code>: O diret\u00f3rio de destino na sua m\u00e1quina local onde voc\u00ea deseja salvar o arquivo.</p> </li> <li> <p>Transfer\u00eancia Recursiva: Para transferir diret\u00f3rios inteiros (incluindo subdiret\u00f3rios e arquivos), use a op\u00e7\u00e3o <code>-r</code>:</p> </li> </ul> <pre><code>scp -r /caminho/local/do/diretorio/ usuario@ip_do_cluster:/caminho/remoto/destino/\n</code></pre> <p>O comando <code>scp</code> \u00e9 uma ferramenta poderosa para transferir arquivos entre sua m\u00e1quina e o cluster Franky de forma segura e eficiente. Com as instru\u00e7\u00f5es e exemplos fornecidos neste guia, voc\u00ea deve ser capaz de realizar transfer\u00eancias de arquivos com facilidade.</p>"},{"location":"Teoria/compilar-executar-C%2B%2B/","title":"Compilar/Executar C\u00f3digos C++","text":"<p>Pr\u00e9-requisitos:</p> <ul> <li>Visual Studio Code (VSCode) instalado</li> </ul>"},{"location":"Teoria/compilar-executar-C%2B%2B/#passos-para-windows","title":"Passos para Windows","text":"<ol> <li> <p>Instalar o Compilador Siga este tutorial</p> </li> <li> <p>Instalar Extens\u00f5es Necess\u00e1rias no VSCode:</p> <ul> <li>Abra o VSCode.</li> <li>V\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo).</li> <li>Pesquise e instale a extens\u00e3o:<ul> <li>C/C++ (Microsoft)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Teoria/compilar-executar-C%2B%2B/#passos-para-linux","title":"Passos para Linux","text":"<ol> <li> <p>Instalar o Compilador G++:</p> <ul> <li>N\u00e3o precisa, j\u00e1 vem instalado &lt;3</li> </ul> </li> <li> <p>Instalar Extens\u00f5es Necess\u00e1rias no VSCode:</p> <ul> <li>Abra o VSCode.</li> <li>V\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo).</li> <li>Pesquise e instale as seguintes extens\u00e3o:<ul> <li>C/C++ (Microsoft)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Teoria/compilar-executar-C%2B%2B/#passos-para-macos","title":"Passos para macOS","text":"<ol> <li> <p>Instalar o compilador:</p> <ul> <li>N\u00e3o precisa, j\u00e1 vem instalado &lt;3</li> <li>Mas se quiser saber mais detalhes sobre o Clang, sugiro este material</li> </ul> </li> <li> <p>Instalar Extens\u00f5es Necess\u00e1rias no VSCode:</p> <ul> <li>Abra o VSCode.</li> <li>V\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo).</li> <li>Pesquise e instale a extens\u00f5es:<ul> <li>C/C++ (Microsoft)</li> </ul> </li> </ul> </li> </ol>"},{"location":"Teoria/compilar-executar-C%2B%2B/#compilando-um-exemplo-em-c-para-testar","title":"Compilando um Exemplo em C++ para Testar","text":"<p>Crie um arquivo <code>main.cpp</code> com o seguinte conte\u00fado:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/compilar-executar-C%2B%2B/#windows-compilar-e-executar","title":"Windows \u2192 Compilar e Executar","text":"<pre><code>g++ main.cpp -o main.exe\n./main.exe\n</code></pre>"},{"location":"Teoria/compilar-executar-C%2B%2B/#linux-compilar-e-executar","title":"Linux \u2192 Compilar e Executar:","text":"<pre><code>g++ main.cpp -o main\n./main\n</code></pre>"},{"location":"Teoria/compilar-executar-C%2B%2B/#macos-compilar-e-executar","title":"MacOS \u2192 Compilar e Executar","text":"<pre><code>clang++ main.cpp -o main\n./main\n</code></pre> <p>Seguindo esses passos, voc\u00ea deve ser capaz de compilar e executar programas C++ em Windows, Linux ou macOS usando o VSCode.</p>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/","title":"Conceitos b\u00e1sicos de C++","text":"<p>Esses s\u00e3o os tipos de vari\u00e1veis e seus respectivos tamanhos em C++ </p> Tipo de Dados Tamanho (em bytes) Valor M\u00ednimo Valor M\u00e1ximo bool 1 false true char 1 -128 127 unsigned char 1 0 255 short 2 -32,768 32,767 unsigned short 2 0 65,535 int 4 -2,147,483,648 2,147,483,647 unsigned int 4 0 4,294,967,295 long 8 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 unsigned long 8 0 18,446,744,073,709,551,615 float 4 1.2E-38 3.4E+38 double 8 2.3E-308 1.7E+308 long double 16 3.4E-4932 1.1E+4932 wchar_t 4 0 4,294,967,295  \u26a0\ufe0f Esses tamanhos podem variar dependendo da arquitetura do sistema. Esta tabela assume um sistema de 64 bits."},{"location":"Teoria/conceitos-basicos-C%2B%2B/#o-que-e-um-namespace","title":"O que \u00e9 um Namespace?","text":"<p>Um namespace \u00e9 uma forma de agrupar identificadores (nomes de fun\u00e7\u00f5es, classes, objetos, etc.) sob um nome comum, evitando conflitos de nome entre diferentes partes de um programa ou entre diferentes bibliotecas.</p>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/#exemplo-simples-de-namespace","title":"Exemplo Simples de Namespace","text":"<p>Imagine duas bibliotecas diferentes que ambas definem uma fun\u00e7\u00e3o chamada <code>print()</code>. Se voc\u00ea incluir ambas as bibliotecas em seu programa, o compilador n\u00e3o saber\u00e1 qual <code>print()</code> usar. Para resolver isso, cada biblioteca pode colocar sua fun\u00e7\u00e3o <code>print()</code> em seu pr\u00f3prio namespace:</p> <pre><code>// Biblioteca A\nnamespace A {\n    void print() {\n        std::cout &lt;&lt; \"Imprimindo da biblioteca A\" &lt;&lt; std::endl;\n    }\n}\n\n// Biblioteca B\nnamespace B {\n    void print() {\n        std::cout &lt;&lt; \"Imprimindo da biblioteca B\" &lt;&lt; std::endl;\n    }\n}\n\nint main() {\n    A::print(); // Chama a fun\u00e7\u00e3o print() da biblioteca A\n    B::print(); // Chama a fun\u00e7\u00e3o print() da biblioteca B\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/#usando-namespaces","title":"Usando Namespaces","text":"<p>Existem v\u00e1rias maneiras de usar namespaces em C++:</p> <ol> <li> <p>Usar o nome completo do namespace (qualifica\u00e7\u00e3o total):</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; // Usa std::cout e std::endl\n    return 0;\n}\n</code></pre> </li> <li> <p>Usar a declara\u00e7\u00e3o <code>using</code> para trazer membros espec\u00edficos do namespace para o escopo atual:</p> <pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::endl;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // Usa cout e endl sem o prefixo std::\n    return 0;\n}\n</code></pre> </li> <li> <p>Usar a diretiva <code>using</code> para trazer todos os membros do namespace para o escopo atual:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl; // Usa cout e endl sem o prefixo std::\n    return 0;\n}\n</code></pre> </li> </ol>"},{"location":"Teoria/conceitos-basicos-C%2B%2B/#o-que-e-std","title":"O que \u00e9 <code>std</code>?","text":"<p><code>std</code> \u00e9 o namespace padr\u00e3o da biblioteca padr\u00e3o C++ (Standard Library). Ele cont\u00e9m a maior parte das fun\u00e7\u00f5es, objetos, tipos e classes fornecidos pela biblioteca padr\u00e3o do C++. Quando voc\u00ea usa recursos da biblioteca padr\u00e3o, como <code>std::vector</code>, <code>std::cout</code>, <code>std::string</code>, etc., voc\u00ea est\u00e1 acessando esses elementos do namespace <code>std</code>.</p> <p>Por exemplo:</p> <ul> <li><code>std::cout</code> \u00e9 o objeto de fluxo de sa\u00edda padr\u00e3o usado para imprimir dados na tela.</li> <li><code>std::vector</code> \u00e9 uma classe de cont\u00eainer que representa um array din\u00e2mico.</li> </ul>"},{"location":"Teoria/flags-compilacao/","title":"Flags de compila\u00e7\u00e3o (-O1, -O2, -O3, -Ofast).","text":"<p>As flags de compila\u00e7\u00e3o s\u00e3o op\u00e7\u00f5es fornecidas ao compilador para controlar o n\u00edvel de otimiza\u00e7\u00e3o aplicada ao c\u00f3digo durante o processo de compila\u00e7\u00e3o. Diferentes n\u00edveis de otimiza\u00e7\u00e3o podem influenciar o desempenho e o tamanho do c\u00f3digo resultante. Vamos explorar as principais flags de otimiza\u00e7\u00e3o usadas com o compilador GCC (GNU Compiler Collection): <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, e <code>-Ofast</code>.</p>"},{"location":"Teoria/flags-compilacao/#1-flag-o1","title":"1. Flag <code>O1</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel B\u00e1sico de Otimiza\u00e7\u00e3o: Aplica otimiza\u00e7\u00f5es que melhoram o desempenho do c\u00f3digo sem aumentar significativamente o tempo de compila\u00e7\u00e3o.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Remo\u00e7\u00e3o de c\u00f3digo morto.</li> <li>Simplifica\u00e7\u00e3o de express\u00f5es.</li> <li>Inlining b\u00e1sico de fun\u00e7\u00f5es.</li> </ul> <p>Quando Usar:</p> <ul> <li>Quando o tempo de compila\u00e7\u00e3o \u00e9 uma preocupa\u00e7\u00e3o, mas algum n\u00edvel de otimiza\u00e7\u00e3o \u00e9 desejado.</li> </ul> <pre><code>g++ -O1 -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#2-flag-o2","title":"2. Flag <code>O2</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel Moderado de Otimiza\u00e7\u00e3o: Aplica um conjunto mais agressivo de otimiza\u00e7\u00f5es que melhoram ainda mais o desempenho do c\u00f3digo.</li> <li>Maior tempo de compila\u00e7\u00e3o comparado ao <code>O1</code>, mas melhor desempenho do c\u00f3digo.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Inclui todas as otimiza\u00e7\u00f5es do <code>O1</code>.</li> <li>Otimiza\u00e7\u00f5es de loop (desenrolamento, fus\u00e3o de loops).</li> <li>Melhorias na aloca\u00e7\u00e3o de registradores.</li> <li>Otimiza\u00e7\u00f5es de fluxo de controle.</li> </ul> <p>Quando Usar:</p> <ul> <li>Para a maioria dos casos onde o desempenho \u00e9 mais cr\u00edtico do que o tempo de compila\u00e7\u00e3o.</li> <li>Quando se quer um bom desempenho na performance do c\u00f3digo.</li> </ul> <pre><code>g++ -O2 -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#3-flag-o3","title":"3. Flag <code>O3</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel Alto de Otimiza\u00e7\u00e3o: Aplica otimiza\u00e7\u00f5es muito agressivas que podem aumentar significativamente o tempo de compila\u00e7\u00e3o e o uso de mem\u00f3ria.</li> <li>Foco em maximizar o desempenho do c\u00f3digo, mesmo que isso aumente o tempo de compila\u00e7\u00e3o.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Inclui todas as otimiza\u00e7\u00f5es do <code>O2</code>.</li> <li>Inlining mais agressivo de fun\u00e7\u00f5es.</li> <li>Vetoriza\u00e7\u00e3o (uso de SIMD).</li> <li>Transforma\u00e7\u00f5es mais avan\u00e7adas de loop.</li> </ul> <p>Quando Usar:</p> <ul> <li>Quando o desempenho m\u00e1ximo do c\u00f3digo \u00e9 crucial e o tempo de compila\u00e7\u00e3o \u00e9 menos importante.</li> <li>Em aplica\u00e7\u00f5es onde cada gota de desempenho \u00e9 necess\u00e1ria.</li> </ul> <pre><code>g++ -O3 -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#4-flag-ofast","title":"4. Flag <code>Ofast</code>","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>N\u00edvel M\u00e1ximo de Otimiza\u00e7\u00e3o: Aplica todas as otimiza\u00e7\u00f5es do <code>O3</code> e desconsidera a conformidade estrita com os padr\u00f5es, o que pode levar a um desempenho ainda maior.</li> </ul> <p>Otimiza\u00e7\u00f5es Comuns:</p> <ul> <li>Inclui todas as otimiza\u00e7\u00f5es do <code>O3</code>.</li> <li>Otimiza\u00e7\u00f5es de matem\u00e1tica r\u00e1pida (por exemplo, assume que n\u00e3o h\u00e1 overflow de ponto flutuante).</li> <li>Desconsidera o padr\u00e3o IEEE para opera\u00e7\u00f5es de ponto flutuante.</li> </ul> <p>Quando Usar:</p> <ul> <li>Quando o desempenho \u00e9 a \u00fanica prioridade e a conformidade estrita com os padr\u00f5es n\u00e3o \u00e9 uma preocupa\u00e7\u00e3o.</li> <li>Em cen\u00e1rios de HPC onde a precis\u00e3o pode ser ligeiramente sacrificada por ganhos de desempenho.</li> </ul> <pre><code>g++ -Ofast -o meu_programa meu_programa.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-dos-niveis-de-otimizacao","title":"Compara\u00e7\u00e3o dos N\u00edveis de Otimiza\u00e7\u00e3o","text":"Flag Tempo de Compila\u00e7\u00e3o Desempenho Seguran\u00e7a e Conformidade -O1 Baixo Moderado Alta -O2 Moderado Alto Alta -O3 Alto Muito Alto Alta -Ofast Muito Alto M\u00e1ximo M\u00e9dia/Baixa <p>As flags de otimiza\u00e7\u00e3o s\u00e3o ferramentas poderosas que podem ajudar a melhorar significativamente o desempenho do seu c\u00f3digo C++. Entender como e quando us\u00e1-las \u00e9 essencial para aproveitar ao m\u00e1ximo os recursos de seu ambiente de compila\u00e7\u00e3o e execu\u00e7\u00e3o.</p>"},{"location":"Teoria/flags-compilacao/#exemplos-de-compilacao-com-diferentes-flags-de-otimizacao","title":"Exemplos de Compila\u00e7\u00e3o com Diferentes Flags de Otimiza\u00e7\u00e3o","text":"<p>Para demonstrar os efeitos das diferentes flags de otimiza\u00e7\u00e3o (<code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Ofast</code>) no desempenho de c\u00f3digos C++, vamos utilizar tr\u00eas exemplos representativos de HPC.</p>"},{"location":"Teoria/flags-compilacao/#exemplo-1-multiplicacao-de-matrizes","title":"Exemplo 1: Multiplica\u00e7\u00e3o de Matrizes","text":"<p>A multiplica\u00e7\u00e3o de matrizes \u00e9 uma opera\u00e7\u00e3o computacionalmente intensiva com muitas aplica\u00e7\u00f5es em HPC.</p>"},{"location":"Teoria/flags-compilacao/#codigo-base","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nvoid multiplyMatrices(const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;double&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;double&gt;&gt;&amp; C, int N) {\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            C[i][j] = 0;\n            for (int k = 0; k &lt; N; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    const int N = 1000;\n    std::vector&lt;std::vector&lt;double&gt;&gt; A(N, std::vector&lt;double&gt;(N, 1.0));\n    std::vector&lt;std::vector&lt;double&gt;&gt; B(N, std::vector&lt;double&gt;(N, 1.0));\n    std::vector&lt;std::vector&lt;double&gt;&gt; C(N, std::vector&lt;double&gt;(N, 0.0));\n\n    auto start = std::chrono::high_resolution_clock::now();\n    multiplyMatrices(A, B, C, N);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    std::cout &lt;&lt; \"Duration: \" &lt;&lt; duration.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/flags-compilacao/#compilacao-e-execucao","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<ol> <li>Compila\u00e7\u00e3o com <code>O1</code>:</li> </ol> <pre><code>g++ -O1 -o matrix_multiplication_O1 matrix_multiplication.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O2</code>:</li> </ol> <pre><code>g++ -O2 -o matrix_multiplication_O2 matrix_multiplication.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O3</code>:</li> </ol> <pre><code>g++ -O3 -o matrix_multiplication_O3 matrix_multiplication.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>Ofast</code>:</li> </ol> <pre><code>g++ -Ofast -o matrix_multiplication_Ofast matrix_multiplication.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho","title":"Compara\u00e7\u00e3o de Desempenho","text":"<p>Execute cada vers\u00e3o do programa compilado e compare a dura\u00e7\u00e3o relatada:</p> <pre><code>time ./matrix_multiplication_O1\ntime ./matrix_multiplication_O2\ntime ./matrix_multiplication_O3\ntime ./matrix_multiplication_Ofast\n</code></pre>"},{"location":"Teoria/flags-compilacao/#explicando-o-output-do-time","title":"Explicando o Output do <code>time</code>","text":"<p>Quando voc\u00ea usa o comando <code>time</code> para medir o tempo de execu\u00e7\u00e3o de um programa, ele fornece tr\u00eas valores principais no output: real, user, e sys. Esses valores representam diferentes aspectos do tempo de execu\u00e7\u00e3o do programa.</p>"},{"location":"Teoria/flags-compilacao/#exemplo-de-output-do-time","title":"Exemplo de Output do <code>time</code>","text":"<pre><code>real    0m10.123s\nuser    0m8.456s\nsys     0m1.234s\n</code></pre>"},{"location":"Teoria/flags-compilacao/#o-que-cada-valor-representa","title":"O Que Cada Valor Representa","text":""},{"location":"Teoria/flags-compilacao/#1-real","title":"1. real","text":"<ul> <li>Tempo Real: Representa o tempo total que passou desde o in\u00edcio at\u00e9 o fim da execu\u00e7\u00e3o do comando. Esse valor inclui todo o tempo de espera do programa, como I/O (input/output), troca de contexto, e tempo de espera por recursos.</li> </ul> <p>Se voc\u00ea iniciar o programa e cronometra-lo com um cron\u00f4metro, o valor real \u00e9 o que voc\u00ea veria no cron\u00f4metro.</p> <p>Fatores que Afetam:</p> <ul> <li>Tempo gasto aguardando acesso ao disco.</li> <li>Tempo de espera na fila da CPU.</li> <li>Troca de contexto e outros tempos de espera.</li> </ul>"},{"location":"Teoria/flags-compilacao/#2-user","title":"2. user","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>Tempo de Usu\u00e1rio: Representa a quantidade de tempo que a CPU gastou executando o c\u00f3digo do programa em modo usu\u00e1rio. Esse tempo n\u00e3o inclui o tempo gasto em chamadas de sistema (system calls) ou o tempo gasto aguardando opera\u00e7\u00f5es de I/O.</li> </ul> <p>Medida de quanto tempo de CPU foi usado para executar as instru\u00e7\u00f5es do seu programa.</p> <p>Fatores que Afetam:</p> <ul> <li>Processamento computacional pesado.</li> <li>C\u00e1lculos matem\u00e1ticos e loops intensivos.</li> </ul>"},{"location":"Teoria/flags-compilacao/#3-sys","title":"3. sys","text":"<p>Descri\u00e7\u00e3o:</p> <ul> <li>Tempo de Sistema: Representa a quantidade de tempo que a CPU gastou executando o c\u00f3digo do kernel em nome do seu programa. Isso inclui o tempo gasto em chamadas de sistema, como opera\u00e7\u00f5es de I/O, gerenciamento de mem\u00f3ria, e outras opera\u00e7\u00f5es de kernel.</li> </ul> <p>Tempo de CPU gasto para executar fun\u00e7\u00f5es de sistema solicitadas pelo seu programa.</p> <p>Fatores que Afetam:</p> <ul> <li>Opera\u00e7\u00f5es de leitura/escrita de disco.</li> <li>Opera\u00e7\u00f5es de rede.</li> <li>Aloca\u00e7\u00e3o e gerenciamento de mem\u00f3ria.</li> </ul>"},{"location":"Teoria/flags-compilacao/#interpretacao-do-output","title":"Interpreta\u00e7\u00e3o do Output","text":"<p>Vamos considerar novamente o exemplo de output:</p> <pre><code>real    0m10.123s\nuser    0m8.456s\nsys     0m1.234s\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <ul> <li>real (0m10.123s): O programa levou 10.123 segundos para ser executado do in\u00edcio ao fim. Isso inclui todo o tempo de espera.</li> <li>user (0m8.456s): A CPU gastou 8.456 segundos executando o c\u00f3digo do seu programa.</li> <li>sys (0m1.234s): A CPU gastou 1.234 segundos executando fun\u00e7\u00f5es do sistema em nome do seu programa.</li> </ul>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho-com-diferentes-flags-de-compilacao","title":"Compara\u00e7\u00e3o de Desempenho com Diferentes Flags de Compila\u00e7\u00e3o","text":"<p>Ao usar <code>time</code> para comparar programas compilados com diferentes flags de otimiza\u00e7\u00e3o (<code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Ofast</code>), voc\u00ea deve prestar aten\u00e7\u00e3o principalmente ao valor real para ver o impacto geral no tempo de execu\u00e7\u00e3o. No entanto, os valores user e sys tamb\u00e9m s\u00e3o importantes para entender como as otimiza\u00e7\u00f5es afetam o uso da CPU e o tempo gasto em opera\u00e7\u00f5es do sistema.</p>"},{"location":"Teoria/flags-compilacao/#_1","title":"Flags de compila\u00e7\u00e3o (-O1, -O2, -O3, -Ofast).","text":"<pre><code># Compila\u00e7\u00e3o com -O3\ng++ -O3 -o matrix_multiplication_O3 matrix_multiplication.cpp\n\n# Medi\u00e7\u00e3o de tempo de execu\u00e7\u00e3o\ntime ./matrix_multiplication_O3\n</code></pre> <p>Output esperado:</p> <pre><code>real    0m7.123s\nuser    0m6.789s\nsys     0m0.234s\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <ul> <li>real (0m7.123s): O tempo total de execu\u00e7\u00e3o foi de 7.123 segundos.</li> <li>user (0m6.789s): A CPU gastou 6.789 segundos executando o c\u00f3digo do programa.</li> <li>sys (0m0.234s): A CPU gastou 0.234 segundos em chamadas de sistema.</li> </ul> <p>Os valores fornecidos pelo comando <code>time</code> ajudam a entender o comportamento do seu programa e o impacto das otimiza\u00e7\u00f5es no desempenho geral. Analisar esses valores pode revelar gargalos e oportunidades de otimiza\u00e7\u00e3o adicional.</p>"},{"location":"Teoria/flags-compilacao/#exemplo-2-regressao-linear-ia","title":"Exemplo 2: Regress\u00e3o Linear (IA)","text":"<p>A regress\u00e3o linear \u00e9 um algoritmo b\u00e1sico de aprendizado de m\u00e1quina comumente usado em IA.</p>"},{"location":"Teoria/flags-compilacao/#codigo-base_1","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\ndouble linearRegression(const std::vector&lt;double&gt;&amp; X, const std::vector&lt;double&gt;&amp; Y) {\n    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;\n    int n = X.size();\n    for (int i = 0; i &lt; n; ++i) {\n        sumX += X[i];\n        sumY += Y[i];\n        sumXY += X[i] * Y[i];\n        sumX2 += X[i] * X[i];\n    }\n    return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n}\n\nint main() {\n    const int N = 1000000;\n    std::vector&lt;double&gt; X(N, 1.0);\n    std::vector&lt;double&gt; Y(N, 2.0);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    double slope = linearRegression(X, Y);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    std::cout &lt;&lt; \"Slope: \" &lt;&lt; slope &lt;&lt; \", Duration: \" &lt;&lt; duration.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/flags-compilacao/#compilacao-e-execucao_1","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<ol> <li>Compila\u00e7\u00e3o com <code>O1</code>:</li> </ol> <pre><code>g++ -O1 -o linear_regression_O1 linear_regression.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O2</code>:</li> </ol> <pre><code>g++ -O2 -o linear_regression_O2 linear_regression.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O3</code>:</li> </ol> <pre><code>g++ -O3 -o linear_regression_O3 linear_regression.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>Ofast</code>:</li> </ol> <pre><code>g++ -Ofast -o linear_regression_Ofast linear_regression.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho_1","title":"Compara\u00e7\u00e3o de Desempenho","text":"<p>Execute cada vers\u00e3o do programa compilado e compare a dura\u00e7\u00e3o relatada:</p> <pre><code>time ./linear_regression_O1\ntime ./linear_regression_O2\ntime ./linear_regression_O3\ntime ./linear_regression_Ofast\n</code></pre>"},{"location":"Teoria/flags-compilacao/#exemplo-3-processamento-de-grandes-conjuntos-de-dados-data-science","title":"Exemplo 3: Processamento de Grandes Conjuntos de Dados (Data Science)","text":"<p>Um exemplo comum em Data Science \u00e9 a normaliza\u00e7\u00e3o de um grande conjunto de dados.</p>"},{"location":"Teoria/flags-compilacao/#codigo-base_2","title":"C\u00f3digo Base","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n\nvoid normalize(std::vector&lt;double&gt;&amp; data) {\n    double mean = 0.0;\n    double stddev = 0.0;\n    int n = data.size();\n\n    for (int i = 0; i &lt; n; ++i) {\n        mean += data[i];\n    }\n    mean /= n;\n\n    for (int i = 0; i &lt; n; ++i) {\n        stddev += (data[i] - mean) * (data[i] - mean);\n    }\n    stddev = std::sqrt(stddev / n);\n\n    for (int i = 0; i &lt; n; ++i) {\n        data[i] = (data[i] - mean) / stddev;\n    }\n}\n\nint main() {\n    const int N = 10000000;\n    std::vector&lt;double&gt; data(N, 1.0);\n\n    auto start = std::chrono::high_resolution_clock::now();\n    normalize(data);\n    auto end = std::chrono::high_resolution_clock::now();\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    std::cout &lt;&lt; \"Duration: \" &lt;&lt; duration.count() &lt;&lt; \" seconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/flags-compilacao/#compilacao-e-execucao_2","title":"Compila\u00e7\u00e3o e Execu\u00e7\u00e3o","text":"<ol> <li>Compila\u00e7\u00e3o com <code>O1</code>:</li> </ol> <pre><code>g++ -O1 -o normalize_O1 normalize.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O2</code>:</li> </ol> <pre><code>g++ -O2 -o normalize_O2 normalize.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>O3</code>:</li> </ol> <pre><code>g++ -O3 -o normalize_O3 normalize.cpp\n</code></pre> <ol> <li>Compila\u00e7\u00e3o com <code>Ofast</code>:</li> </ol> <pre><code>g++ -Ofast -o normalize_Ofast normalize.cpp\n</code></pre>"},{"location":"Teoria/flags-compilacao/#comparacao-de-desempenho_2","title":"Compara\u00e7\u00e3o de Desempenho","text":"<p>Execute cada vers\u00e3o do programa compilado e compare a dura\u00e7\u00e3o relatada:</p> <pre><code>time ./normalize_O1\ntime ./normalize_O2\ntime ./normalize_O3\ntime ./normalize_Ofast\n</code></pre> <p>Depois de compilar e executar os programas com diferentes flags de otimiza\u00e7\u00e3o, compare os tempos de execu\u00e7\u00e3o relatados por cada um. Isso ajudar\u00e1 a entender como diferentes n\u00edveis de otimiza\u00e7\u00e3o afetam o desempenho de opera\u00e7\u00f5es computacionalmente intensivas.</p>"},{"location":"Teoria/funcoes-inline/","title":"Fun\u00e7\u00f5es Inline","text":"<p>As fun\u00e7\u00f5es inline s\u00e3o usadas para reduzir a sobrecarga das chamadas de fun\u00e7\u00e3o, que pode ser significativa em programas de alto desempenho onde fun\u00e7\u00f5es s\u00e3o chamadas repetidamente. Em vez de realizar uma chamada de fun\u00e7\u00e3o, que envolve empilhar argumentos, saltar para a localiza\u00e7\u00e3o da fun\u00e7\u00e3o, executar a fun\u00e7\u00e3o, e ent\u00e3o retornar, o compilador substitui a chamada da fun\u00e7\u00e3o pelo pr\u00f3prio corpo da fun\u00e7\u00e3o. Isso pode resultar em um c\u00f3digo mais r\u00e1pido e eficiente.</p>"},{"location":"Teoria/funcoes-inline/#vantagens-de-usar-funcoes-inline","title":"Vantagens de Usar Fun\u00e7\u00f5es Inline","text":"<ol> <li>Redu\u00e7\u00e3o da Sobrecarga de Chamada de Fun\u00e7\u00e3o:<ul> <li>As chamadas de fun\u00e7\u00e3o envolvem opera\u00e7\u00f5es adicionais de empilhamento de argumentos e desvio de controle, que podem se tornar um gargalo se as fun\u00e7\u00f5es forem chamadas repetidamente.</li> <li>Fun\u00e7\u00f5es inline eliminam essa sobrecarga, substituindo a chamada pelo pr\u00f3prio c\u00f3digo da fun\u00e7\u00e3o.</li> </ul> </li> <li>Melhoria do Desempenho:<ul> <li>A execu\u00e7\u00e3o de fun\u00e7\u00f5es inline pode ser mais r\u00e1pida, especialmente em loops intensivos onde pequenas fun\u00e7\u00f5es s\u00e3o chamadas repetidamente.</li> <li>Pode resultar em otimiza\u00e7\u00f5es adicionais pelo compilador, como a elimina\u00e7\u00e3o de vari\u00e1veis tempor\u00e1rias e a fus\u00e3o de c\u00f3digo.</li> </ul> </li> <li>Efici\u00eancia do Cache:<ul> <li>Em alguns casos, a inser\u00e7\u00e3o de fun\u00e7\u00f5es inline pode melhorar a localidade de refer\u00eancia e a efici\u00eancia do cache, embora isso dependa da natureza do c\u00f3digo e do hardware.</li> </ul> </li> </ol>"},{"location":"Teoria/funcoes-inline/#contextos-ideais-para-aplicar-funcoes-inline","title":"Contextos Ideais para Aplicar Fun\u00e7\u00f5es Inline","text":"<ol> <li> <p>Fun\u00e7\u00f5es Pequenas e Simples:</p> <ul> <li>Fun\u00e7\u00f5es que s\u00e3o curtas e t\u00eam poucas opera\u00e7\u00f5es s\u00e3o ideais para serem inline. Por exemplo, fun\u00e7\u00f5es matem\u00e1ticas simples como <code>soma</code>, <code>subtrai</code>, <code>multiplica</code> ou <code>divide</code>.</li> </ul> <pre><code>inline int soma(int a, int b) {\n    return a + b;\n}\n</code></pre> </li> <li> <p>Fun\u00e7\u00f5es Chamadas Frequentemente:</p> <ul> <li>Fun\u00e7\u00f5es que s\u00e3o chamadas repetidamente em loops intensivos s\u00e3o boas candidatas para serem inline, pois a elimina\u00e7\u00e3o da sobrecarga da chamada de fun\u00e7\u00e3o pode ter um impacto significativo no desempenho.</li> </ul> <pre><code>inline int quadrado(int x) {\n    return x * x;\n}\n</code></pre> </li> <li> <p>Fun\u00e7\u00f5es que Acessam Membros de Classe:</p> <ul> <li>M\u00e9todos de classe que s\u00e3o simples e frequentemente chamados podem se beneficiar de serem inline. Em C++, m\u00e9todos definidos dentro da declara\u00e7\u00e3o de uma classe s\u00e3o implicitamente inline.</li> </ul> <pre><code>class Ponto {\npublic:\n    inline int getX() const { return x; }\n    inline int getY() const { return y; }\nprivate:\n    int x, y;\n};\n</code></pre> </li> </ol>"},{"location":"Teoria/funcoes-inline/#exemplo","title":"Exemplo","text":"<p>Vamos considerar um exemplo onde uma fun\u00e7\u00e3o inline \u00e9 usada para calcular o quadrado de um n\u00famero em um loop intensivo. Isso \u00e9 comum em opera\u00e7\u00f5es cient\u00edficas e de engenharia, onde c\u00e1lculos matem\u00e1ticos simples s\u00e3o realizados repetidamente.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Fun\u00e7\u00e3o inline para calcular o quadrado de um n\u00famero\ninline int quadrado(int x) {\n    return x * x;\n}\n\nint main() {\n    const int N = 1000000; // N\u00famero de elementos\n    vector&lt;int&gt; dados(N, 2); // Inicializa um vetor com N elementos, todos iguais a 2\n    vector&lt;int&gt; resultados(N);\n\n    auto inicio = high_resolution_clock::now();\n\n    // Loop intensivo que usa a fun\u00e7\u00e3o inline\n    for (int i = 0; i &lt; N; ++i) {\n        resultados[i] = quadrado(dados[i]);\n    }\n\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Tempo para calcular quadrados: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes-inline/#consideracoes-ao-usar-funcoes-inline","title":"Considera\u00e7\u00f5es ao Usar Fun\u00e7\u00f5es Inline","text":"<ol> <li>Tamanho da Fun\u00e7\u00e3o:<ul> <li>Fun\u00e7\u00f5es inline devem ser pequenas e simples. Fun\u00e7\u00f5es grandes inline podem aumentar significativamente o tamanho do c\u00f3digo bin\u00e1rio, o que pode ter um efeito negativo na efici\u00eancia do cache.</li> </ul> </li> <li>Otimiza\u00e7\u00f5es do Compilador:<ul> <li>O compilador pode ignorar a sugest\u00e3o de inline se achar que n\u00e3o ser\u00e1 ben\u00e9fico. Isso \u00e9 apenas uma sugest\u00e3o ao compilador.</li> </ul> </li> <li>Manutenibilidade:<ul> <li>Excesso de fun\u00e7\u00f5es inline pode tornar o c\u00f3digo mais dif\u00edcil de ler e manter. Use inline judiciosamente, apenas onde os benef\u00edcios de desempenho s\u00e3o claros.</li> </ul> </li> </ol> <p>As fun\u00e7\u00f5es inline s\u00e3o uma ferramenta valiosa em High-Performance Computing para reduzir a sobrecarga de chamadas de fun\u00e7\u00e3o e melhorar o desempenho em loops intensivos e c\u00e1lculos repetitivos. Elas devem ser usadas em fun\u00e7\u00f5es pequenas e frequentemente chamadas para obter os maiores benef\u00edcios. Ao combinar fun\u00e7\u00f5es inline com a sobrecarga de fun\u00e7\u00f5es, podemos otimizar ainda mais o c\u00f3digo para diferentes tipos de dados, mantendo a legibilidade e a organiza\u00e7\u00e3o.</p>"},{"location":"Teoria/funcoes/","title":"Passagem de Par\u00e2metros","text":"<p>Par\u00e2metros podem ser passados por valor, por refer\u00eancia ou por ponteiro. No contexto de HPC, passar par\u00e2metros por refer\u00eancia ou ponteiro \u00e9 geralmente prefer\u00edvel para evitar c\u00f3pias desnecess\u00e1rias de dados, que podem ser custosas em termos de tempo e mem\u00f3ria.</p>"},{"location":"Teoria/funcoes/#passagem-de-parametros-por-valor","title":"Passagem de Par\u00e2metros por Valor","text":"<p>Passar por valor significa que uma c\u00f3pia do argumento \u00e9 passada para a fun\u00e7\u00e3o. Qualquer modifica\u00e7\u00e3o feita ao par\u00e2metro dentro da fun\u00e7\u00e3o n\u00e3o afeta o argumento original.</p> <pre><code>// Fun\u00e7\u00e3o que recebe um par\u00e2metro por valor\nvoid exemploValor(int x) {\n    x = 10; // Modifica\u00e7\u00e3o local, n\u00e3o afeta o argumento original\n}\n</code></pre>"},{"location":"Teoria/funcoes/#passagem-por-referencia-e-passagem-por-ponteiro","title":"Passagem por Refer\u00eancia e Passagem por Ponteiro","text":"<p>Passagem por refer\u00eancia e passagem por ponteiro s\u00e3o duas formas de passar argumentos para fun\u00e7\u00f5es em C++, permitindo que a fun\u00e7\u00e3o modifique o argumento original. Apesar de terem prop\u00f3sitos similares, elas diferem em sintaxe e uso. Vamos explorar essas diferen\u00e7as detalhadamente.</p>"},{"location":"Teoria/funcoes/#passagem-por-referencia","title":"Passagem por Refer\u00eancia","text":"<p>Passar um argumento por refer\u00eancia significa que a fun\u00e7\u00e3o recebe uma refer\u00eancia ao argumento original, permitindo modificar diretamente o valor do argumento. A sintaxe usa o operador <code>&amp;</code> no par\u00e2metro da fun\u00e7\u00e3o.</p>"},{"location":"Teoria/funcoes/#sintaxe-e-exemplo","title":"Sintaxe e Exemplo","text":"<pre><code>#include &lt;iostream&gt;\n\n// Fun\u00e7\u00e3o que recebe um par\u00e2metro por refer\u00eancia\nvoid alteraPorReferencia(int&amp; x) {\n    x = 10; // Modifica\u00e7\u00e3o afeta o argumento original\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    alteraPorReferencia(valor);\n    std::cout &lt;&lt; \"Depois da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Sintaxe Limpa: A sintaxe \u00e9 mais clara e f\u00e1cil de ler, pois n\u00e3o envolve o uso expl\u00edcito de ponteiros.</li> <li>Seguran\u00e7a: Reduz o risco de manipula\u00e7\u00e3o incorreta de ponteiros (como desreferenciamento de ponteiros nulos).</li> <li>N\u00e3o Nulo: Refer\u00eancias devem ser inicializadas e n\u00e3o podem ser nulas.</li> </ul>"},{"location":"Teoria/funcoes/#passagem-por-ponteiro","title":"Passagem por Ponteiro","text":"<p>Passar um argumento por ponteiro significa que a fun\u00e7\u00e3o recebe o endere\u00e7o do argumento original. A sintaxe usa o operador <code>*</code> no par\u00e2metro da fun\u00e7\u00e3o e o operador <code>&amp;</code> ao passar o argumento.</p>"},{"location":"Teoria/funcoes/#sintaxe-e-exemplo_1","title":"Sintaxe e Exemplo","text":"<pre><code>#include &lt;iostream&gt;\n\n// Fun\u00e7\u00e3o que recebe um par\u00e2metro por ponteiro\nvoid alteraPorPonteiro(int* x) {\n    *x = 10; // Modifica\u00e7\u00e3o afeta o argumento original\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    alteraPorPonteiro(&amp;valor);\n    std::cout &lt;&lt; \"Depois da fun\u00e7\u00e3o: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes/#caracteristicas_1","title":"Caracter\u00edsticas","text":"<ul> <li>Flexibilidade: Permite a passagem de valores nulos (ponteiros nulos).</li> <li>Controle Expl\u00edcito: Fornece controle expl\u00edcito sobre a mem\u00f3ria, podendo ser \u00fatil em contextos onde manipula\u00e7\u00e3o direta de endere\u00e7os \u00e9 necess\u00e1ria.</li> <li>Complexidade: A sintaxe pode ser mais complexa e propensa a erros, como desreferenciamento de ponteiros nulos ou incorretos.</li> </ul>"},{"location":"Teoria/funcoes/#quando-usar-cada-um","title":"Quando Usar Cada Um","text":"<ul> <li>Passagem por Refer\u00eancia: Use quando voc\u00ea precisa modificar o argumento original e quer uma sintaxe mais limpa e segura. Ideal para a maioria dos casos onde a refer\u00eancia n\u00e3o precisa ser nula.</li> <li>Passagem por Ponteiro: Use quando h\u00e1 a necessidade de manipular diretamente endere\u00e7os de mem\u00f3ria ou quando o valor passado pode ser opcional (nulo).</li> </ul>"},{"location":"Teoria/funcoes/#exemplo-comparativo","title":"Exemplo Comparativo","text":"<p>Vamos comparar um exemplo onde modificamos um valor usando ambas as abordagens.</p>"},{"location":"Teoria/funcoes/#passagem-por-referencia_1","title":"Passagem por Refer\u00eancia","text":"<pre><code>#include &lt;iostream&gt;\n\nvoid incrementaReferencia(int&amp; x) {\n    x++; // Incrementa o valor\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes: \" &lt;&lt; valor &lt;&lt; std::endl;\n    incrementaReferencia(valor);\n    std::cout &lt;&lt; \"Depois: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/funcoes/#passagem-por-ponteiro_1","title":"Passagem por Ponteiro","text":"<pre><code>#include &lt;iostream&gt;\n\nvoid incrementaPonteiro(int* x) {\n    if (x) { // Verifica se o ponteiro n\u00e3o \u00e9 nulo\n        (*x)++; // Incrementa o valor\n    }\n}\n\nint main() {\n    int valor = 5;\n    std::cout &lt;&lt; \"Antes: \" &lt;&lt; valor &lt;&lt; std::endl;\n    incrementaPonteiro(&amp;valor);\n    std::cout &lt;&lt; \"Depois: \" &lt;&lt; valor &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Ambos os exemplos acima modificam o valor original de <code>valor</code>, mas a abordagem de refer\u00eancia \u00e9 mais limpa, enquanto a abordagem de ponteiro oferece maior flexibilidade em termos de manipula\u00e7\u00e3o de endere\u00e7os e valores nulos.</p>"},{"location":"Teoria/loops-e-la%C3%A7os/","title":"Loops  e La\u00e7os","text":"<p>No contexto de HPC, onde a efici\u00eancia e a performance s\u00e3o cruciais, as estruturas de controle (loops e la\u00e7os) desempenham pap\u00e9is vitais:</p> <ol> <li>Otimiza\u00e7\u00e3o de Algoritmos<ul> <li>As estruturas de controle permitem que algoritmos sejam implementados de forma eficiente. Condicionais e loops bem utilizados podem reduzir o n\u00famero de opera\u00e7\u00f5es e evitar c\u00e1lculos desnecess\u00e1rios, otimizando o tempo de execu\u00e7\u00e3o.</li> </ul> </li> <li>Paralelismo<ul> <li>Em HPC, o paralelismo \u00e9 frequentemente utilizado para acelerar a execu\u00e7\u00e3o dos programas. Estruturas de controle s\u00e3o essenciais para dividir tarefas entre diferentes threads ou processos.</li> <li>O uso adequado de condicionais pode garantir que as tarefas sejam distribu\u00eddas eficientemente entre os recursos computacionais, evitando sobrecarga em um \u00fanico n\u00f3 de processamento.</li> </ul> </li> <li>Balanceamento de Carga<ul> <li>Estruturas de controle podem ajudar no balanceamento de carga, distribuindo o trabalho de maneira uniforme entre os processadores. Por exemplo, condicionais podem ser usados para verificar a carga de trabalho em diferentes n\u00f3s e ajustar dinamicamente a distribui\u00e7\u00e3o das tarefas.</li> <li>Isso \u00e9 crucial para evitar situa\u00e7\u00f5es onde alguns processadores ficam ociosos enquanto outros est\u00e3o sobrecarregados, maximizando a utiliza\u00e7\u00e3o de recursos e melhorando a performance geral.</li> </ul> </li> <li>Gerenciamento de Recursos<ul> <li>Condicionais e loops podem ser usados para gerenciar recursos, como aloca\u00e7\u00e3o de mem\u00f3ria e acesso a dispositivos de I/O. Em ambientes HPC, onde grandes volumes de dados s\u00e3o manipulados, o gerenciamento eficiente de mem\u00f3ria \u00e9 fundamental. Estruturas de controle podem ajudar a evitar desperd\u00edcio de mem\u00f3ria e garantir que os recursos sejam utilizados de maneira eficiente.</li> </ul> </li> </ol>"},{"location":"Teoria/loops-e-la%C3%A7os/#estruturas-de-controle-condicionais-if-else-if-else","title":"Estruturas de controle condicionais (<code>if</code>, <code>else if</code>, <code>else</code> ):","text":"<p>Exemplo: Encontrar o valor m\u00e1ximo em uma matriz</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Define a vari\u00e1vel max_value com o primeiro valor da matriz\n    int max_value = matrix[0][0];\n\n    // Percorre cada linha da matriz\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Percorre cada coluna da matriz\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Se o valor atual da matriz for maior que max_value, atualiza max_value\n            if (matrix[i][j] &gt; max_value) {\n                max_value = matrix[i][j];\n            }\n        }\n    }\n\n    // Imprime o valor m\u00e1ximo encontrado na matriz\n    std::cout &lt;&lt; \"O valor m\u00e1ximo na matriz \u00e9: \" &lt;&lt; max_value &lt;&lt; std::endl;\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-condicional-switch","title":"Estrutura de controle condicional <code>switch</code> :","text":"<p>Exemplo: Imprimir a posi\u00e7\u00e3o de um n\u00famero espec\u00edfico na matriz</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Define o valor alvo a ser encontrado\n    int target = 5;\n\n    // Percorre cada linha da matriz\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Percorre cada coluna da matriz\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Verifica o valor atual da matriz usando switch\n            switch(matrix[i][j]) {\n                case 5:\n                    // Se o valor for 5, imprime a posi\u00e7\u00e3o e sai do switch\n                    std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" encontrado em: (\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \")\" &lt;&lt; std::endl;\n                    break;\n                default:\n                    // Caso padr\u00e3o do switch, n\u00e3o faz nada\n                    break;\n            }\n        }\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-loop-for","title":"Estrutura de controle loop <code>for</code> :","text":"<p>Exemplo Somar todos os elementos de uma matriz :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Inicializa a vari\u00e1vel sum com 0\n    int sum = 0;\n\n    // Percorre cada linha da matriz\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Percorre cada coluna da matriz\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Adiciona o valor atual da matriz \u00e0 sum\n            sum += matrix[i][j];\n        }\n    }\n\n    // Imprime a soma de todos os elementos na matriz\n    std::cout &lt;&lt; \"A soma de todos os elementos na matriz \u00e9: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-loop-while","title":"Estrutura de controle loop <code>while</code> :","text":"<p>Encontrar um n\u00famero espec\u00edfico na matriz </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    // Define o valor alvo a ser encontrado\n    int target = 5;\n    bool found = false; // Flag para indicar se o valor foi encontrado\n    size_t i = 0; // \u00cdndice para as linhas\n\n    // Loop externo para percorrer as linhas\n    while (i &lt; matrix.size() &amp;&amp; !found) {\n        size_t j = 0; // \u00cdndice para as colunas\n        // Loop interno para percorrer as colunas\n        while (j &lt; matrix[i].size() &amp;&amp; !found) {\n            // Se o valor atual da matriz for igual ao alvo, imprime a posi\u00e7\u00e3o\n            if (matrix[i][j] == target) {\n                std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" encontrado em: (\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \")\" &lt;&lt; std::endl;\n                found = true; // Atualiza a flag\n            }\n            ++j; // Incrementa o \u00edndice das colunas\n        }\n        ++i; // Incrementa o \u00edndice das linhas\n    }\n\n    // Se o valor n\u00e3o foi encontrado, imprime uma mensagem\n    if (!found) {\n        std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" n\u00e3o encontrado na matriz.\" &lt;&lt; std::endl;\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#estrutura-de-controle-loop-do-while","title":"Estrutura de controle loop <code>do-while</code> :","text":"<p>Verificar se todos os elementos da matriz s\u00e3o positivos </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    bool all_positive = true; // Flag para indicar se todos os elementos s\u00e3o positivos\n    size_t i = 0; // \u00cdndice para as linhas\n\n    // Loop externo do-while para percorrer as linhas\n    do {\n        size_t j = 0; // \u00cdndice para as colunas\n        // Loop interno do-while para percorrer as colunas\n        do {\n            // Se o valor atual da matriz for menor ou igual a 0, atualiza a flag e sai do loop\n            if (matrix[i][j] &lt;= 0) {\n                all_positive = false;\n                break;\n            }\n            ++j; // Incrementa o \u00edndice das colunas\n        } while (j &lt; matrix[i].size());\n        ++i; // Incrementa o \u00edndice das linhas\n    } while (i &lt; matrix.size() &amp;&amp; all_positive);\n\n    // Imprime o resultado da verifica\u00e7\u00e3o\n    if (all_positive) {\n        std::cout &lt;&lt; \"Todos os elementos da matriz s\u00e3o positivos.\" &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Nem todos os elementos da matriz s\u00e3o positivos.\" &lt;&lt; std::endl;\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#controladores-de-loop-break","title":"Controladores de loop <code>break</code> :","text":"<p>Interromper a busca ao encontrar um n\u00famero espec\u00edfico (<code>break</code>)</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n\n    int target = 5; // Define o valor alvo a ser encontrado\n    bool found = false; // Flag para indicar se o valor foi encontrado\n\n    // Loop externo para percorrer as linhas\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Loop interno para percorrer as colunas\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Se o valor atual da matriz for igual ao alvo, imprime a posi\u00e7\u00e3o\n            if (matrix[i][j] == target) {\n                std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" encontrado em: (\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \")\" &lt;&lt; std::endl;\n                found = true; // Atualiza a flag\n                break; // Interrompe o loop interno\n            }\n        }\n        if (found) {\n            break; // Interrompe o loop externo\n        }\n    }\n\n    // Se o valor n\u00e3o foi encontrado, imprime uma mensagem\n    if (!found) {\n        std::cout &lt;&lt; \"N\u00famero \" &lt;&lt; target &lt;&lt; \" n\u00e3o encontrado na matriz.\" &lt;&lt; std::endl;\n    }\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/loops-e-la%C3%A7os/#controladores-de-loop-continue","title":"Controladores de loop continue :","text":"<p>Ignorar n\u00fameros negativos ao somar elementos de uma matriz (<code>continue</code>)</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    // Inicializa uma matriz 3x3 com valores inteiros, incluindo n\u00fameros negativos\n    std::vector&lt;std::vector&lt;int&gt;&gt; matrix = {\n        {1, -2, 3},\n        {-4, 5, -6},\n        {7, -8, 9}\n    };\n\n    int sum = 0; // Inicializa a vari\u00e1vel sum com 0\n\n    // Loop externo para percorrer as linhas\n    for (size_t i = 0; i &lt; matrix.size(); ++i) {\n        // Loop interno para percorrer as colunas\n        for (size_t j = 0; j &lt; matrix[i].size(); ++j) {\n            // Se o valor atual da matriz for negativo, ignora-o e continua para a pr\u00f3xima itera\u00e7\u00e3o\n            if (matrix[i][j] &lt; 0) {\n                continue; // Ignora n\u00fameros negativos\n            }\n            // Adiciona o valor atual da matriz \u00e0 soma\n            sum += matrix[i][j];\n        }\n    }\n\n    // Imprime a soma de todos os elementos positivos na matriz\n    std::cout &lt;&lt; \"A soma de todos os elementos positivos na matriz \u00e9: \" &lt;&lt; sum &lt;&lt; std::endl;\n\n    return 0; // Termina o programa\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/","title":"Manipula\u00e7\u00e3o de Vetores","text":"<p>Manipula\u00e7\u00e3o b\u00e1sica de vetores em C++ envolve opera\u00e7\u00f5es comuns como inicializa\u00e7\u00e3o, acesso a elementos, modifica\u00e7\u00e3o, itera\u00e7\u00e3o, inser\u00e7\u00e3o, remo\u00e7\u00e3o, e c\u00f3pia de vetores. Esses conceitos s\u00e3o fundamentais, pois constituem a base para a manipula\u00e7\u00e3o de dados em grande escala.</p>"},{"location":"Teoria/manipulacao-vetores/#inicializacao-de-vetores-declaracao-e-inicializacao","title":"Inicializa\u00e7\u00e3o de Vetores \u2192 Declara\u00e7\u00e3o e Inicializa\u00e7\u00e3o","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec1;                // Declara um vetor vazio de inteiros\n    std::vector&lt;int&gt; vec2(10);            // Declara um vetor de 10 inteiros inicializados com zero\n    std::vector&lt;int&gt; vec3(10, 5);         // Declara um vetor de 10 inteiros, todos inicializados com 5\n\n    // Exemplo de inicializa\u00e7\u00e3o de vetor com valores espec\u00edficos\n    std::vector&lt;int&gt; vec4 = {1, 2, 3, 4, 5};\n\n    // Imprime os elementos do vetor vec4\n    for (int val : vec4) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#acesso-e-modificacao-de-elementos","title":"Acesso e Modifica\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Acessa elementos usando o operador []\n    std::cout &lt;&lt; \"Primeiro elemento: \" &lt;&lt; vec[0] &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Terceiro elemento: \" &lt;&lt; vec[2] &lt;&lt; std::endl;\n\n    // Acessa elementos usando o m\u00e9todo at()\n    std::cout &lt;&lt; \"Segundo elemento: \" &lt;&lt; vec.at(1) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#modificacao-de-elementos","title":"Modifica\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Modifica elementos usando o operador []\n    vec[0] = 10;\n    vec[2] = 30;\n\n    // Modifica elementos usando o m\u00e9todo at()\n    vec.at(1) = 20;\n\n    // Imprime os elementos modificados\n    for (int val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#iteracao-usando-loop","title":"Itera\u00e7\u00e3o Usando Loop","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Itera sobre os elementos usando um loop tradicional\n    for (size_t i = 0; i &lt; vec.size(); ++i) {\n        std::cout &lt;&lt; vec[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#insercao-de-elementos","title":"Inser\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Insere elementos no final do vetor\n    vec.push_back(6);\n    vec.push_back(7);\n\n    // Insere um elemento na posi\u00e7\u00e3o espec\u00edfica\n    vec.insert(vec.begin() + 2, 10); // Insere o valor 10 na terceira posi\u00e7\u00e3o\n\n    // Imprime os elementos ap\u00f3s a inser\u00e7\u00e3o\n    for (int val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#remocao-de-elementos","title":"Remo\u00e7\u00e3o de Elementos","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\n\n    // Remove o \u00faltimo elemento\n    vec.pop_back();\n\n    // Remove um elemento na posi\u00e7\u00e3o espec\u00edfica\n    vec.erase(vec.begin() + 1); // Remove o segundo elemento\n\n    // Imprime os elementos ap\u00f3s a remo\u00e7\u00e3o\n    for (int val : vec) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#copiando-vetores","title":"Copiando Vetores","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; vec1 = {1, 2, 3, 4, 5};\n\n    // Cria uma c\u00f3pia de vec1\n    std::vector&lt;int&gt; vec2 = vec1;\n\n    // Modifica a c\u00f3pia\n    vec2[0] = 10;\n\n    // Imprime os elementos dos dois vetores\n    std::cout &lt;&lt; \"vec1: \";\n    for (int val : vec1) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"vec2: \";\n    for (int val : vec2) {\n        std::cout &lt;&lt; val &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#contextos-uteis-para-hpc","title":"Contextos \u00dateis para HPC","text":"<p>Manipula\u00e7\u00f5es b\u00e1sicas de vetores s\u00e3o frequentemente utilizadas em HPC para inicializar e processar grandes conjuntos de dados. Aqui est\u00e3o alguns contextos \u00fateis:</p> <ol> <li>Inicializa\u00e7\u00e3o de Dados:<ul> <li>Vetores podem ser usados para armazenar dados de entrada para simula\u00e7\u00f5es ou c\u00e1lculos.</li> </ul> </li> <li>Opera\u00e7\u00f5es em S\u00e9rie:<ul> <li>Aplicar opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas em todos os elementos de um vetor \u00e9 uma tarefa comum em HPC.</li> </ul> </li> <li>Armazenamento de Resultados Intermedi\u00e1rios:<ul> <li>Vetores s\u00e3o \u00fateis para armazenar resultados intermedi\u00e1rios em algoritmos iterativos.</li> </ul> </li> </ol>"},{"location":"Teoria/manipulacao-vetores/#exemplo-uso-de-vector-com-classe-e-inline","title":"Exemplo: Uso de <code>Vector</code> com Classe e Inline","text":"<p>A utiliza\u00e7\u00e3o de classes para encapsular a l\u00f3gica de manipula\u00e7\u00e3o de vetores, junto com o uso de aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria e fun\u00e7\u00f5es <code>inline</code>, permite a cria\u00e7\u00e3o de estruturas de dados flex\u00edveis e de alto desempenho. Neste exemplo, implementaremos uma classe <code>Vector</code> que demonstrar\u00e1 esses conceitos.</p>"},{"location":"Teoria/manipulacao-vetores/#conceitos-fundamentais","title":"Conceitos Fundamentais","text":"<p>Aloca\u00e7\u00e3o Din\u00e2mica de Mem\u00f3ria: A aloca\u00e7\u00e3o din\u00e2mica permite que a mem\u00f3ria para o vetor seja alocada em tempo de execu\u00e7\u00e3o, proporcionando flexibilidade na gest\u00e3o do tamanho do vetor. Utilizamos <code>new</code> para alocar mem\u00f3ria e <code>delete[]</code> para liber\u00e1-la, garantindo que o uso de mem\u00f3ria seja eficiente e controlado.</p> <p>Ponteiros: Os ponteiros s\u00e3o utilizados para manipular diretamente a mem\u00f3ria alocada dinamicamente. No nosso exemplo, <code>int* dados</code> \u00e9 um ponteiro para o array que armazenar\u00e1 os elementos do vetor.</p> <p>Fun\u00e7\u00f5es Inline: Fun\u00e7\u00f5es <code>inline</code> s\u00e3o usadas para otimizar o desempenho, especialmente em m\u00e9todos curtos e frequentemente chamados. A declara\u00e7\u00e3o <code>inline</code> sugere ao compilador que expanda o c\u00f3digo da fun\u00e7\u00e3o no local da chamada, reduzindo a sobrecarga de chamadas de fun\u00e7\u00e3o.</p> <p>Redimensionamento Din\u00e2mico: Redimensionar dinamicamente o vetor permite que ele cres\u00e7a conforme necess\u00e1rio. Implementamos um m\u00e9todo que duplica a capacidade do vetor quando necess\u00e1rio, copiando os dados existentes para um novo espa\u00e7o de mem\u00f3ria alocado.</p>"},{"location":"Teoria/manipulacao-vetores/#implementacao-da-classe-vector","title":"Implementa\u00e7\u00e3o da Classe <code>Vector</code>","text":"<p>A seguir, apresentamos a implementa\u00e7\u00e3o detalhada da classe <code>Vector</code>, que inclui m\u00e9todos para inicializa\u00e7\u00e3o, acesso, modifica\u00e7\u00e3o, inser\u00e7\u00e3o e remo\u00e7\u00e3o de elementos, al\u00e9m de um m\u00e9todo para redimensionamento din\u00e2mico.</p> <pre><code>#include &lt;iostream&gt;\n\nclass Vector {\npublic:\n    Vector(int tamanho);                  // Construtor que inicializa o vetor\n    ~Vector();                            // Destrutor que libera a mem\u00f3ria alocada\n    void inicializa(int valor);           // M\u00e9todo para inicializar o vetor\n    inline int get(int index) const;      // M\u00e9todo inline para acessar um elemento\n    inline void set(int index, int valor); // M\u00e9todo inline para modificar um elemento\n    void inserir(int index, int valor);   // M\u00e9todo para inserir um elemento\n    void remover(int index);              // M\u00e9todo para remover um elemento\n    void imprime() const;                 // M\u00e9todo para imprimir o vetor\n    inline int tamanho() const;           // M\u00e9todo inline para obter o tamanho do vetor\n\nprivate:\n</code></pre>"},{"location":"Teoria/manipulacao-vetores/#definicao-da-classe-vector","title":"Defini\u00e7\u00e3o da Classe <code>Vector</code>","text":"<p>Vamos adicionar fun\u00e7\u00f5es inline e algumas otimiza\u00e7\u00f5es para melhorar o desempenho onde for poss\u00edvel.</p> <ol> <li>Atributos:<ul> <li><code>int* dados</code>: Ponteiro para o array din\u00e2mico que armazena os elementos do vetor.</li> <li><code>int tam</code>: Tamanho atual do vetor.</li> <li><code>int capacidade</code>: Capacidade m\u00e1xima do vetor antes de precisar redimensionar.</li> </ul> </li> </ol> <pre><code>#include &lt;iostream&gt;\n\nclass Vector {\npublic:\n    Vector(int tamanho);                  // Construtor que inicializa o vetor\n    ~Vector();                            // Destrutor que libera a mem\u00f3ria alocada\n    void inicializa(int valor);           // M\u00e9todo para inicializar o vetor\n    inline int get(int index) const;      // M\u00e9todo inline para acessar um elemento\n    inline void set(int index, int valor); // M\u00e9todo inline para modificar um elemento\n    void inserir(int index, int valor);   // M\u00e9todo para inserir um elemento\n    void remover(int index);              // M\u00e9todo para remover um elemento\n    void imprime() const;                 // M\u00e9todo para imprimir o vetor\n    inline int tamanho() const;           // M\u00e9todo inline para obter o tamanho do vetor\n\nprivate:\n    int* dados;                           // Ponteiro para os dados do vetor\n    int tam;                              // Tamanho atual do vetor\n    int capacidade;                       // Capacidade m\u00e1xima do vetor\n    void redimensiona(int novaCapacidade); // M\u00e9todo para redimensionar o vetor\n};\n</code></pre> <ol> <li> <p>Construtor e Destrutor:</p> <ul> <li> <p><code>Vector(int tamanho)</code>: Inicializa o vetor com o tamanho especificado e aloca mem\u00f3ria dinamicamente.</p> <pre><code>Vector::Vector(int tamanho)\n    : tam(tamanho), capacidade(tamanho), dados(new int[tamanho]) {}\n</code></pre> </li> <li> <p><code>~Vector()</code>: Libera a mem\u00f3ria alocada para evitar vazamentos de mem\u00f3ria.</p> <pre><code>Vector::~Vector() {\n    delete[] dados; // Libera a mem\u00f3ria alocada\n}\n</code></pre> </li> </ul> </li> <li> <p>M\u00e9todos B\u00e1sicos:</p> <ul> <li> <p><code>inicializa(int valor)</code>: Inicializa todos os elementos do vetor com o valor especificado.</p> <pre><code>void Vector::inicializa(int valor) {\n    for (int i = 0; i &lt; tam; ++i) {\n        dados[i] = valor; // Inicializa cada elemento do vetor com o valor especificado\n    }\n}\n</code></pre> </li> <li> <p><code>get(int index) const</code>: M\u00e9todo inline para acessar um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>inline int Vector::get(int index) const {\n    if (index &gt;= 0 &amp;&amp; index &lt; tam) {\n        return dados[index]; // Retorna o elemento na posi\u00e7\u00e3o especificada\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n        return -1; // Valor de erro\n    }\n}\n</code></pre> </li> <li> <p><code>set(int index, int valor)</code>: M\u00e9todo inline para modificar um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>inline void Vector::set(int index, int valor) {\n    if (index &gt;= 0 &amp;&amp; index &lt; tam) {\n        dados[index] = valor; // Modifica o elemento na posi\u00e7\u00e3o especificada\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> </li> <li> <p><code>inserir(int index, int valor)</code>: Insere um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>void Vector::inserir(int index, int valor) {\n    if (index &gt;= 0 &amp;&amp; index &lt;= tam) {\n        if (tam &gt;= capacidade) {\n            redimensiona(2 * capacidade); // Redimensiona o vetor se necess\u00e1rio\n        }\n        for (int i = tam; i &gt; index; --i) {\n            dados[i] = dados[i - 1]; // Move os elementos para a direita\n        }\n        dados[index] = valor; // Insere o novo elemento\n        tam++; // Incrementa o tamanho do vetor\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> </li> </ul> </li> <li> <p><code>remover(int index)</code>: Remove um elemento na posi\u00e7\u00e3o especificada.</p> <pre><code>void Vector::remover(int index) {\n    if (index &gt;= 0 &amp;&amp; index &lt; tam) {\n        for (int i = index; i &lt; tam - 1; ++i) {\n            dados[i] = dados[i + 1]; // Move os elementos para a esquerda\n        }\n        tam--; // Decrementa o tamanho do vetor\n    } else {\n        std::cerr &lt;&lt; \"\u00cdndice fora do intervalo!\" &lt;&lt; std::endl;\n    }\n}\n</code></pre> </li> <li> <p><code>imprime() const</code>: Imprime todos os elementos do vetor.</p> <pre><code>void Vector::imprime() const {\n    for (int i = 0; i &lt; tam; ++i) {\n        std::cout &lt;&lt; dados[i] &lt;&lt; \" \"; // Imprime cada elemento do vetor\n    }\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre> </li> <li> <p><code>tamanho() const</code>: M\u00e9todo inline para obter o tamanho atual do vetor.</p> <pre><code>inline int Vector::tamanho() const {\n    return tam; // Retorna o tamanho atual do vetor\n}\n</code></pre> </li> <li> <p><code>redimensiona(int novaCapacidade)</code>: Redimensiona o vetor para a nova capacidade especificada, alocando nova mem\u00f3ria e copiando os dados existentes.</p> <pre><code>void Vector::redimensiona(int novaCapacidade) {\n    int* novoDados = new int[novaCapacidade]; // Aloca nova mem\u00f3ria\n    for (int i = 0; i &lt; tam; ++i) {\n        novoDados[i] = dados[i]; // Copia os dados antigos\n    }\n    delete[] dados; // Libera a mem\u00f3ria antiga\n    dados = novoDados; // Atualiza o ponteiro para os novos dados\n    capacidade = novaCapacidade; // Atualiza a capacidade do vetor\n}\n</code></pre> </li> </ol>"},{"location":"Teoria/manipulacao-vetores/#uso-da-classe-vector","title":"Uso da Classe <code>Vector</code>","text":"<ol> <li> <p>Inicializa\u00e7\u00e3o e Impress\u00e3o:</p> <ul> <li>Criamos um vetor de tamanho 5 e inicializamos todos os elementos com 0.</li> <li> <p>Imprimimos o vetor inicializado.</p> <pre><code>int main() {\n    Vector vec(5); // Cria um vetor de tamanho 5\n    vec.inicializa(0); // Inicializa todos os elementos com 0\n\n    std::cout &lt;&lt; \"Vetor inicializado: \";\n    vec.imprime(); // Imprime o vetor inicializado\n</code></pre> </li> </ul> </li> <li> <p>Modifica\u00e7\u00e3o:</p> <ul> <li> <p>Modificamos o terceiro elemento para 10 e imprimimos o vetor.</p> <pre><code>    vec.set(2, 10); // Modifica o terceiro elemento para 10\n    std::cout &lt;&lt; \"Ap\u00f3s modificar o terceiro elemento para 10: \";\n    vec.imprime(); // Imprime o vetor ap\u00f3s a modifica\u00e7\u00e3o\n</code></pre> </li> </ul> </li> <li> <p>Inser\u00e7\u00e3o:</p> <ul> <li> <p>Inserimos o valor 20 na terceira posi\u00e7\u00e3o e imprimimos o vetor.</p> <pre><code>    vec.inserir(2, 20); // Insere o valor 20 na terceira posi\u00e7\u00e3o\n    std::cout &lt;&lt; \"Ap\u00f3s inserir 20 na terceira posi\u00e7\u00e3o: \";\n    vec.imprime(); // Imprime o vetor ap\u00f3s a inser\u00e7\u00e3o\n</code></pre> </li> </ul> </li> <li> <p>Remo\u00e7\u00e3o:</p> <ul> <li> <p>Removemos o segundo elemento e imprimimos o vetor.</p> <pre><code>    vec.remover(1); // Remove o segundo elemento\n    std::cout &lt;&lt; \"Ap\u00f3s remover o segundo elemento: \";\n    vec.imprime(); // Imprime o vetor ap\u00f3s a remo\u00e7\u00e3o\n</code></pre> </li> </ul> </li> <li> <p>Tamanho:</p> <ul> <li> <p>Imprimimos o tamanho atual do vetor.</p> <pre><code>    std::cout &lt;&lt; \"Tamanho do vetor: \" &lt;&lt; vec.tamanho() &lt;&lt; std::endl; // Imprime o tamanho do vetor\n\n    return 0;\n}\n</code></pre> </li> </ul> </li> </ol> <p>Neste exemplo, usamos aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria e ponteiros para criar e manipular vetores em C++ usando classes e objetos. Tamb\u00e9m adicionamos fun\u00e7\u00f5es inline para melhorar o desempenho em opera\u00e7\u00f5es comuns como acesso e modifica\u00e7\u00e3o de elementos.</p>"},{"location":"Teoria/memoria-dinamica/","title":"Aloca\u00e7\u00e3o de Mem\u00f3ria Din\u00e2mica","text":"<p>A aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica \u00e9 uma pr\u00e1tica que permite aos programadores alocar e desalocar mem\u00f3ria durante a execu\u00e7\u00e3o do programa. Quando lidamos com grandes volumes de dados e opera\u00e7\u00f5es computacionalmente intensivas, a gest\u00e3o eficiente da mem\u00f3ria \u00e9 crucial para o desempenho e a escalabilidade das aplica\u00e7\u00f5es.</p> <p>Em C++, a mem\u00f3ria din\u00e2mica \u00e9 gerenciada usando os operadores <code>new</code> e <code>delete</code> para alocar e desalocar mem\u00f3ria, respectivamente.</p>"},{"location":"Teoria/memoria-dinamica/#exemplo-1-alocacao-e-manipulacao-de-matrizes-dinamicas","title":"Exemplo 1: Aloca\u00e7\u00e3o e Manipula\u00e7\u00e3o de Matrizes Din\u00e2micas","text":"<p>Vamos considerar um exemplo de aloca\u00e7\u00e3o din\u00e2mica de uma matriz e sua utiliza\u00e7\u00e3o em opera\u00e7\u00f5es de HPC.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main() {\n    int N = 1000; // Tamanho da matriz\n\n    // Aloca mem\u00f3ria para uma matriz din\u00e2mica\n    int** matriz = new int*[N];\n    for (int i = 0; i &lt; N; ++i) {\n        matriz[i] = new int[N];\n    }\n\n    // Inicializa a matriz com valores\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            matriz[i][j] = i + j;\n        }\n    }\n\n    // Realiza uma opera\u00e7\u00e3o de soma simples na matriz\n    auto inicio = high_resolution_clock::now();\n    long long soma = 0;\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            soma += matriz[i][j];\n        }\n    }\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Soma de todos os elementos: \" &lt;&lt; soma &lt;&lt; endl;\n    cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    // Libera a mem\u00f3ria alocada para a matriz\n    for (int i = 0; i &lt; N; ++i) {\n        delete[] matriz[i];\n    }\n    delete[] matriz;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/memoria-dinamica/#alocacao-da-matriz","title":"Aloca\u00e7\u00e3o da Matriz:","text":"<ul> <li><code>int** matriz = new int*[N];</code> aloca mem\u00f3ria para um array de ponteiros.</li> <li>O loop <code>for</code> interno aloca mem\u00f3ria para cada linha da matriz.</li> <li>Inicializa\u00e7\u00e3o e Opera\u00e7\u00f5es:<ul> <li>A matriz \u00e9 inicializada com a soma dos \u00edndices.</li> <li>Realiza uma opera\u00e7\u00e3o de soma em todos os elementos da matriz, medindo o tempo de execu\u00e7\u00e3o.</li> </ul> </li> <li>Desaloca\u00e7\u00e3o da Mem\u00f3ria:<ul> <li>A mem\u00f3ria alocada para cada linha \u00e9 liberada usando <code>delete[]</code>.</li> <li>A mem\u00f3ria alocada para o array de ponteiros \u00e9 liberada usando <code>delete[]</code>.</li> </ul> </li> </ul>"},{"location":"Teoria/memoria-dinamica/#alocacao-de-memoria-com-stdvector","title":"Aloca\u00e7\u00e3o de Mem\u00f3ria com <code>std::vector</code>","text":"<p>Usar <code>std::vector</code> \u00e9 uma alternativa eficiente e segura para a aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica manual em C++. <code>std::vector</code> gerencia automaticamente a mem\u00f3ria, reduzindo o risco de vazamentos de mem\u00f3ria e outros erros.</p>"},{"location":"Teoria/memoria-dinamica/#exemplo-com-stdvector","title":"Exemplo com <code>std::vector</code>","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main() {\n    int N = 1000; // Tamanho da matriz\n\n    // Aloca mem\u00f3ria para uma matriz din\u00e2mica usando std::vector\n    vector&lt;vector&lt;int&gt;&gt; matriz(N, vector&lt;int&gt;(N));\n\n    // Inicializa a matriz com valores\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            matriz[i][j] = i + j;\n        }\n    }\n\n    // Realiza uma opera\u00e7\u00e3o de soma simples na matriz\n    auto inicio = high_resolution_clock::now();\n    long long soma = 0;\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            soma += matriz[i][j];\n        }\n    }\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Soma de todos os elementos: \" &lt;&lt; soma &lt;&lt; endl;\n    cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/memoria-dinamica/#consideracoes-de-desempenho-em-hpc","title":"Considera\u00e7\u00f5es de Desempenho em HPC","text":"<ol> <li>Localidade de Dados:<ul> <li>A localidade de refer\u00eancia \u00e9 importante para o desempenho da cache. Matrizes alocadas dinamicamente podem ter menor localidade de refer\u00eancia do que matrizes est\u00e1ticas ou <code>std::vector</code>, especialmente se cada linha for alocada separadamente.</li> </ul> </li> <li>Fragmenta\u00e7\u00e3o de Mem\u00f3ria:<ul> <li>A aloca\u00e7\u00e3o din\u00e2mica pode levar \u00e0 fragmenta\u00e7\u00e3o de mem\u00f3ria, especialmente se a mem\u00f3ria for alocada e desalocada frequentemente. Isso pode ser mitigado usando pools de mem\u00f3ria ou alocadores personalizados.</li> </ul> </li> <li>Parallelismo:<ul> <li>Aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica pode introduzir sobrecarga em ambientes paralelos devido \u00e0 necessidade de sincroniza\u00e7\u00e3o. Em HPC, \u00e9 comum usar t\u00e9cnicas avan\u00e7adas para gerenciar a aloca\u00e7\u00e3o de mem\u00f3ria de forma eficiente em ambientes paralelos.</li> </ul> </li> </ol> <p>A aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica \u00e9 uma pr\u00e1tica fundamental em C++ que permite gerenciar a mem\u00f3ria de forma flex\u00edvel durante a execu\u00e7\u00e3o do programa. No contexto de HPC, a gest\u00e3o eficiente da mem\u00f3ria \u00e9 crucial para o desempenho e a escalabilidade das aplica\u00e7\u00f5es. Usar t\u00e9cnicas como aloca\u00e7\u00e3o manual com <code>new</code> e <code>delete</code> ou aloca\u00e7\u00e3o autom\u00e1tica com <code>std::vector</code> pode ajudar a escrever c\u00f3digo eficiente e seguro.</p>"},{"location":"Teoria/profiling/","title":"Profiling","text":"<p>Profiling \u00e9 o processo de medir o comportamento de um programa em termos de consumo de recursos, como tempo de execu\u00e7\u00e3o, uso de CPU, mem\u00f3ria e I/O. As informa\u00e7\u00f5es coletadas durante o profiling ajudam a identificar \"gargalos\" ou partes do c\u00f3digo que s\u00e3o ineficientes.</p> <p>Use o Cluster Franky</p> <pre><code>Acessando o terminal dele via ssh com o comando ssh nome_da_pasta@ip_do_cluster\n</code></pre> <p>ficou com d\u00favida?</p>"},{"location":"Teoria/profiling/#ferramentas-para-profiling-em-c","title":"Ferramentas para Profiling em C++","text":"<p>gprof: O gprof (GNU Profiler) \u00e9 uma ferramenta de profiling que faz parte do GNU Compiler Collection (GCC). Ele \u00e9 usado para medir o tempo de execu\u00e7\u00e3o gasto em cada fun\u00e7\u00e3o de um programa e criar um relat\u00f3rio detalhado de como esse tempo \u00e9 distribu\u00eddo entre as v\u00e1rias partes do c\u00f3digo. O gprof \u00e9 \u00fatil para identificar \"gargalos\" de desempenho em um programa, onde otimiza\u00e7\u00f5es podem ser mais eficazes.</p> <p>Valgrind: O Valgrind \u00e9 uma su\u00edte de ferramentas que ajuda a encontrar bugs de mem\u00f3ria e a realizar profiling de programas,tamb\u00e9m \u00e9 usado para medir o desempenho do programa em termos de uso de CPU.</p>"},{"location":"Teoria/profiling/#exemplo-1-usando-gprof","title":"Exemplo 1: Usando <code>gprof</code>","text":"<p>Vamos come\u00e7ar com um exemplo b\u00e1sico de como usar o <code>gprof</code>.</p>"},{"location":"Teoria/profiling/#codigo-de-exemplo-em-c","title":"C\u00f3digo de Exemplo em C++","text":"<p>O c\u00f3digo exemplo mult_matriz.cpp realiza uma opera\u00e7\u00e3o de multiplica\u00e7\u00e3o de matrizes. Ele multiplica duas matrizes  A  e  B  e armazena o resultado na matriz C.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid multiplyMatrices(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; C) {\n    int n = A.size();\n    for (int i = 0; i &lt; n; ++i) {\n        for (int j = 0; j &lt; n; ++j) {\n            C[i][j] = 0;\n            for (int k = 0; k &lt; n; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int n = 100;\n    std::vector&lt;std::vector&lt;int&gt;&gt; A(n, std::vector&lt;int&gt;(n, 1));\n    std::vector&lt;std::vector&lt;int&gt;&gt; B(n, std::vector&lt;int&gt;(n, 2));\n    std::vector&lt;std::vector&lt;int&gt;&gt; C(n, std::vector&lt;int&gt;(n, 0));\n\n    multiplyMatrices(A, B, C);\n\n    std::cout &lt;&lt; \"Matrix multiplication completed.\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/profiling/#compilacao-com-suporte-a-profiling","title":"Compila\u00e7\u00e3o com Suporte a Profiling","text":"<p>Para usar o <code>gprof</code>, precisamos compilar o c\u00f3digo com a flag <code>-pg</code>, que habilita o suporte ao profiling:</p> <pre><code>g++ -pg mult_matriz.cpp -o mult_matriz\n</code></pre>"},{"location":"Teoria/profiling/#executando-o-programa","title":"Executando o Programa","text":"<p>Depois de compilar, execute o programa normalmente:</p> <pre><code>./mult_matriz\n</code></pre> <p>Essa execu\u00e7\u00e3o vai gerar um arquivo chamado <code>gmon.out</code>, que cont\u00e9m os dados de profiling.</p>"},{"location":"Teoria/profiling/#analisando-os-dados-com-gprof","title":"Analisando os Dados com <code>gprof</code>","text":"<p>Agora, use o <code>gprof</code> para analisar os dados:</p> <pre><code>gprof mult_matriz gmon.out &gt; analise.txt\n</code></pre> <p>Isso cria um relat\u00f3rio detalhado do tempo gasto em cada fun\u00e7\u00e3o e a quantidade de chamadas feitas. O relat\u00f3rio ser\u00e1 salvo no arquivo <code>analise.txt</code>.</p>"},{"location":"Teoria/profiling/#entendendo-o-relatorio-de-profiling","title":"Entendendo o Relat\u00f3rio de Profiling","text":"<p>Ap\u00f3s executar o seu programa com <code>gprof</code>, voc\u00ea obter\u00e1 um relat\u00f3rio que cont\u00e9m duas se\u00e7\u00f5es principais: o Flat Profile e o Call Graph. Vamos explorar o significado de cada uma e como interpret\u00e1-las.</p>"},{"location":"Teoria/profiling/#flat-profile-identificando-as-funcoes-criticas","title":"Flat Profile: Identificando as Fun\u00e7\u00f5es Cr\u00edticas","text":"<p>O Flat Profile fornece uma vis\u00e3o geral do tempo que cada fun\u00e7\u00e3o consome durante a execu\u00e7\u00e3o do programa. Aqui est\u00e3o os principais elementos do relat\u00f3rio:</p> <ul> <li> <p>% time: Indica a porcentagem do tempo total de execu\u00e7\u00e3o que foi gasto em cada fun\u00e7\u00e3o. Fun\u00e7\u00f5es com valores mais altos s\u00e3o geralmente os principais alvos para otimiza\u00e7\u00e3o.</p> </li> <li> <p>cumulative seconds: \u00c9 o tempo acumulado at\u00e9 essa fun\u00e7\u00e3o ser chamada. Ele ajuda a entender quanto tempo foi gasto no programa at\u00e9 aquele ponto.</p> </li> <li> <p>self seconds: \u00c9 ao tempo gasto exclusivamente dentro da fun\u00e7\u00e3o, sem incluir o tempo das fun\u00e7\u00f5es que ela chama.</p> </li> <li> <p>calls: Mostra quantas vezes a fun\u00e7\u00e3o foi chamada. Fun\u00e7\u00f5es chamadas muitas vezes podem ser boas candidatas para otimiza\u00e7\u00e3o, especialmente se tiverem um tempo significativo por chamada.</p> </li> <li> <p>self ms/call e total ms/call: Esses valores mostram o tempo m\u00e9dio gasto em cada chamada da fun\u00e7\u00e3o. <code>self ms/call</code> \u00e9 o tempo gasto na pr\u00f3pria fun\u00e7\u00e3o, enquanto <code>total ms/call</code> inclui o tempo das fun\u00e7\u00f5es que ela invoca.</p> </li> </ul>"},{"location":"Teoria/profiling/#call-graph-compreendendo-as-relacoes-entre-funcoes","title":"Call Graph: Compreendendo as Rela\u00e7\u00f5es Entre Fun\u00e7\u00f5es","text":"<p>O Call Graph mostra a hierarquia de chamadas entre as fun\u00e7\u00f5es do seu programa. Ele detalha como as fun\u00e7\u00f5es est\u00e3o interconectadas e qual o impacto de cada uma no tempo de execu\u00e7\u00e3o total.</p> <ul> <li> <p>Self/Children Time: O tempo \"Self\" \u00e9 o gasto na pr\u00f3pria fun\u00e7\u00e3o, enquanto o tempo \"Children\" \u00e9 o gasto nas fun\u00e7\u00f5es que ela chama.</p> </li> <li> <p>Called: Informa quantas vezes uma fun\u00e7\u00e3o foi chamada, seja diretamente ou indiretamente por outras fun\u00e7\u00f5es.</p> </li> </ul>"},{"location":"Teoria/profiling/#analise-do-relatorio-de-profiling","title":"An\u00e1lise do Relat\u00f3rio de Profiling","text":"<p>No relat\u00f3rio gerado, as fun\u00e7\u00f5es relacionadas ao operador <code>operator[]</code> do <code>std::vector</code> aparecem como cr\u00edticas, consumindo cerca de 33% do tempo de execu\u00e7\u00e3o cada. Isso indica que a maneira como os vetores s\u00e3o acessados e manipulados no c\u00f3digo esta consumindo bastante tempo.</p> <p>Al\u00e9m disso, a fun\u00e7\u00e3o <code>multiplyMatrices</code> aparece com um tempo de execu\u00e7\u00e3o acumulado consider\u00e1vel. Como esta fun\u00e7\u00e3o realiza o trabalho pesado da multiplica\u00e7\u00e3o de matrizes, \u00e9 natural que ela seja um foco de aten\u00e7\u00e3o para otimiza\u00e7\u00e3o.</p>"},{"location":"Teoria/profiling/#oportunidades-de-otimizacao","title":"Oportunidades de Otimiza\u00e7\u00e3o","text":"<p>Com base no relat\u00f3rio, os poss\u00edveis candidatos a otimiza\u00e7\u00e3o s\u00e3o:</p> <ul> <li> <p>Reduzir Acessos ao Vetor: Como o acesso aos elementos do vetor (<code>operator[]</code>) consome uma parte significativa do tempo de execu\u00e7\u00e3o, podemos tentar reduzir o n\u00famero de acessos diretos ao vetor. </p> </li> <li> <p>Otimizar a Fun\u00e7\u00e3o <code>multiplyMatrices</code>: Esta fun\u00e7\u00e3o \u00e9 o cora\u00e7\u00e3o do processamento e qualquer melhoria aqui ter\u00e1 um grande impacto no desempenho global. Podemos pensar em paralelizar a fun\u00e7\u00e3o para distribuir o trabalho entre m\u00faltiplos n\u00facleos ou m\u00e1quinas, em um ambiente HPC como o Cluster Franky.</p> </li> </ul>"},{"location":"Teoria/profiling/#exemplo-2-usando-valgrind-para-profiling-de-memoria","title":"Exemplo 2: Usando Valgrind para Profiling de Mem\u00f3ria","text":"<p>O Valgrind tem um conjunto de ferramentas para an\u00e1lise de programas. Uma de suas funcionalidades mais conhecidas \u00e9 a detec\u00e7\u00e3o de problemas de mem\u00f3ria, mas tamb\u00e9m pode ser usado para profiling de CPU.</p> <p>Vamos usar o mesmo c\u00f3digo de multiplica\u00e7\u00e3o de matrizes do exemplo anterior.</p>"},{"location":"Teoria/profiling/#usando-o-valgrind-para-detectar-problemas-de-memoria","title":"Usando o Valgrind para Detectar Problemas de Mem\u00f3ria","text":"<p>Primeiro, compile o c\u00f3digo normalmente, sem flags especiais:</p> <pre><code>g++ mult_matriz.cpp -o mult_matriz\n</code></pre> <p>Agora, execute o programa usando o Valgrind para detectar problemas de mem\u00f3ria:</p> <pre><code>valgrind --leak-check=full ./mult_matriz\n</code></pre> <p>O Valgrind ir\u00e1 executar o programa e relatar quaisquer vazamentos de mem\u00f3ria ou acessos inv\u00e1lidos.</p> <p>No relat\u00f3rio obtido aqui nos meus testes eu tive os seguintes resultados:</p>"},{"location":"Teoria/profiling/#interpretacao-do-relatorio-valgrind","title":"Interpreta\u00e7\u00e3o do Relat\u00f3rio Valgrind","text":"<ol> <li>HEAP SUMMARY (Resumo da Pilha)</li> <li> <p>in use at exit: 0 bytes in 0 blocks: Isso significa que, ao final da execu\u00e7\u00e3o do programa, n\u00e3o h\u00e1 blocos de mem\u00f3ria alocados que n\u00e3o foram liberados. Ou seja, toda a mem\u00f3ria que foi alocada foi devidamente liberada.</p> </li> <li> <p>total heap usage: 308 allocs, 308 frees, 202,128 bytes allocated: Este campo indica que, ao longo da execu\u00e7\u00e3o do programa, 308 aloca\u00e7\u00f5es de mem\u00f3ria heap ocorreram, e todas as 308 foram correspondidas por uma libera\u00e7\u00e3o. O total de mem\u00f3ria alocada durante o programa foi de 202,128 bytes.</p> </li> <li> <p>All heap blocks were freed -- no leaks are possible</p> </li> <li> <p>Esta linha confirma que todos os blocos de mem\u00f3ria foram liberados corretamente, portanto, n\u00e3o h\u00e1 vazamentos de mem\u00f3ria poss\u00edveis. Isso significa que o gerenciamento de mem\u00f3ria no programa est\u00e1 sendo feito corretamente.</p> </li> <li> <p>ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)</p> </li> <li>Esta parte do relat\u00f3rio informa que n\u00e3o houve nenhum erro de mem\u00f3ria detectado. Isso inclui erros como acessos inv\u00e1lidos, uso de mem\u00f3ria n\u00e3o inicializada, ou acessos fora dos limites. O Valgrind n\u00e3o encontrou nenhum problema relacionado \u00e0 mem\u00f3ria neste programa.</li> </ol>"},{"location":"Teoria/profiling/#usando-o-valgrind-para-profiling-de-cpu-com-callgrind","title":"Usando o Valgrind para Profiling de CPU com <code>callgrind</code>","text":"<p>O Valgrind tamb\u00e9m pode ser usado para profiling de CPU com a ferramenta Callgrind:</p> <pre><code>valgrind --tool=callgrind ./mult_matriz\n</code></pre> <p>Este comando vai resultar em um arquivo de sa\u00edda <code>callgrind.out.&lt;PID&gt;</code>, que cont\u00e9m informa\u00e7\u00f5es detalhadas sobre o uso da CPU por cada fun\u00e7\u00e3o do programa.</p> <p>O relat\u00f3rio que voc\u00ea executou com Callgrind fornece um resumo sobre o desempenho do programa em termos de instru\u00e7\u00f5es executadas. Os elementos principais do relat\u00f3rio s\u00e3o:</p> <ol> <li> <p>Events: Ir: <code>Ir</code> significa \"Instruction References\". Este evento conta o n\u00famero total de instru\u00e7\u00f5es de m\u00e1quina que foram executadas pelo programa. As instru\u00e7\u00f5es de m\u00e1quina s\u00e3o as opera\u00e7\u00f5es mais b\u00e1sicas que a CPU realiza, como somar n\u00fameros, carregar dados da mem\u00f3ria, ou comparar valores. No relat\u00f3rio aqui do meu teste, o valor de <code>Ir</code> \u00e9 128,306,660. Isso significa que o programa executou mais de 128 milh\u00f5es de instru\u00e7\u00f5es durante a multiplica\u00e7\u00e3o de matrizes.</p> </li> <li> <p>Collected: 128,306,660: Este n\u00famero indica que o Callgrind coletou dados sobre todas essas 128 milh\u00f5es de instru\u00e7\u00f5es. \u00c9 uma confirma\u00e7\u00e3o de que todas as instru\u00e7\u00f5es executadas foram monitoradas.</p> </li> <li> <p>I refs: 128,306,660 : <code>I refs</code> \u00e9 uma m\u00e9trica que mostra o n\u00famero total de refer\u00eancias de instru\u00e7\u00e3o que foram feitas durante a execu\u00e7\u00e3o do programa. Como o valor \u00e9 igual ao de <code>Ir</code>, isso indica que cada instru\u00e7\u00e3o foi contabilizada.</p> </li> </ol> <p>O que fazer com essas informa\u00e7\u00f5es?</p> <ul> <li> <p>N\u00famero de Instru\u00e7\u00f5es: Um alto n\u00famero de instru\u00e7\u00f5es (<code>Ir</code>) pode indicar que o programa est\u00e1 realizando muitas opera\u00e7\u00f5es. Em um ambiente HPC, isso pode ser bom ou ruim, dependendo da efici\u00eancia dessas instru\u00e7\u00f5es. Muitas instru\u00e7\u00f5es simples podem ser r\u00e1pidas, enquanto poucas instru\u00e7\u00f5es complexas podem ser mais lentas.</p> </li> <li> <p>Identifica\u00e7\u00e3o de Gargalos: Ao combinar esses dados com outras informa\u00e7\u00f5es, como tempos de execu\u00e7\u00e3o e cache misses (que Callgrind tamb\u00e9m pode monitorar), voc\u00ea pode identificar quais partes do c\u00f3digo consomem mais recursos e otimizar essas \u00e1reas. Por exemplo, se uma fun\u00e7\u00e3o espec\u00edfica estiver gerando um grande n\u00famero de instru\u00e7\u00f5es e utilizando muito cache, ela pode ser um gargalo que precisa ser otimizado.</p> </li> </ul>"},{"location":"Teoria/profiling/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Para uma an\u00e1lise mais detalhada, voc\u00ea pode:</p> <p>Usar o KCachegrind (uma interface gr\u00e1fica) para visualizar o resultado detalhadamente:</p> <pre><code>kcachegrind callgrind.out.&lt;PID&gt;\n</code></pre> <p></p> <p>Como podemos ver na imagem, a fun\u00e7\u00e3o <code>multiplyMatrices</code> est\u00e1 destacada em laranja e consome 97.80% do total de instru\u00e7\u00f5es. Isso indica que a multiplica\u00e7\u00e3o de matrizes \u00e9 a opera\u00e7\u00e3o mais intensiva e cr\u00edtica em termos de desempenho no c\u00f3digo. Como essa fun\u00e7\u00e3o domina o uso de CPU, ela \u00e9 o principal alvo para otimiza\u00e7\u00e3o.</p> <p>As fun\u00e7\u00f5es que manipulam <code>std::vector</code> tamb\u00e9m aparecem com destaque:</p> <p><code>std::vector::operator[]</code>: Consome 18.71% das instru\u00e7\u00f5es. Esse operador \u00e9 chamado cada vez que um elemento do vetor \u00e9 acessado. A alta porcentagem indica que muitos acessos ao vetor est\u00e3o ocorrendo, o que pode ser um ponto de otimiza\u00e7\u00e3o.</p> <p><code>std::vector::allocator</code>: Tamb\u00e9m est\u00e1 destacada, indicando que a aloca\u00e7\u00e3o e acesso aos elementos do vetor \u00e9 um fator importante no uso de recursos.</p>"},{"location":"Teoria/profiling/#comparacao-entre-gprof-e-valgrind","title":"Compara\u00e7\u00e3o entre Gprof e Valgrind","text":"<p>Gprof e Valgrind s\u00e3o ferramentas de profiling, mas com focos e funcionalidades especificas. Na tabela temos uma compara\u00e7\u00e3o detalhada entre essas duas ferramentas:</p> Aspecto Gprof Valgrind Foco Principal Profiling de desempenho, medindo o tempo gasto em fun\u00e7\u00f5es. Detecta erros de uso de mem\u00f3ria e oferece ferramentas de profiling. Uso T\u00edpico Mapear gargalos de desempenho e identificar o tempo de execu\u00e7\u00e3o das fun\u00e7\u00f5es. Detectar vazamentos de mem\u00f3ria, acessos inv\u00e1lidos, e mapear o uso de CPU e mem\u00f3ria. Complexidade Relativamente simples de usar e interpretar, adequado para profiling inicial. Mais complexo, com v\u00e1rias ferramentas especializadas para diferentes tipos de an\u00e1lise. Overhead de Execu\u00e7\u00e3o Baixo overhead; o programa roda quase na velocidade normal. Alto overhead; o programa pode rodar significativamente mais lento devido \u00e0 an\u00e1lise detalhada. An\u00e1lise de Fun\u00e7\u00f5es Oferece relat\u00f3rios de chamadas (Call Graph) e perfis de fun\u00e7\u00f5es para entender o tempo de execu\u00e7\u00e3o. Oferece gr\u00e1ficos de chamadas detalhados com Callgrind, al\u00e9m de perfis de cache e instru\u00e7\u00f5es. Depura\u00e7\u00e3o de Mem\u00f3ria N\u00e3o fornece suporte para debug de mem\u00f3ria. Ferramenta principal para depura\u00e7\u00e3o de mem\u00f3ria, com suporte para detectar vazamentos e erros. Multithreading Suporta an\u00e1lise b\u00e1sica, mas n\u00e3o \u00e9 especializado em detectar race conditions. Helgrind \u00e9 especializado race conditions em programas multithreaded. Integra\u00e7\u00e3o e Uso Parte do GCC, f\u00e1cil de integrar em fluxos de trabalho de compila\u00e7\u00e3o. Requer execu\u00e7\u00e3o com a ferramenta espec\u00edfica e pode necessitar de ajustes no ambiente para uso eficiente. Ambiente de Uso Ideal para profiling em ambientes de desenvolvimento e produ\u00e7\u00e3o. Melhor utilizado em desenvolvimento e testes devido ao overhead; \u00fatil em produ\u00e7\u00e3o para an\u00e1lise pontual."},{"location":"Teoria/profiling/#conclusao","title":"Conclus\u00e3o","text":"<p>Gprof e Valgrind s\u00e3o ferramentas complementares no arsenal de um desenvolvedor:</p> <ul> <li> <p>Gprof \u00e9 uma boa escolha quando o objetivo \u00e9 entender a distribui\u00e7\u00e3o de tempo de execu\u00e7\u00e3o entre as fun\u00e7\u00f5es de um programa. Com seu baixo overhead, \u00e9 ideal para profiling inicial e para identificar rapidamente as \u00e1reas do c\u00f3digo que mais consomem tempo.</p> </li> <li> <p>Valgrind \u00e9 indispens\u00e1vel quando se trata de garantir o bom funcionamento do c\u00f3digo, especialmente em rela\u00e7\u00e3o ao uso de mem\u00f3ria. Embora introduza um overhead significativo, suas ferramentas como Memcheck e Callgrind s\u00e3o essenciais para detectar vazamentos de mem\u00f3ria, acessos inv\u00e1lidos, e para visualizar o desempenho em termos de uso de CPU e cache.</p> </li> </ul> <p>Em ambientes de HPC, usar Gprof para identificar gargalos de desempenho e Valgrind para garantir que o c\u00f3digo esteja livre de erros de mem\u00f3ria e bem otimizado, proporciona uma abordagem robusta para garantir que o software seja tanto r\u00e1pido quanto confi\u00e1vel. </p>"},{"location":"Teoria/slurm/","title":"SLURM","text":""},{"location":"Teoria/slurm/#o-que-e-slurm","title":"O que \u00e9 SLURM?","text":"<p>SLURM (Simple Linux Utility for Resource Management) \u00e9 um gerenciador de workload open-source amplamente utilizado em clusters de computa\u00e7\u00e3o de alto desempenho (HPC). Ele \u00e9 respons\u00e1vel por alocar recursos de computa\u00e7\u00e3o (como CPUs, mem\u00f3ria e GPUs) aos usu\u00e1rios e suas tarefas, gerenciar filas de jobs, monitorar o uso de recursos e agendar a execu\u00e7\u00e3o de tarefas de forma eficiente.</p>"},{"location":"Teoria/slurm/#principais-funcionalidades-do-slurm","title":"Principais Funcionalidades do SLURM","text":"<ol> <li>Aloca\u00e7\u00e3o de Recursos: SLURM distribui recursos de computa\u00e7\u00e3o, como n\u00f3s e processadores, conforme solicitado pelos usu\u00e1rios. Ele assegura que os recursos s\u00e3o utilizados de maneira eficiente e equitativa.</li> <li>Submiss\u00e3o de Jobs: Usu\u00e1rios podem submeter jobs (tarefas de computa\u00e7\u00e3o) ao SLURM, que coloca esses jobs em uma fila e os executa quando os recursos necess\u00e1rios est\u00e3o dispon\u00edveis.</li> <li>Monitoramento e Gerenciamento: SLURM monitoriza o estado dos jobs, n\u00f3s e parti\u00e7\u00f5es do cluster, fornecendo ferramentas para verificar o status e a utiliza\u00e7\u00e3o de recursos.</li> <li>Pol\u00edticas de Prioriza\u00e7\u00e3o: Implementa pol\u00edticas para priorizar jobs com base em v\u00e1rios fatores, como tempo de espera, utiliza\u00e7\u00e3o de recursos e prioridades definidas pelo administrador do cluster.</li> </ol>"},{"location":"Teoria/slurm/#comandos-principais-do-slurm","title":"Comandos Principais do SLURM","text":"<p>Alguns dos comandos principais usados no SLURM:</p> <ol> <li>sbatch: \u00c9 um comando do SLURM usado para submeter scripts de jobs para execu\u00e7\u00e3o em um cluster. Esses scripts cont\u00eam instru\u00e7\u00f5es sobre como os recursos devem ser alocados e quais comandos devem ser executados</li> <li>scancel: Cancela um job pendente ou em execu\u00e7\u00e3o.</li> <li>scontrol: Ferramenta administrativa usada para visualizar e/ou modificar o estado do SLURM. Muitos comandos <code>scontrol</code> s\u00f3 podem ser executados pelo adminstrador do sistema.</li> <li>sinfo: Relata o estado das filas e n\u00f3s gerenciados pelo SLURM, com v\u00e1rias op\u00e7\u00f5es de filtragem, ordena\u00e7\u00e3o e formata\u00e7\u00e3o.</li> <li>sprio: Exibe uma vis\u00e3o detalhada dos componentes que afetam a prioridade de um job.</li> <li>squeue: Relata o estado dos jobs em execu\u00e7\u00e3o em ordem de prioridade e depois os jobs pendentes em ordem de prioridade.</li> <li>srun: Submete um job para execu\u00e7\u00e3o e faz o pedido de aloca\u00e7\u00e3o dos recursos da maquina.</li> <li>strigger: Define, obt\u00e9m ou visualiza gatilhos de eventos, como n\u00f3s caindo ou jobs se aproximando do limite de tempo.</li> </ol>"},{"location":"Teoria/slurm/#exemplos-de-uso-para-cada-comando-slurm","title":"Exemplos de Uso para Cada Comando SLURM","text":""},{"location":"Teoria/slurm/#1-sbatch","title":"1. sbatch","text":"<p>Submete scripts de jobs para execu\u00e7\u00e3o em um cluster. Esses scripts cont\u00eam instru\u00e7\u00f5es sobre como os recursos devem ser alocados e quais comandos devem ser executados.</p> <p>Exemplo de Script:</p> <pre><code>#!/bin/bash\n#SBATCH --job-name=meu_job        # Nome do job\n#SBATCH --output=meu_job.out      # Arquivo de sa\u00edda\n#SBATCH --error=meu_job.err       # Arquivo de erro\n#SBATCH --ntasks=1                # N\u00famero de tarefas\n#SBATCH --cpus-per-task=4         # N\u00famero de CPUs por tarefa\n#SBATCH --mem=4G                  # Mem\u00f3ria total alocada para o job\n#SBATCH --time=00:02:00           # Tempo m\u00e1ximo de execu\u00e7\u00e3o (hh:mm:ss)\n#SBATCH --partition=normal        # Fila do cluster\n\necho \"Iniciando o job\"\nsleep 60\necho \"Job finalizado\"\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>-job-name=meu_job</code>: Define o nome do job como <code>meu_job</code>.</p> <p><code>-output=meu_job.out</code>: Especifica o arquivo onde a sa\u00edda padr\u00e3o do job ser\u00e1 registrada.</p> <p><code>-error=meu_job.err</code>: Especifica o arquivo onde os erros ser\u00e3o registrados.</p> <p><code>-ntasks=1</code>: Define o n\u00famero de tarefas (processos) a serem utilizados pelo job.</p> <p><code>-cpus-per-task=4</code>: Aloca 4 CPUs para cada tarefa.</p> <p><code>-mem=4G</code>: Especifica que 4 GB de mem\u00f3ria ser\u00e3o alocados para o job.</p> <p><code>-time=00:02:00</code>: Define o tempo m\u00e1ximo de execu\u00e7\u00e3o do job como 2 minutos.</p> <p><code>-partition=normal</code>: Especifica a fila do cluster onde o job ser\u00e1 executado.</p>"},{"location":"Teoria/slurm/#2-scancel","title":"2. scancel","text":"<p>Cancela um job pendente ou em execu\u00e7\u00e3o.</p> <p>Exemplo:</p> <pre><code>scancel 12345\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <ul> <li><code>12345</code>: Especifica o ID do job que deve ser cancelado.</li> </ul>"},{"location":"Teoria/slurm/#3-scontrol","title":"3. scontrol","text":"<p>Ferramenta administrativa usada para visualizar e/ou modificar o estado do SLURM. Muitos comandos <code>scontrol</code> s\u00f3 podem ser executados pelo administrador do sistema.</p> <p>Exemplo:</p> <pre><code>scontrol show job 12345\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>show job 12345</code>: Exibe informa\u00e7\u00f5es detalhadas sobre o job com ID <code>12345</code>.</p>"},{"location":"Teoria/slurm/#4-sinfo","title":"4. sinfo","text":"<p>Relata o estado das filas e n\u00f3s gerenciados pelo SLURM.</p> <p>Exemplo:</p> <pre><code>sinfo\n</code></pre>"},{"location":"Teoria/slurm/#5-sprio","title":"5. sprio","text":"<p>Exibe uma vis\u00e3o detalhada dos componentes que afetam a prioridade de um job.</p> <p>Exemplo:</p> <pre><code>sprio\n</code></pre>"},{"location":"Teoria/slurm/#6-squeue","title":"6. squeue","text":"<p>Relata o estado dos jobs em execu\u00e7\u00e3o em ordem de prioridade e depois os jobs pendentes em ordem de prioridade.</p> <p>Exemplo:</p> <pre><code>squeue -u username\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>u username</code>: Filtra a sa\u00edda para mostrar apenas os jobs do usu\u00e1rio <code>username</code>.</p>"},{"location":"Teoria/slurm/#7-srun","title":"7. srun","text":"<p>Submete um job para execu\u00e7\u00e3o e faz o pedido de aloca\u00e7\u00e3o dos recursos da m\u00e1quina.</p> <p>Exemplo:</p> <pre><code>srun -N 1 -n 1 --time=00:01:00 ./meu_programa\n</code></pre> <p>Explica\u00e7\u00e3o das Flags:</p> <p><code>N 1</code>: Especifica que 1 n\u00f3 deve ser alocado.</p> <p><code>n 1</code>: Define que 1 tarefa deve ser executadas.</p> <p><code>-time=00:01:00</code>: Define o tempo m\u00e1ximo de execu\u00e7\u00e3o do job como 1 minuto.</p> <p><code>./meu_programa</code>: Especifica o programa a ser executado.</p>"},{"location":"Teoria/slurm/#9-strigger","title":"9. strigger","text":"<p>Define, obt\u00e9m ou visualiza gatilhos de eventos, como n\u00f3s caindo ou jobs se aproximando do limite de tempo.</p> <p>Exemplo: Vamos supor que voc\u00ea queira configurar um gatilho (<code>strigger</code>) para monitorar o uso de mem\u00f3ria de um job espec\u00edfico e enviar um alerta quando o uso de mem\u00f3ria ultrapassar um certo limite. Aqui est\u00e1 um exemplo completo:</p> <pre><code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=500 --action=\"echo 'Aten\u00e7\u00e3o: O uso de mem\u00f3ria ultrapassou 500 MB!'\"\n</code></pre>"},{"location":"Teoria/slurm/#explicacao-do-comando","title":"Explica\u00e7\u00e3o do Comando:","text":"<p><code>strigger</code>: Comando para configurar um gatilho no SLURM.</p> <p><code>--set</code>: Indica que estamos criando um novo gatilho.</p> <p><code>--jobid=&lt;JOB_ID&gt;</code>: Especifica o ID do job que queremos monitorar. Substitua <code>&lt;JOB_ID&gt;</code> pelo ID real do job.</p> <p><code>--threshold=500</code>: Define o limiar de 500 MB de uso de mem\u00f3ria. Quando o job usar mais de 500 MB, o gatilho ser\u00e1 ativado.</p> <p><code>--action=\"echo 'Aten\u00e7\u00e3o: O uso de mem\u00f3ria ultrapassou 500 MB!'\"</code>: Define a a\u00e7\u00e3o que ser\u00e1 executada quando o gatilho for ativado. Neste caso, a a\u00e7\u00e3o \u00e9 um simples comando <code>echo</code> que imprime uma mensagem de alerta.</p> <p>Este gatilho ser\u00e1 acionado quando o job especificado pelo <code>&lt;JOB_ID&gt;</code> ultrapassar 500 MB de uso de mem\u00f3ria. A a\u00e7\u00e3o definida (<code>echo</code>) ser\u00e1 executada, e voc\u00ea ver\u00e1 a mensagem \"Aten\u00e7\u00e3o: O uso de mem\u00f3ria ultrapassou 500 MB!\" no terminal ou no arquivo de sa\u00edda do job.</p> <p>Voc\u00ea pode personalizar o comando <code>strigger</code> para outras situa\u00e7\u00f5es, como monitorar o tempo restante de um job, detectar falhas de n\u00f3s, ou monitorar o uso de CPU, simplesmente ajustando os par\u00e2metros e as a\u00e7\u00f5es conforme necess\u00e1rio.</p>"},{"location":"Teoria/slurm/#tipos-comuns-de-eventos-monitoraveis-pelo-strigger","title":"Tipos Comuns de Eventos Monitor\u00e1veis pelo <code>strigger</code>:","text":"<p>Tempo Restante (<code>TIME_LIMIT</code>):</p> <p>Aciona o gatilho quando um job se aproxima de seu limite de tempo de execu\u00e7\u00e3o.</p> <p>Uso do <code>--threshold</code>: Especifica o tempo restante em segundos.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=60 --action=\"echo 'Job est\u00e1 a 60 segundos do limite de tempo!'\"</code></p> <p>Uso de Mem\u00f3ria (<code>MEMORY</code>):</p> <p>Aciona o gatilho quando o uso de mem\u00f3ria de um job ultrapassa um certo limite.</p> <p>Uso do <code>--threshold</code>: Especifica a quantidade de mem\u00f3ria usada, geralmente em megabytes (MB).</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=1024 --action=\"echo 'Job ultrapassou 1GB de mem\u00f3ria!'\"</code></p> <p>Falha de N\u00f3 (<code>NODE_FAIL</code>):</p> <p>Aciona o gatilho quando um n\u00f3 falha ou fica indispon\u00edvel.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de falha ocorre.</p> <p>Exemplo: <code>strigger --set --node=&lt;NODE_NAME&gt; --event=NODE_FAIL --action=\"echo 'N\u00f3 falhou!'\"</code></p> <p>Falha de Job (<code>JOB_FAIL</code>):</p> <p>Aciona o gatilho quando um job falha por qualquer motivo.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de falha ocorre.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=JOB_FAIL --action=\"echo 'Job falhou!'\"</code></p> <p>In\u00edcio de Job (<code>JOB_START</code>):</p> <p>Aciona o gatilho quando um job come\u00e7a a ser executado.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de in\u00edcio ocorre.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=JOB_START --action=\"echo 'Job iniciou!'\"</code></p> <p>Finaliza\u00e7\u00e3o de Job (<code>JOB_END</code>):</p> <p>Aciona o gatilho quando um job termina sua execu\u00e7\u00e3o, independentemente de ter sido conclu\u00eddo com sucesso ou n\u00e3o.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de finaliza\u00e7\u00e3o ocorre.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=JOB_END --action=\"echo 'Job terminou!'\"</code></p> <p>Limite de CPU (<code>CPU_LIMIT</code>):</p> <p>Aciona o gatilho quando o uso de CPU de um job ultrapassa um certo limite.</p> <p>Uso do <code>--threshold</code>: Especifica o uso de CPU em segundos de CPU ou em porcentagem.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=80 --action=\"echo 'Job ultrapassou 80% do uso de CPU!'\"</code></p> <p>Submiss\u00e3o de Job (<code>JOB_SUBMIT</code>):</p> <p>Aciona o gatilho quando um job \u00e9 submetido para execu\u00e7\u00e3o.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de submiss\u00e3o ocorre.</p> <p>Exemplo: <code>strigger --set --user=&lt;USER_NAME&gt; --event=JOB_SUBMIT --action=\"echo 'Um job foi submetido!'\"</code></p> <p>Queda de Parti\u00e7\u00e3o (<code>PARTITION_DOWN</code>):</p> <p>Aciona o gatilho quando uma parti\u00e7\u00e3o inteira do cluster cai ou fica indispon\u00edvel.</p> <p>Uso do <code>--threshold</code>: N\u00e3o aplic\u00e1vel diretamente. O gatilho \u00e9 acionado quando o evento de queda da parti\u00e7\u00e3o ocorre.</p> <p>Exemplo: <code>strigger --set --partition=&lt;PARTITION_NAME&gt; --event=PARTITION_DOWN --action=\"echo 'Parti\u00e7\u00e3o caiu!'\"</code></p> <p>Chegada de Job ao Limiar de Tempo (<code>TIME_LIM_REACHED</code>):</p> <p>Similar ao <code>TIME_LIMIT</code>, mas pode ser mais espec\u00edfico para quando o tempo limite \u00e9 alcan\u00e7ado, n\u00e3o apenas quando est\u00e1 pr\u00f3ximo.</p> <p>Uso do <code>--threshold</code>: Especifica o tempo restante ou o evento do tempo limite.</p> <p>Exemplo: <code>strigger --set --jobid=&lt;JOB_ID&gt; --event=TIME_LIM_REACHED --action=\"echo 'Tempo limite alcan\u00e7ado!'\"</code></p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/","title":"Sobrecarga de Fun\u00e7\u00f5es em C++","text":"<p>Sobrecarga de fun\u00e7\u00f5es \u00e9 um recurso da linguagem C++ que permite definir m\u00faltiplas fun\u00e7\u00f5es com o mesmo nome, mas com diferentes listas de par\u00e2metros. Isso significa que voc\u00ea pode ter v\u00e1rias fun\u00e7\u00f5es que realizam tarefas semelhantes, mas aceitam diferentes tipos ou n\u00fameros de argumentos.</p> <p>No contexto de HPC, a sobrecarga de fun\u00e7\u00f5es pode ser usada para otimizar opera\u00e7\u00f5es em diferentes tipos de dados (por exemplo, opera\u00e7\u00f5es em inteiros, floats e doubles) sem duplicar o c\u00f3digo. Isso pode ajudar a escrever c\u00f3digo mais limpo e eficiente.</p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#regras-para-sobrecarga-de-funcoes","title":"Regras para Sobrecarga de Fun\u00e7\u00f5es","text":"<p>Para que duas ou mais fun\u00e7\u00f5es sejam sobrecarregadas corretamente, elas devem ser diferentes em pelo menos um dos seguintes aspectos:</p> <ol> <li>N\u00famero de par\u00e2metros: As fun\u00e7\u00f5es devem ter um n\u00famero diferente de par\u00e2metros.</li> <li>Tipo de par\u00e2metros: As fun\u00e7\u00f5es devem ter tipos diferentes de par\u00e2metros.</li> </ol> <p>A sobrecarga de fun\u00e7\u00f5es n\u00e3o pode ser feita apenas com base no tipo de retorno das fun\u00e7\u00f5es.</p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#exemplo-basico-de-sobrecarga-de-funcoes","title":"Exemplo B\u00e1sico de Sobrecarga de Fun\u00e7\u00f5es","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// Fun\u00e7\u00e3o que imprime um inteiro\nvoid imprimir(int valor) {\n    std::cout &lt;&lt; \"Inteiro: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n\n// Fun\u00e7\u00e3o que imprime um float\nvoid imprimir(float valor) {\n    std::cout &lt;&lt; \"Float: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n\n// Fun\u00e7\u00e3o que imprime uma string\nvoid imprimir(std::string valor) {\n    std::cout &lt;&lt; \"String: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n\nint main() {\n    imprimir(10);          // Chama a fun\u00e7\u00e3o que imprime um inteiro\n    imprimir(3.14f);       // Chama a fun\u00e7\u00e3o que imprime um float\n    imprimir(\"Hello\");     // Chama a fun\u00e7\u00e3o que imprime uma string\n\n    return 0;\n}\n</code></pre> <p>Neste exemplo, a fun\u00e7\u00e3o <code>imprimir</code> \u00e9 sobrecarregada para aceitar diferentes tipos de argumentos: <code>int</code>, <code>float</code> e <code>std::string</code></p> <p>Vamos considerar um exemplo de sobrecarga de fun\u00e7\u00f5es para calcular o produto escalar de vetores de diferentes tipos.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Fun\u00e7\u00e3o para calcular o produto escalar de vetores de inteiros\nint produtoEscalar(const std::vector&lt;int&gt;&amp; v1, const std::vector&lt;int&gt;&amp; v2) {\n    int produto = 0;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\n// Fun\u00e7\u00e3o para calcular o produto escalar de vetores de floats\nfloat produtoEscalar(const std::vector&lt;float&gt;&amp; v1, const std::vector&lt;float&gt;&amp; v2) {\n    float produto = 0.0f;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\n// Fun\u00e7\u00e3o para calcular o produto escalar de vetores de doubles\ndouble produtoEscalar(const std::vector&lt;double&gt;&amp; v1, const std::vector&lt;double&gt;&amp; v2) {\n    double produto = 0.0;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\nint main() {\n    std::vector&lt;int&gt; v1_int = {1, 2, 3};\n    std::vector&lt;int&gt; v2_int = {4, 5, 6};\n\n    std::vector&lt;float&gt; v1_float = {1.0f, 2.0f, 3.0f};\n    std::vector&lt;float&gt; v2_float = {4.0f, 5.0f, 6.0f};\n\n    std::vector&lt;double&gt; v1_double = {1.0, 2.0, 3.0};\n    std::vector&lt;double&gt; v2_double = {4.0, 5.0, 6.0};\n\n    std::cout &lt;&lt; \"Produto Escalar (int): \" &lt;&lt; produtoEscalar(v1_int, v2_int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (float): \" &lt;&lt; produtoEscalar(v1_float, v2_float) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (double): \" &lt;&lt; produtoEscalar(v1_double, v2_double) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#sobrecarga-de-funcoes-e-templates","title":"Sobrecarga de Fun\u00e7\u00f5es e Templates","text":"<p>Outra abordagem para lidar com opera\u00e7\u00f5es semelhantes em diferentes tipos de dados \u00e9 o uso de templates de fun\u00e7\u00f5es. Templates podem ser usados para evitar a necessidade de sobrecarregar fun\u00e7\u00f5es manualmente para cada tipo de dado.</p>"},{"location":"Teoria/sobrecarga-de-funcoes-C%2B%2B/#exemplo-de-template-de-funcao","title":"Exemplo de Template de Fun\u00e7\u00e3o","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Template de fun\u00e7\u00e3o para calcular o produto escalar de vetores\ntemplate &lt;typename T&gt;\nT produtoEscalar(const std::vector&lt;T&gt;&amp; v1, const std::vector&lt;T&gt;&amp; v2) {\n    T produto = 0;\n    for (size_t i = 0; i &lt; v1.size(); ++i) {\n        produto += v1[i] * v2[i];\n    }\n    return produto;\n}\n\nint main() {\n    std::vector&lt;int&gt; v1_int = {1, 2, 3};\n    std::vector&lt;int&gt; v2_int = {4, 5, 6};\n\n    std::vector&lt;float&gt; v1_float = {1.0f, 2.0f, 3.0f};\n    std::vector&lt;float&gt; v2_float = {4.0f, 5.0f, 6.0f};\n\n    std::vector&lt;double&gt; v1_double = {1.0, 2.0, 3.0};\n    std::vector&lt;double&gt; v2_double = {4.0, 5.0, 6.0};\n\n    std::cout &lt;&lt; \"Produto Escalar (int): \" &lt;&lt; produtoEscalar(v1_int, v2_int) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (float): \" &lt;&lt; produtoEscalar(v1_float, v2_float) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Produto Escalar (double): \" &lt;&lt; produtoEscalar(v1_double, v2_double) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>A sobrecarga de fun\u00e7\u00f5es em C++ permite a defini\u00e7\u00e3o de m\u00faltiplas fun\u00e7\u00f5es com o mesmo nome, mas com diferentes listas de par\u00e2metros. Isso melhora a legibilidade, manuten\u00e7\u00e3o e facilidade de uso do c\u00f3digo. No contexto de HPC, a sobrecarga de fun\u00e7\u00f5es pode ser usada para otimizar opera\u00e7\u00f5es em diferentes tipos de dados, evitando duplica\u00e7\u00e3o de c\u00f3digo e melhorando a efici\u00eancia. Alternativamente, templates de fun\u00e7\u00f5es podem ser usados para alcan\u00e7ar resultados similares com menos c\u00f3digo.</p>"},{"location":"Teoria/uso-de-constantes/","title":"Const Correctness em HPC","text":"<p>Const Correctness (uso de constantes) \u00e9 um conceito em C++ que garante que os dados n\u00e3o sejam modificados quando n\u00e3o deveriam ser. Usar <code>const</code> corretamente pode melhorar a legibilidade do c\u00f3digo, evitar erros e permitir otimiza\u00e7\u00f5es pelo compilador. </p>"},{"location":"Teoria/uso-de-constantes/#usos-comuns-de-const","title":"Usos Comuns de <code>const</code>","text":""},{"location":"Teoria/uso-de-constantes/#1-variaveis-locais","title":"1. Vari\u00e1veis Locais","text":"<p>Declarar vari\u00e1veis locais como <code>const</code> se voc\u00ea n\u00e3o pretende modificar o valor delas.</p> <pre><code>const int valor = 10;\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#2-parametros-de-funcao","title":"2. Par\u00e2metros de Fun\u00e7\u00e3o","text":"<p>Usar <code>const</code> em par\u00e2metros de fun\u00e7\u00e3o para garantir que os argumentos n\u00e3o sejam modificados.</p> <pre><code>void imprimeValor(const int valor) {\n    std::cout &lt;&lt; \"Valor: \" &lt;&lt; valor &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#3-ponteiros-e-referencias","title":"3. Ponteiros e Refer\u00eancias","text":"<p>Declarar ponteiros e refer\u00eancias como <code>const</code> para garantir que os dados apontados ou referenciados n\u00e3o sejam alterados.</p> <pre><code>void imprimeValor(const int* ptr) {\n    std::cout &lt;&lt; \"Valor: \" &lt;&lt; *ptr &lt;&lt; std::endl;\n}\n\nvoid imprimeValor(const int&amp; ref) {\n    std::cout &lt;&lt; \"Valor: \" &lt;&lt; ref &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#4-metodos-de-classe","title":"4. M\u00e9todos de Classe","text":"<p>Declarar m\u00e9todos como <code>const</code> para garantir que eles n\u00e3o modifiquem o estado do objeto.</p> <pre><code>class Ponto {\npublic:\n    Ponto(int x, int y) : x(x), y(y) {}\n\n    int getX() const { return x; }\n    int getY() const { return y; }\n\nprivate:\n    int x, y;\n};\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#exemplo-multiplicacao-de-matrizes-com-const-correctness","title":"Exemplo: Multiplica\u00e7\u00e3o de Matrizes com Const Correctness","text":"<p>Vamos considerar um exemplo de multiplica\u00e7\u00e3o de matrizes onde aplicamos const correctness para garantir que os dados de entrada n\u00e3o sejam modificados.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Fun\u00e7\u00e3o para multiplicar duas matrizes com const correctness\nvoid multiplicaMatriz(const vector&lt;vector&lt;int&gt;&gt;&amp; A, const vector&lt;vector&lt;int&gt;&gt;&amp; B, vector&lt;vector&lt;int&gt;&gt;&amp; C) {\n    int N = A.size();\n    for (int i = 0; i &lt; N; ++i) {\n        for (int j = 0; j &lt; N; ++j) {\n            C[i][j] = 0;\n            for (int k = 0; k &lt; N; ++k) {\n                C[i][j] += A[i][k] * B[k][j];\n            }\n        }\n    }\n}\n\nint main() {\n    int N = 100; // Tamanho da matriz\n    vector&lt;vector&lt;int&gt;&gt; A(N, vector&lt;int&gt;(N, 1));\n    vector&lt;vector&lt;int&gt;&gt; B(N, vector&lt;int&gt;(N, 1));\n    vector&lt;vector&lt;int&gt;&gt; C(N, vector&lt;int&gt;(N, 0));\n\n    auto inicio = high_resolution_clock::now();\n\n    // Chama a fun\u00e7\u00e3o de multiplica\u00e7\u00e3o de matrizes\n    multiplicaMatriz(A, B, C);\n\n    auto fim = high_resolution_clock::now();\n    auto duracao = duration_cast&lt;milliseconds&gt;(fim - inicio).count();\n\n    cout &lt;&lt; \"Tempo de multiplica\u00e7\u00e3o de matrizes: \" &lt;&lt; duracao &lt;&lt; \"ms\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"Teoria/uso-de-constantes/#const-correctness-em-classes","title":"Const Correctness em Classes","text":"<p>No contexto de HPC, classes frequentemente encapsulam dados e opera\u00e7\u00f5es. Garantir const correctness em m\u00e9todos de classe \u00e9 essencial.</p>"},{"location":"Teoria/uso-de-constantes/#exemplo-classe-de-matriz-com-metodos-const","title":"Exemplo: Classe de Matriz com M\u00e9todos Const","text":"<pre><code>class Matriz {\npublic:\n    Matriz(int N) : data(N, vector&lt;int&gt;(N, 0)) {}\n\n    const vector&lt;int&gt;&amp; operator[](int index) const {\n        return data[index];\n    }\n\n    vector&lt;int&gt;&amp; operator[](int index) {\n        return data[index];\n    }\n\n    void imprime() const {\n        for (const auto&amp; linha : data) {\n            for (int valor : linha) {\n                cout &lt;&lt; valor &lt;&lt; \" \";\n            }\n            cout &lt;&lt; endl;\n        }\n    }\n\nprivate:\n    vector&lt;vector&lt;int&gt;&gt; data;\n};\n\nint main() {\n    Matriz matriz(3);\n\n    matriz[0][0] = 1;\n    matriz[1][1] = 2;\n    matriz[2][2] = 3;\n\n    cout &lt;&lt; \"Matriz:\" &lt;&lt; endl;\n    matriz.imprime();\n\n    return 0;\n}\n</code></pre> <p>Aplicar const correctness pode prevenir erros e permitir otimiza\u00e7\u00f5es adicionais pelo compilador. Usar <code>const</code> de maneira apropriada em vari\u00e1veis, par\u00e2metros de fun\u00e7\u00e3o, ponteiros, refer\u00eancias e m\u00e9todos de classe \u00e9 uma pr\u00e1tica recomendada para escrever c\u00f3digo robusto e eficiente.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/","title":"Cluster Franky","text":"<p>Nosso objetivo \u00e9 preparar voc\u00ea com as habilidades necess\u00e1rias para utilizar sistemas de HPC em situa\u00e7\u00f5es reais. Inspirado no supercomputador Santos Dumont, o Cluster Franky oferece um ambiente robusto e seguro para realizar simula\u00e7\u00f5es complexas e an\u00e1lises de grandes volumes de dados.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#como-o-sistema-funciona","title":"Como o Sistema Funciona","text":"<p>Para que voc\u00ea compreenda melhor como o Cluster Franky opera, veja a figura abaixo que detalha a arquitetura do sistema:</p> <p></p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#1-conexao-e-autenticacao","title":"1. Conex\u00e3o e Autentica\u00e7\u00e3o","text":"<p>O processo de intera\u00e7\u00e3o com o Cluster Franky come\u00e7a quando voc\u00ea se conecta ao Cluster via SSH atrav\u00e9s da rede do Insper, em seguida, voc\u00ea ser\u00e1 direcionado ao Login Node, que serve como o ponto de entrada para o cluster. Para acessar o sistema, \u00e9 necess\u00e1rio passar por um processo de autentica\u00e7\u00e3o usando pares de chaves p\u00fablicas e privadas, configurados previamente por nossa equipe t\u00e9cnica.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#2-envio-e-gerenciamento-de-tarefas-jobs","title":"2. Envio e Gerenciamento de Tarefas (Jobs)","text":"<p>Uma vez autenticado, voc\u00ea interage com o cluster atrav\u00e9s do Slurm. O Slurm \u00e9 respons\u00e1vel por gerenciar a execu\u00e7\u00e3o das tarefas que voc\u00ea submete, distribuindo-as eficientemente pelos recursos de computa\u00e7\u00e3o dispon\u00edveis, que s\u00e3o divididos em:</p> <ul> <li>N\u00f3 de Computa\u00e7\u00e3o CPU: Composto por cinco n\u00f3s, cada um com 24 threads e 64 GB de RAM.</li> <li>N\u00f3 de Computa\u00e7\u00e3o GPU: Composto por um n\u00f3s, equipado com uma GPU NVIDIA 1080 Ti, 16 GB de RAM e 8 threads.</li> </ul> <p>Os daemons de controle cada n\u00f3 de computa\u00e7\u00e3o gerencia a execu\u00e7\u00e3o das tarefas, garantindo que os recursos sejam alocados de forma otimizada. Isso significa que, independentemente de voc\u00ea estar executando simula\u00e7\u00f5es simples ou tarefas intensivas de processamento de dados, o sistema est\u00e1 configurado para maximizar a efici\u00eancia e minimizar o tempo de execu\u00e7\u00e3o.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#3-armazenamento-e-gestao-de-dados","title":"3. Armazenamento e Gest\u00e3o de Dados","text":"<p>Durante suas atividades, voc\u00ea deve utilizar a pasta SCRATCH para armazenar temporariamente os arquivos e dados necess\u00e1rios para suas tarefas. \u00c9 importante lembrar que essa pasta \u00e9 destinada ao armazenamento tempor\u00e1rio, portanto, certifique-se de salvar seus dados em um local seguro ap\u00f3s concluir suas atividades.</p> <p>O sistema de arquivos atual do Cluster Franky utiliza o NFS (Network File System), que facilita o acesso aos dados entre os n\u00f3s de computa\u00e7\u00e3o. No futuro, planejamos migrar para o sistema de arquivos Lustre, que oferecer\u00e1 maior efici\u00eancia e melhor desempenho no manuseio de grandes volumes de dados.</p>"},{"location":"Teoria/cluster-Franky/cluster-Franky/#porque-usar-o-cluster-franky","title":"Porque usar o Cluster Franky?","text":"<p>Utilizar o Cluster Franky oferece v\u00e1rios benef\u00edcios que v\u00e3o prepar\u00e1-lo para desafios reais em HPC:</p> <ul> <li> <p>Experi\u00eancia Pr\u00e1tica em HPC: Ao trabalhar com o Cluster Franky, voc\u00ea ter\u00e1 a oportunidade de realizar tarefas que simulam cen\u00e1rios reais encontrados em supercomputadores como o Santos Dumont. Isso inclui a execu\u00e7\u00e3o de simula\u00e7\u00f5es complexas, a otimiza\u00e7\u00e3o de recursos e o uso inteligente das ferramentas dispon\u00edveis.</p> </li> <li> <p>Desenvolvimento de Habilidades T\u00e9cnicas: Aprender a utilizar ferramentas avan\u00e7adas como o Slurm e a interagir com ambientes de computa\u00e7\u00e3o distribu\u00edda ir\u00e1 equip\u00e1-lo com habilidades t\u00e9cnicas valiosas, amplamente aplic\u00e1veis em diversas \u00e1reas de pesquisa e ind\u00fastria.</p> </li> <li> <p>Prepara\u00e7\u00e3o para o Mundo Real: A experi\u00eancia adquirida com o Cluster Franky ser\u00e1 um diferencial no mercado de trabalho, pois voc\u00ea estar\u00e1 familiarizado com pr\u00e1ticas e tecnologias utilizadas em sistemas de HPC de ponta.</p> </li> </ul> <p>O Cluster Franky n\u00e3o \u00e9 apenas uma ferramenta de aprendizado; \u00e9 uma porta de entrada para o mundo da computa\u00e7\u00e3o de alto desempenho. Aproveite essa oportunidade para expandir seus conhecimentos, experimentar e se preparar para enfrentar desafios de HPC. Se precisar de ajuda ou tiver d\u00favidas, procure um de n\u00f3s!</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/","title":"Contextualizando o HPC","text":""},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-hpc","title":"O que \u00e9 HPC?","text":"<p>High-Performance Computing (HPC) refere-se ao uso de supercomputadores e clusters de computadores para resolver problemas computacionalmente complexos. HPC \u00e9 essencial em campos como ci\u00eancia, engenharia e finan\u00e7as, onde grandes volumes de dados precisam ser processados rapidamente.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#top-500","title":"TOP 500","text":"<p>Supercomputador Fugaku Fonte:https://spectrum.ieee.org/japans-fugaku-supercomputer-is-first-in-the-world-to-simultaneously-top-all-high-performance-benchmarks</p> <p>O TOP 500 \u00e9 uma lista semestral que classifica os 500 supercomputadores mais poderosos do mundo com base no benchmark LINPACK, que mede a capacidade de resolver sistemas de equa\u00e7\u00f5es lineares. A lista \u00e9 um indicador importante do progresso em tecnologia de supercomputa\u00e7\u00e3o. Varia\u00e7\u00f5es da lista incluem:</p> <ul> <li>Green500: Classifica supercomputadores pela efici\u00eancia energ\u00e9tica.</li> <li>Graph500: Mede o desempenho em tarefas de an\u00e1lise de gr\u00e1ficos.</li> <li>HPCG: Avalia supercomputadores usando um benchmark alternativo ao LINPACK, mais representativo de cargas de trabalho reais em HPC.</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#que-tipo-de-problema-e-computacionalmente-complexo","title":"Que tipo de problema \u00e9 computacionalmente complexo?","text":"<p>Problemas computacionalmente complexos exigem grande capacidade de processamento e mem\u00f3ria para serem resolvidos eficientemente. Exemplos incluem:</p> <ul> <li>Simula\u00e7\u00f5es clim\u00e1ticas</li> <li>Modelagem molecular</li> <li>Processamento de grandes conjuntos de dados (Big Data)</li> <li>An\u00e1lise gen\u00f4mica</li> <li>Renderiza\u00e7\u00e3o de gr\u00e1ficos em alta resolu\u00e7\u00e3o</li> <li>Aprendizado de m\u00e1quina e intelig\u00eancia artificial</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-um-supercomputador","title":"O que \u00e9 um supercomputador?","text":"<p>Monstr\u00e3o - Supercomputador do Insper Fonte:https://www.insper.edu.br/noticias/conhece-o-monstrao-saiba-mais-sobre-o-supercomputador-do-insper/</p> <p>Um supercomputador \u00e9 um sistema computacional de alto desempenho projetado para processar grandes volumes de dados e realizar c\u00e1lculos complexos muito rapidamente. Ele consiste em milhares de n\u00f3s de computa\u00e7\u00e3o interconectados, cada um contendo m\u00faltiplos processadores, grande quantidade de mem\u00f3ria e armazenamento r\u00e1pido.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-um-cluster","title":"O que \u00e9 um Cluster?","text":"<p>Cluster Franky - Laborat\u00f3rio de Redes e Supercomputa\u00e7\u00e3o do Insper</p> <p>Um cluster \u00e9 um conjunto de computadores (n\u00f3s) conectados que trabalham juntos como se fossem um \u00fanico sistema. Cada n\u00f3 em um cluster \u00e9 um computador independente, mas o sistema inteiro \u00e9 gerenciado para atuar em conjunto, distribuindo tarefas e compartilhando recursos.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#qual-a-diferenca-de-um-supercomputador-para-um-cluster","title":"Qual a diferen\u00e7a de um supercomputador para um cluster?","text":"<p>A principal diferen\u00e7a entre um supercomputador e um cluster est\u00e1 na integra\u00e7\u00e3o e desempenho:</p> <ul> <li>Supercomputador: Um sistema integrado de alto desempenho projetado especificamente para computa\u00e7\u00e3o intensa. Possui uma arquitetura otimizada e interconex\u00f5es de alta velocidade.</li> <li>Cluster: S\u00e3o computadores independentes conectados para trabalhar juntos. Pode ser composto por hardware de mercado e geralmente \u00e9 mais flex\u00edvel e expans\u00edvel.</li> </ul> <p>OBS: Muitos supercomputadores modernos s\u00e3o de fato clusters, utilizando milhares de n\u00f3s interconectados para alcan\u00e7ar um desempenho extremamente alto.</p>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-preciso-saber-para-utilizar-o-cluster","title":"O que \u00e9 preciso saber para utilizar o Cluster?","text":"<p>Para utilizar um cluster eficientemente, \u00e9 importante entender:</p> <ul> <li>Acesso e Conex\u00e3o: Como se conectar ao cluster e configurar as credenciais de acesso.</li> <li>Gerenciamento de Recursos: Como usar o sistema de gerenciamento de SLURM para submeter e monitorar jobs.</li> <li>Sistema de Arquivos: Navega\u00e7\u00e3o e uso do sistema de arquivos do cluster.</li> <li>Compila\u00e7\u00e3o e Execu\u00e7\u00e3o: Compilar c\u00f3digo e executar programas no ambiente do cluster.</li> <li>Paraleliza\u00e7\u00e3o: Como paralelizar c\u00f3digo usando bibliotecas como OpenMP e MPI.</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#o-que-e-preciso-saber-para-resolver-problemas-em-hpc","title":"O que \u00e9 preciso saber para resolver problemas em HPC?","text":"<p>Para resolver problemas em HPC, \u00e9 essencial ter conhecimento em:</p> <ul> <li>Arquitetura de Computadores: Compreender a arquitetura do sistema, incluindo hierarquia de mem\u00f3ria e caches, para escrever c\u00f3digo eficiente.</li> <li>Otimiza\u00e7\u00e3o de C\u00f3digo: T\u00e9cnicas de otimiza\u00e7\u00e3o, uso eficiente da mem\u00f3ria, uso efici\u00eante do compilador.</li> <li>Profiling: Ferramentas e t\u00e9cnicas para identificar gargalos de desempenho e medir a efici\u00eancia do c\u00f3digo.</li> <li>Gerenciamento de Recursos: Usar ferramentas de gerenciamento como SLURM para alocar recursos adequadamente.</li> <li>Programa\u00e7\u00e3o Paralela: Usar OpenMP para paraleliza\u00e7\u00e3o em mem\u00f3ria compartilhada e MPI para mem\u00f3ria distribu\u00edda.</li> </ul>"},{"location":"Teoria/contextualizando-hpc/contextualizando-HPC/#recursos-adicionais","title":"Recursos Adicionais","text":"<ul> <li>Documenta\u00e7\u00e3o do SLURM: SLURM User Guide</li> <li>Tutoriais de MPI: MPI Tutorial</li> <li>OpenMP: OpenMP Official Site</li> <li>Profiling Tools: Gprof, Valgrind</li> </ul>"},{"location":"Teoria/introducao/conceitos-basicos-hw/","title":"Relembrando conceitos importantes","text":"<p>O mapa de mem\u00f3ria de um computador revela como a mem\u00f3ria \u00e9 organizada e gerenciada, isso \u00e9 essencial para entender o armazenamento, o acesso e a manipula\u00e7\u00e3o de dados pela CPU. A mem\u00f3ria principal do sistema inclui o heap, a stack e os segmentos de dados e c\u00f3digo. </p> <ol> <li>Pilha: Localizada no topo do mapa de mem\u00f3ria, \u00e9 usada para armazenar vari\u00e1veis locais e chamadas de fun\u00e7\u00e3o. Cada thread possui sua pr\u00f3pria pilha.</li> <li>Espa\u00e7o Livre: Espa\u00e7o entre a pilha e o heap, permitindo o crescimento de ambos conforme necess\u00e1rio.</li> <li>Heap: \u00c1rea usada para a aloca\u00e7\u00e3o de mem\u00f3ria din\u00e2mica. Mem\u00f3ria \u00e9 alocada e desalocada conforme necess\u00e1rio durante a execu\u00e7\u00e3o do programa.</li> <li>Segmento de Dados: Cont\u00e9m vari\u00e1veis globais e est\u00e1ticas. Este segmento \u00e9 dividido em duas partes:<ul> <li>Segmento de Dados Inicializado: Armazena vari\u00e1veis globais e est\u00e1ticas que s\u00e3o inicializadas.</li> <li>BSS (Block Started by Symbol): Armazena vari\u00e1veis globais e est\u00e1ticas n\u00e3o inicializadas.</li> </ul> </li> <li>Segmento de C\u00f3digo: Cont\u00e9m o c\u00f3digo execut\u00e1vel do programa.</li> </ol> <p>Os endere\u00e7os da pilha crescem de cima para baixo, enquanto os endere\u00e7os do heap crescem de baixo para cima, conforme indicado pelas setas de crescimento no diagrama. Essa organiza\u00e7\u00e3o \u00e9 essencial para o gerenciamento eficiente da mem\u00f3ria e para garantir a integridade e desempenho do programa</p> <p></p> <p>Os caches, subdivididos em L1, L2 e L3, s\u00e3o mem\u00f3rias r\u00e1pidas de diferentes tamanhos e velocidades. O L1 \u00e9 o mais r\u00e1pido e menor, localizado dentro do n\u00facleo da CPU. O L2 \u00e9 maior e mais lento que o L1, mas ainda mais r\u00e1pido que a RAM, enquanto o L3, compartilhado entre os n\u00facleos do processador, \u00e9 maior e mais lento que o L2. Os registradores, pequenas quantidades de mem\u00f3ria dentro da CPU, s\u00e3o extremamente r\u00e1pidos e usados para opera\u00e7\u00f5es imediatas e tempor\u00e1rias.</p> <p></p> <ul> <li>Registradores: Pequenas quantidades de mem\u00f3ria dentro da CPU, extremamente r\u00e1pidas, usadas para opera\u00e7\u00f5es imediatas e tempor\u00e1rias. Tamanho: 64-128 bits.</li> <li>Cache L1: O cache mais r\u00e1pido e muito pequeno, localizado dentro do n\u00facleo da CPU. Tamanho: 32 KB.</li> <li>Cache L2: Maior e mais lento que o L1, mas ainda muito r\u00e1pido. Tamanho: 256 KB - 512 KB.</li> <li>Cache L3: Compartilhado entre os n\u00facleos do processador, \u00e9 maior e mais lento que o L2, mas ainda mais r\u00e1pido que a RAM. Tamanho: 2 MB - 16 MB.</li> <li>RAM: A mem\u00f3ria principal do sistema, maior em tamanho e a mais lenta em termos de velocidade comparada aos caches e registradores. Tamanho: 4 GB - 64 GB ou mais.</li> </ul> <p></p> <p>No contexto de HPC, escolher os tipos de dados adequados em C++ \u00e9 crucial por v\u00e1rias raz\u00f5es. </p> <ul> <li>Vari\u00e1veis menores ocupam menos espa\u00e7o, permitindo que mais dados sejam armazenados no cache ou na RAM, melhorando a localidade de cache e resultando em acessos mais r\u00e1pidos.</li> <li>A velocidade de processamento tamb\u00e9m \u00e9 impactada pela escolha dos tipos na declara\u00e7\u00e3o da vari\u00e1vel. A CPU processa tipos menores mais rapidamente, e instru\u00e7\u00f5es SIMD (Single Instruction, Multiple Data) podem processar m\u00faltiplos dados em paralelo se os tipos forem pequenos o suficiente para caberem nos registradores.</li> <li>A precis\u00e3o dos c\u00e1lculos \u00e9 outra considera\u00e7\u00e3o importante. Para c\u00e1lculos cient\u00edficos, a precis\u00e3o adicional dos <code>double</code> pode ser necess\u00e1ria para evitar erros num\u00e9ricos significativos, enquanto em gr\u00e1ficos e outras aplica\u00e7\u00f5es, <code>float</code> pode ser suficiente e mais eficiente em termos de mem\u00f3ria e processamento.</li> <li>Usar tipos menores de vari\u00e1veis reduzem a quantidade de dados transferidos entre n\u00f3s em um cluster, diminuindo a lat\u00eancia e a sobrecarga de comunica\u00e7\u00e3o.</li> </ul> <p>Considerar corretamente os tipos na cria\u00e7\u00e3o das vari\u00e1veis \u00e9 importante para maximizar a efici\u00eancia de uso de mem\u00f3ria, melhorar a velocidade e a precis\u00e3o dos c\u00e1lculos, otimizar o desempenho computacional, minimizar a fragmenta\u00e7\u00e3o de mem\u00f3ria, aproveitar melhor o paralelismo e reduzir a lat\u00eancia de comunica\u00e7\u00e3o, al\u00e9m de melhorar a localidade de cache e o acesso \u00e0 mem\u00f3ria. Compreender o mapa de mem\u00f3ria do computador e como os diferentes tipos de dados interagem com a CPU e a mem\u00f3ria pode levar a melhorias significativas no desempenho dos seus algoritmos.</p>"},{"location":"aulas/","title":"Entregas e Objetivos","text":"<p>aula 00: Introdu\u00e7\u00e3o ao Curso - Contextualiza\u00e7\u00e3o do curso, introdu\u00e7\u00e3o a HPC, entender porque usamos C++ em HPC. </p> <p>aula 01: Introdu\u00e7\u00e3o ao Cluster - Configurar o ambiente de desenvolvimento, submeter o primeiro job no Cluster Franky. </p> <p>aula 02: SLURM - Entender como a solicita\u00e7\u00e3o de recursos impacta o tempo de execu\u00e7\u00e3o de uma tarefa e compreender como pedir recursos ao SLURM.</p>"},{"location":"aulas/00-introducao/","title":"Aula 0: A import\u00e2ncia da linguagem","text":"<p>Nesta atividade, veremos como a escolha da linguagem de programa\u00e7\u00e3o pode melhorar significativamente o desempenho de opera\u00e7\u00f5es computacionalmente intensivas. Utilizaremos Python e C++ para implementar e comparar o desempenho na multiplica\u00e7\u00e3o de matrizes, uma opera\u00e7\u00e3o comum em muitas aplica\u00e7\u00f5es de IA e vis\u00e3o computacional.</p>"},{"location":"aulas/00-introducao/#parte-1-implementacao-basica-em-python","title":"Parte 1: Implementa\u00e7\u00e3o B\u00e1sica em Python","text":"<p>Execute o c\u00f3digo abaixo e observe o tempo de execu\u00e7\u00e3o. Essa \u00e9 uma implementa\u00e7\u00e3o sequencial que processa a multiplica\u00e7\u00e3o de matrizes usando uma \u00fanica thread em python.</p> <pre><code>import time  # Importa o m\u00f3dulo time, que fornece fun\u00e7\u00f5es para medir o tempo de execu\u00e7\u00e3o do c\u00f3digo.\n\ndef multiply_matrices(A, B):\n    # Define a fun\u00e7\u00e3o multiply_matrices, que realiza a multiplica\u00e7\u00e3o de duas matrizes A e B.\n    # O resultado \u00e9 armazenado na matriz result.\n    result = [[0 for _ in range(len(B[0]))] for _ in range(len(A))]\n    # Cria uma matriz de zeros com o mesmo n\u00famero de linhas que A e o mesmo n\u00famero de colunas que B.\n    # Esta matriz armazenar\u00e1 os resultados da multiplica\u00e7\u00e3o.\n\n    for i in range(len(A)):\n        # Itera sobre as linhas da matriz A.\n        for j in range(len(B[0])):\n            # Itera sobre as colunas da matriz B.\n            for k in range(len(B)):\n                # Itera sobre as colunas de A e as linhas de B para calcular o produto escalar da linha i de A com a coluna j de B.\n                result[i][j] += A[i][k] * B[k][j]\n                # Realiza a multiplica\u00e7\u00e3o dos elementos correspondentes de A e B e soma o resultado ao elemento result[i][j].\n\n    return result\n    # Retorna a matriz result, que cont\u00e9m o produto das matrizes A e B.\n\n# Gerar duas matrizes de tamanho grande para o teste\nN = 200  # Define o tamanho N das matrizes quadradas (200x200).\n\nA = [[i + j for j in range(N)] for i in range(N)]\n# Gera a matriz A de tamanho N x N, onde cada elemento A[i][j] \u00e9 a soma dos \u00edndices i e j.\n\nB = [[i * j for j in range(N)] for i in range(N)]\n# Gera a matriz B de tamanho N x N, onde cada elemento B[i][j] \u00e9 o produto dos \u00edndices i e j.\n\nstart_time = time.time()\n# Marca o tempo de in\u00edcio da multiplica\u00e7\u00e3o das matrizes usando a fun\u00e7\u00e3o time.time().\n\nresult = multiply_matrices(A, B)\n# Chama a fun\u00e7\u00e3o multiply_matrices para multiplicar as matrizes A e B, armazenando o resultado em 'result'.\n\nend_time = time.time()\n# Marca o tempo de t\u00e9rmino da multiplica\u00e7\u00e3o usando a fun\u00e7\u00e3o time.time().\n\nprint(f\"Tempo de execu\u00e7\u00e3o para a multiplica\u00e7\u00e3o de matrizes: {end_time - start_time:.2f} segundos\")\n# Calcula e exibe o tempo de execu\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes, subtraindo start_time de end_time.\n# O tempo \u00e9 formatado para mostrar duas casas decimais.\n</code></pre>"},{"location":"aulas/00-introducao/#parte-2-implementacao-em-c","title":"Parte 2: Implementa\u00e7\u00e3o em C++","text":"<p>Compile e execute o c\u00f3digo em C++. Compare o tempo de execu\u00e7\u00e3o com o resultado obtido na Parte 1. Observe como C++ lida com opera\u00e7\u00f5es computacionalmente intensivas de forma mais eficiente.</p> <p>Tip</p> <p>Se precisar de ajuda para instalar um compilador em C++ ou compilar e executar c\u00f3digos em c++, consulte o material dispon\u00edvel.</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda do C++ (necess\u00e1ria para usar std::cout).\n#include &lt;vector&gt;     // Inclui a biblioteca de vetores da STL (Standard Template Library) do C++, usada para criar matrizes din\u00e2micas.\n#include &lt;chrono&gt;     // Inclui a biblioteca de medi\u00e7\u00e3o de tempo do C++ (necess\u00e1ria para medir o tempo de execu\u00e7\u00e3o).\n\n// Fun\u00e7\u00e3o para multiplicar duas matrizes A e B, armazenando o resultado na matriz 'result'.\nvoid multiply_matrices(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {\n   // Loop para iterar sobre as linhas da matriz A.\n   for (size_t i = 0; i &lt; A.size(); ++i) {\n      // Loop para iterar sobre as colunas da matriz B.\n      for (size_t j = 0; j &lt; B[0].size(); ++j) {\n            result[i][j] = 0; // Inicializa o elemento result[i][j] com 0 antes de somar os produtos.\n            // Loop para calcular o produto escalar da linha i de A com a coluna j de B.\n            for (size_t k = 0; k &lt; B.size(); ++k) {\n               result[i][j] += A[i][k] * B[k][j]; // Realiza a multiplica\u00e7\u00e3o e soma dos elementos correspondentes de A e B.\n            }\n      }\n   }\n}\n\n// Fun\u00e7\u00e3o principal do programa.\nint main() {\n   size_t N = 200; // Define o tamanho N das matrizes quadradas (200x200).\n\n   // Declara e inicializa a matriz A como uma matriz NxN preenchida com zeros.\n   std::vector&lt;std::vector&lt;int&gt;&gt; A(N, std::vector&lt;int&gt;(N));\n\n   // Declara e inicializa a matriz B como uma matriz NxN preenchida com zeros.\n   std::vector&lt;std::vector&lt;int&gt;&gt; B(N, std::vector&lt;int&gt;(N));\n\n   // Declara e inicializa a matriz result como uma matriz NxN preenchida com zeros, que armazenar\u00e1 o resultado da multiplica\u00e7\u00e3o.\n   std::vector&lt;std::vector&lt;int&gt;&gt; result(N, std::vector&lt;int&gt;(N));\n\n   // Loop para preencher as matrizes A e B com valores.\n   for (size_t i = 0; i &lt; N; ++i) {\n      for (size_t j = 0; j &lt; N; ++j) {\n            A[i][j] = i + j; // Preenche a matriz A com a soma dos \u00edndices i e j.\n            B[i][j] = i * j; // Preenche a matriz B com o produto dos \u00edndices i e j.\n      }\n   }\n\n   // Marca o tempo de in\u00edcio da multiplica\u00e7\u00e3o das matrizes usando o rel\u00f3gio de alta resolu\u00e7\u00e3o.\n   auto start = std::chrono::high_resolution_clock::now();\n\n   // Chama a fun\u00e7\u00e3o multiply_matrices para multiplicar as matrizes A e B, armazenando o resultado em 'result'.\n   multiply_matrices(A, B, result);\n\n   // Marca o tempo de t\u00e9rmino da multiplica\u00e7\u00e3o.\n   auto end = std::chrono::high_resolution_clock::now();\n\n   // Calcula a dura\u00e7\u00e3o da multiplica\u00e7\u00e3o subtraindo o tempo de in\u00edcio do tempo de t\u00e9rmino, armazenando o resultado em 'duration'.\n   std::chrono::duration&lt;double&gt; duration = end - start;\n\n   // Exibe o tempo de execu\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes no console.\n   std::cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o para a multiplica\u00e7\u00e3o de matrizes em C++: \" &lt;&lt; duration.count() &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n\n   return 0; // Retorna 0, indicando que o programa foi executado com sucesso.\n}\n</code></pre>"},{"location":"aulas/00-introducao/#parte-3-paralelismo-em-c","title":"Parte 3: Paralelismo em C++","text":"<p>Compile e execute o c\u00f3digo modificado. Observe a diferen\u00e7a no tempo de execu\u00e7\u00e3o em compara\u00e7\u00e3o com as vers\u00f5es anteriores.</p> <p>Warning</p> <p>Lembre-se! Sempre que fizer altera\u00e7\u00f5es no seu c\u00f3digo em c++, \u00e9 necess\u00e1rio gerar um novo bin\u00e1rio.</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda, usada para fun\u00e7\u00f5es como std::cout.\n#include &lt;vector&gt;     // Inclui a biblioteca de vetores da STL (Standard Template Library) do C++.\n#include &lt;chrono&gt;     // Inclui a biblioteca para medi\u00e7\u00e3o de tempo, utilizada para calcular a dura\u00e7\u00e3o de execu\u00e7\u00e3o.\n#include &lt;omp.h&gt;      // Inclui a biblioteca OpenMP, usada para paralelismo em C++.\n\nvoid multiply_matrices(const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; A, const std::vector&lt;std::vector&lt;int&gt;&gt;&amp; B, std::vector&lt;std::vector&lt;int&gt;&gt;&amp; result) {\n    // Define a fun\u00e7\u00e3o que realiza a multiplica\u00e7\u00e3o de duas matrizes A e B, armazenando o resultado na matriz 'result'.\n    #pragma omp parallel for\n    // Diretiva OpenMP que paraleliza o loop 'for' que segue. Cada itera\u00e7\u00e3o do loop externo ser\u00e1 executada em paralelo.\n    for (size_t i = 0; i &lt; A.size(); ++i) {\n        // Itera sobre as linhas da matriz A. 'size_t' \u00e9 um tipo de dado usado para representar tamanhos e \u00edndices.\n        for (size_t j = 0; j &lt; B[0].size(); ++j) {\n            // Itera sobre as colunas da matriz B.\n            result[i][j] = 0;\n            // Inicializa o elemento [i][j] da matriz result com 0 antes de somar os produtos.\n            for (size_t k = 0; k &lt; B.size(); ++k) {\n                // Itera sobre as colunas de A e as linhas de B para calcular o produto escalar da linha i de A com a coluna j de B.\n                result[i][j] += A[i][k] * B[k][j];\n                // Realiza a multiplica\u00e7\u00e3o dos elementos correspondentes de A e B, somando o resultado ao elemento result[i][j].\n            }\n        }\n    }\n}\n\nint main() {\n    size_t N = 200;\n    // Define o tamanho N das matrizes quadradas (200x200).\n    std::vector&lt;std::vector&lt;int&gt;&gt; A(N, std::vector&lt;int&gt;(N));\n    // Declara e inicializa a matriz A como uma matriz NxN preenchida com zeros.\n    std::vector&lt;std::vector&lt;int&gt;&gt; B(N, std::vector&lt;int&gt;(N));\n    // Declara e inicializa a matriz B como uma matriz NxN preenchida com zeros.\n    std::vector&lt;std::vector&lt;int&gt;&gt; result(N, std::vector&lt;int&gt;(N));\n    // Declara e inicializa a matriz result como uma matriz NxN preenchida com zeros, que armazenar\u00e1 o resultado da multiplica\u00e7\u00e3o.\n\n    for (size_t i = 0; i &lt; N; ++i) {\n        // Itera sobre as linhas da matriz A e B.\n        for (size_t j = 0; j &lt; N; ++j) {\n            // Itera sobre as colunas da matriz A e B.\n            A[i][j] = i + j;\n            // Preenche a matriz A com valores como a soma dos \u00edndices i e j.\n            B[i][j] = i * j;\n            // Preenche a matriz B com valores como o produto dos \u00edndices i e j.\n        }\n    }\n\n    auto start = std::chrono::high_resolution_clock::now();\n    // Marca o tempo de in\u00edcio da multiplica\u00e7\u00e3o das matrizes usando o rel\u00f3gio de alta resolu\u00e7\u00e3o.\n    multiply_matrices(A, B, result);\n    // Chama a fun\u00e7\u00e3o multiply_matrices para multiplicar as matrizes A e B, armazenando o resultado em 'result'.\n    auto end = std::chrono::high_resolution_clock::now();\n    // Marca o tempo de t\u00e9rmino da multiplica\u00e7\u00e3o.\n\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    // Calcula a dura\u00e7\u00e3o da multiplica\u00e7\u00e3o subtraindo o tempo de in\u00edcio do tempo de t\u00e9rmino, armazenando o resultado em 'duration'.\n    std::cout &lt;&lt; \"Tempo de execu\u00e7\u00e3o para a multiplica\u00e7\u00e3o de matrizes em C++ com OpenMP: \" &lt;&lt; duration.count() &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n    // Exibe o tempo de execu\u00e7\u00e3o da multiplica\u00e7\u00e3o de matrizes no console.\n\n    return 0;\n    // Retorna 0, indicando que o programa foi executado com sucesso.\n}\n</code></pre> <p>Esta atividade demonstrou como a escolha da linguagem de programa\u00e7\u00e3o pode impactar no desempenho de opera\u00e7\u00f5es computacionalmente intensivas, como a multiplica\u00e7\u00e3o de matrizes. Voc\u00ea viu como Python e C++ lidam com essas opera\u00e7\u00f5es e como o paralelismo pode ser uma boa op\u00e7\u00e3o, dependendo da complexidade do problema. Na pr\u00f3xima atividade, voc\u00ea levar\u00e1 essas implementa\u00e7\u00f5es para o cluster Franky e essas diferen\u00e7as ficar\u00e3o ainda mais vis\u00edveis.</p> <p>Tip</p> <p>Se quiser saber um pouco mais sobre HPC, relembrar conceitos ou aprofundar um pouco em C++</p>"},{"location":"aulas/00-introducao/#entrega-atividade-0","title":"Entrega - Atividade 0","text":"<ul> <li> <p>Aumente o tamanho das matrizes nos 3 exemplos para 300x300, 900x900 e 1300x1300 </p> </li> <li> <p>Elabore um gr\u00e1fico que relaciona a complexidade do problema (tamanho da matriz) com o tempo de execu\u00e7\u00e3o para cada implementa\u00e7\u00e3o.</p> </li> <li> <p>Fa\u00e7a uma an\u00e1lise comparativa sobre o impacto do paralelismo no desempenho de acordo com a complexidade do problema.</p> </li> <li> <p>Comente sobre como voc\u00ea acha que este problema pode ser abordado em um ambiente de HPC.</p> </li> </ul> <p>Submeta seu relat\u00f3rio at\u00e9 as 23h59 do dia da aula pelo Blackboard.</p>"},{"location":"aulas/01-introducao/","title":"Aula 1: Acessando o Cluster Franky","text":"<p>Na Atividade 1, voc\u00ea ir\u00e1 executar as implementa\u00e7\u00f5es que foram testadas na Atividade 0, mas agora no ambiente de um cluster HPC usando SLURM. O objetivo \u00e9 observar como o ambiente de cluster, com sua capacidade de processamento paralelo, pode impactar o desempenho das opera\u00e7\u00f5es computacionalmente intensivas que voc\u00ea j\u00e1 explorou.</p>"},{"location":"aulas/01-introducao/#parte-0-configurando-seu-acesso-ao-cluster-franky","title":"Parte 0: Configurando seu acesso ao Cluster Franky","text":"<p>Para ter acesso ao Cluster Franky voc\u00ea precisa configurar suas credenciais de acesso e realizar acesso remoto via SSH.</p> <p>Entre no Blackboard, navegue at\u00e9 a se\u00e7\u00e3o de materiais do curso onde a pasta com o par de chaves foi disponibilizada, Fa\u00e7a o download da pasta completa, que cont\u00e9m os arquivos <code>id_rsa</code> (chave privada) e <code>id_rsa.pub</code> (chave p\u00fablica). Dependendo do sistema operacional que voc\u00ea utiliza, siga as instru\u00e7\u00f5es abaixo para configurar  corretamente sua chave privada.</p>"},{"location":"aulas/01-introducao/#para-macbook-ou-linux","title":"Para Macbook ou Linux:","text":"<p>Abra o terminal, navegue at\u00e9 a pasta onde a chave privada (<code>id_rsa</code>) foi baixada, mova a chave para o diret\u00f3rio <code>.ssh</code> em sua home:</p> <pre><code>mv id_rsa ~/.ssh/\n</code></pre> <p>Garanta que apenas voc\u00ea possa ler o arquivo:</p> <pre><code>chmod 600 ~/.ssh/id_rsa\n</code></pre> <p>Conecte-se ao cluster utilizando o comando SSH:</p> <p>Substitua <code>nome_da_pasta</code> pelo nome que est\u00e1 na pasta com as chaves que voc\u00ea baixou no BlackBoard e <code>cluster_endereco</code> pelo endere\u00e7o de IP fornecido durante a aula.</p> <p><pre><code>ssh -i ~/.ssh/id_rsa nome_da_pasta@ip_do_cluster\n</code></pre> ou</p> <pre><code>ssh nome_da_pasta@ip_do_cluster\n</code></pre>"},{"location":"aulas/01-introducao/#para-windows","title":"Para Windows:","text":"<p>Usando OpenSSH :</p> <p>Abra o PowerShell ou Windows Terminal. Navegue at\u00e9 a pasta onde a chave privada (<code>id_rsa</code>) foi baixada, mova a chave para a pasta <code>.ssh</code> em seu diret\u00f3rio de usu\u00e1rio:</p> <pre><code>mkdir $env:USERPROFILE\\.ssh\nmv id_rsa $env:USERPROFILE\\.ssh\\\n</code></pre> <p>Certifique-se de que as permiss\u00f5es est\u00e3o corretas: <pre><code>icacls $env:USERPROFILE\\.ssh\\id_rsa /inheritance:r /grant:r \"$($env:USERNAME):(R)\"\n</code></pre> Conecte-se ao cluster usando o comando: <pre><code>ssh -i $env:USERPROFILE\\.ssh\\id_rsa seu_usuario_insper@ip_do_cluster\n</code></pre></p>"},{"location":"aulas/01-introducao/#configurar-o-vs-code-para-acesso-remoto-ao-cluster","title":"Configurar o VS Code para Acesso Remoto ao Cluster**","text":"<p>Instale a Extens\u00e3o Remote - SSH:</p> <p>Abra o VS Code, v\u00e1 para a aba de extens\u00f5es (\u00edcone de quadrado no lado esquerdo). Pesquise por \"Remote - SSH\" e instale a extens\u00e3o oficial da Microsoft.</p> <p>Configurar o Acesso Remoto:</p> <p>Pressione <code>Ctrl+Shift+P</code> (ou <code>Cmd+Shift+P</code> no Mac) para abrir o painel de comandos.</p> <p>Digite <code>Remote-SSH: Add New SSH Host...</code> e selecione a op\u00e7\u00e3o.</p> <p>Insira o comando SSH que voc\u00ea utilizou anteriormente: <pre><code>ssh -i ~/.ssh/id_rsa nome_da_pasta@ip_do_cluster\n</code></pre> Escolha o arquivo de configura\u00e7\u00e3o padr\u00e3o (<code>~/.ssh/config</code> para Mac/Linux ou <code>C:\\Users\\seu_usuario\\.ssh\\config</code> para Windows).</p> <p>Pressione <code>Ctrl+Shift+P</code> (ou <code>Cmd+Shift+P</code> no Mac) novamente e digite <code>Remote-SSH: Connect to Host...</code>. Selecione o host configurado.</p> <p>O VS Code abrir\u00e1 uma nova janela conectada ao ambiente remoto do cluster.</p> <p></p> <p>Gerenciar Projetos Remotamente:</p> <p>Ap\u00f3s a conex\u00e3o, voc\u00ea pode abrir pastas e arquivos no cluster diretamente pelo VS Code.</p> <p>Utilize os recursos do VS Code, como o terminal integrado e o debug para trabalhar no cluster Franky.</p>"},{"location":"aulas/01-introducao/#executando-a-atividade-0-no-cluster-franky-usando-slurm","title":"Executando a Atividade 0 no Cluster Franky usando SLURM","text":"<p>Um arquivo .slurm \u00e9 usado para \"lan\u00e7ar jobs\" no sistema SLURM, especificando os recursos necess\u00e1rios para a execu\u00e7\u00e3o, como mem\u00f3ria, n\u00famero de m\u00e1quinas e n\u00facleos. Nesse arquivo, tamb\u00e9m definimos como desejamos o output do execut\u00e1vel e onde o sistema pode encontrar o arquivo a ser executado. Como a equipe que gerencia o Cluster definiu que os jobs sejam lan\u00e7ados apenas da pasta SCRATCH, podemos omitir o caminho do arquivo nos nossos arquivos .slurm.</p> <p>Warning</p> <p>As instru\u00e7\u00f5es #SBATCH s\u00e3o tecnicamente consideradas \"coment\u00e1rios\" pelo interpretador de comandos do shell (bash), mas n\u00e3o s\u00e3o realmente ignoradas. Quando voc\u00ea escreve um script para ser executado pelo SLURM, o bash interpreta as linhas #SBATCH como coment\u00e1rios normais, enquanto o gerenciador de jobs SLURM interpreta essas mesmas linhas como diretivas que definem como o job deve ser executado.</p> <p>Tip</p> <p>N\u00e3o \u00e9 necess\u00e1rio neste momento, mas se voc\u00ea quiser transferir arquivos da sua m\u00e1quina para o cluster e vice versa, voc\u00ea pode usar o comando scp mais detalhes aqui</p> <p>Crie um script de submiss\u00e3o .slurm para cada implementa\u00e7\u00e3o utilizando os exemplos abaixo. Esse script ser\u00e1 utilizado para enviar o job ao cluster.</p> <p>Script SLURM para o c\u00f3digo em Python:</p> <p>matriz_mult_python.slurm</p> <pre><code>#!/bin/bash\n#As instru\u00e7\u00f5es SBATCH n\u00e3o devem ser descomentadas\n\n#SBATCH --job-name=mult_matriz_py\n# define o nome do job. Esse nome aparece nas listas de jobs e \u00e9 \u00fatil para identificar o job.\n\n#SBATCH --output=mult_matriz_py.out\n# Especifica o arquivo onde a sa\u00edda padr\u00e3o (stdout) do job ser\u00e1 salva.\n\n#SBATCH --ntasks=1\n# Define o n\u00famero de tarefas que o job executar\u00e1. Neste caso, o job executa uma \u00fanica tarefa.\n\n#SBATCH --time=00:10:00\n# Define o tempo m\u00e1ximo de execu\u00e7\u00e3o para o job. Neste caso, o job tem um tempo limite de 10 minutos. Se o job exceder esse tempo, ele ser\u00e1 automaticamente encerrado.\n\n#SBATCH --partition=normal\n# Especifica a parti\u00e7\u00e3o (ou fila) onde o job ser\u00e1 submetido. Aqui, o job ser\u00e1 submetido a fila \"normal\".\n\npython3 mult_matriz_py.py\n#Executa o programa python3 dentro do n\u00f3 de computa\u00e7\u00e3o.\n</code></pre> <p>Script SLURM para arquivos C++:</p> <p>Como o C++ \u00e9 uma linguagem que requer compila\u00e7\u00e3o, precisamos gerar o execut\u00e1vel antes de preparar o arquivo .slurm.</p> <p>Dentro da pasta SCRATCH, compile seu c\u00f3digo .cpp para gerar o bin\u00e1rio.</p> <pre><code>g++  mult_matriz_cpp.cpp -o mult_matriz_cpp \n</code></pre> <p>matriz_mult_cpp.slurm</p> <pre><code>#!/bin/bash\n#SBATCH --job-name=matriz_mult_cpp\n# Define o nome do job como \"matrix_mult_openmp\". Esse nome aparece nas listas de jobs e \u00e9 \u00fatil para identificar o job.\n\n#SBATCH --output=matriz_mult_cpp.out\n# Especifica o arquivo onde a sa\u00edda padr\u00e3o (stdout) do job ser\u00e1 salva.\n\n#SBATCH --ntasks=1\n# Define o n\u00famero de tarefas que o job executar\u00e1. Neste caso, o job executa uma \u00fanica tarefa.\n\n#SBATCH --time=00:10:00\n# Define o tempo m\u00e1ximo de execu\u00e7\u00e3o para o job. Neste caso, o job tem um tempo limite de 10 minutos. Se o job exceder esse tempo, ele ser\u00e1 automaticamente encerrado.\n\n#SBATCH --partition=normal\n# Especifica a parti\u00e7\u00e3o (ou fila) onde o job ser\u00e1 submetido. Aqui, o job ser\u00e1 submetido a fila \"normal\".\n\n\n./mult_matriz_cpp\n# Executa o programa compilado \"mult_matriz_cpp\" dentro do n\u00f3 de computa\u00e7\u00e3o.\n</code></pre> <p>Script SLURM para arquivos C++ com Paralelismo:</p> <p>Ao utilizar o OpenMP para paralelizar c\u00f3digos em C++, \u00e9 necess\u00e1rio incluir a flag apropriada durante a compila\u00e7\u00e3o. Essa flag informa ao compilador para interpretar corretamente as diretivas OpenMP no c\u00f3digo e gerar o bin\u00e1rio de forma adequada.</p> <pre><code>g++ -fopenmp mult_matriz_paralelo -o mult_matriz_paralelo.cpp\n</code></pre> <p>matriz_mult_paralelo.slurm</p> <pre><code>#!/bin/bash\n\n#SBATCH --job-name=matriz_mult_paralelo\n# Define o nome do job como \"matrix_mult_paralelo\". Esse nome aparece nas listas de jobs e \u00e9 \u00fatil para identificar o job.\n\n#SBATCH --output=matriz_mult_paralelo.out\n# Especifica o arquivo onde a sa\u00edda padr\u00e3o (stdout) do job ser\u00e1 salva.\n\n#SBATCH --ntasks=1\n# Define o n\u00famero de tarefas que o job executar\u00e1. Neste caso, o job executa uma \u00fanica tarefa.\n\n#SBATCH --cpus-per-task=4\n# Especifica o n\u00famero de CPUs que devem ser alocadas para esta tarefa.\n\n#SBATCH --time=00:10:00\n# Define o tempo m\u00e1ximo de execu\u00e7\u00e3o para o job. Neste caso, o job tem um tempo limite de 10 minutos. Se o job exceder esse tempo, ele ser\u00e1 automaticamente encerrado.\n\n#SBATCH --partition=normal\n# Especifica a parti\u00e7\u00e3o (ou fila) onde o job ser\u00e1 submetido. Aqui, o job ser\u00e1 submetido a fila \"normal\".\n\n\n./mult_matriz_paralelo\n# Executa o programa compilado \"mult_matriz_paralelo\" dentro do n\u00f3 de computa\u00e7\u00e3o.\n</code></pre>"},{"location":"aulas/01-introducao/#parte-2-execucao-das-implementacoes-no-cluster","title":"Parte 2: Execu\u00e7\u00e3o das Implementa\u00e7\u00f5es no Cluster","text":"<p>Submiss\u00e3o dos Jobs:</p> <p>Utilize o comando <code>sbatch</code> para submeter cada script SLURM ao cluster.</p> <p>Exemplo:</p> <pre><code>sbatch matriz_mult_python.slurm\nsbatch matriz_mult_cpp.slurm\nsbatch matriz_mult_paralelo.slurm\n</code></pre> <p>Monitoramento dos Jobs:</p> <p>Use o comando <code>squeue</code> para monitorar o status dos jobs.</p> <p>Exemplo:</p> <pre><code>squeue \n</code></pre> <p>An\u00e1lise dos Resultados:</p> <p>Ap\u00f3s a execu\u00e7\u00e3o dos jobs, os resultados estar\u00e3o dispon\u00edveis nos arquivos <code>.out</code>  especificados em cada script SLURM.</p> <ul> <li> <p>Compare os tempos de execu\u00e7\u00e3o dos tr\u00eas m\u00e9todos (Python, C++, C++ com OpenMP) no cluster.</p> </li> <li> <p>Analise como o paralelismo afeta o desempenho no ambiente do cluster, em compara\u00e7\u00e3o com sua execu\u00e7\u00e3o local.</p> </li> </ul> <p>Tip</p> <p>Se quiser explorar mais os comandos do SLURM, temos uma material aqui que pode te ajudar</p> <p>Entrega Atividade 1 - Relat\u00f3rio de Desempenho:</p> <ul> <li> <p>Prepare um relat\u00f3rio detalhado, incluindo gr\u00e1ficos que mostrem a rela\u00e7\u00e3o entre o tamanho das matrizes e o tempo de execu\u00e7\u00e3o para cada implementa\u00e7\u00e3o.</p> </li> <li> <p>Discuta o impacto do ambiente HPC no desempenho das opera\u00e7\u00f5es e como o paralelismo pode escalar em um cluster de m\u00faltiplos n\u00f3s.</p> </li> <li> <p>Submeta seu relat\u00f3rio pelo Blackboard at\u00e9 as 23h59 do dia da aula.</p> </li> </ul> <p>Nesta atividade, voc\u00ea explorou como o ambiente de cluster, pode ser utilizado para otimizar e acelerar opera\u00e7\u00f5es que s\u00e3o intensivas em termos computacionais. Isso oferece uma base s\u00f3lida para entender como tarefas de grande escala, como o processamento de big data ou o treinamento de modelos de IA, podem ser significativamente aceleradas com HPC.</p>"},{"location":"aulas/02-03-implementacao-c%2B%2B/","title":"02/03 - Implementa\u00e7\u00e3o em C++","text":"<p>A disciplina utilizar\u00e1 a linguagem C++ para implementa\u00e7\u00e3o dos programas. Ela \u00e9 muito usada em implementa\u00e7\u00f5es de alto desempenho e possui recursos muito \u00fateis e que simplificam a programa\u00e7\u00e3o se comparada com C puro. Nas aulas 02 e 03 aprenderemos alguns desses recursos e os utilizaremos para implementa\u00e7\u00e3o de algoritmos simples. </p> <p>Gabaritos e respostas</p> <p>Este curso n\u00e3o fornece c\u00f3digo de resposta para os exerc\u00edcios de sala. Cada exerc\u00edcio \u00e9 acompanhado de um algoritmo em pseudo-c\u00f3digo e alguns pares de arquivos entrada/sa\u00edda. Isto j\u00e1 \u00e9 suficiente para que voc\u00eas verifiquem se sua solu\u00e7\u00e3o est\u00e1 correta. </p> <p>Boas pr\u00e1ticas de programa\u00e7\u00e3o ser\u00e3o demonstradas em exerc\u00edcios corrigidos pelo professor durante o semestre.</p>"},{"location":"aulas/02-03-implementacao-c%2B%2B/#compilacao","title":"Compila\u00e7\u00e3o","text":"<p>Programas em C++ s\u00e3o compilados com o comando <code>g++</code>. Ele funciona igual ao <code>gcc</code> que voc\u00eas j\u00e1 usaram em Desafios e Sistemas Hardware-Software.</p> <pre><code>$&gt; g++ -Wall -O3 arquivo.cpp -o executavel\n</code></pre>"},{"location":"aulas/02-03-implementacao-c%2B%2B/#entrada-e-saida-em-c","title":"Entrada e sa\u00edda em C++","text":"<p>Em C usamos as fun\u00e7\u00f5es <code>printf</code> para mostrar dados no terminal e <code>scanf</code> para ler dados. Em C++ essas fun\u00e7\u00f5es tamb\u00e9m podem ser usadas, mas em geral s\u00e3o substitu\u00eddas pelos objetos <code>std::cin</code> e <code>std::cout</code> (dispon\u00edveis no cabe\u00e7alho iostream). </p> <p>A maior vantagem de usar <code>cin</code> e <code>cout</code> \u00e9 que n\u00e3o precisamos mais daquelas strings de formata\u00e7\u00e3o estranhas com <code>%d</code>, <code>%s</code> e afins. Podemos passar vari\u00e1veis diretamente para a sa\u00edda do terminal usando o operador <code>&lt;&lt;</code>. Veja um exemplo abaixo. </p> <pre><code>int a = 10;\ndouble b = 3.2;\nstd::cout &lt;&lt; \"Sa\u00edda: \" &lt;&lt; a &lt;&lt; \";\" &lt;&lt; b &lt;&lt; \"\\n\";\n</code></pre> <p>E esse <code>std::</code>?</p> <p>Em <code>C++</code> podemos ter v\u00e1rias fun\u00e7\u00f5es, vari\u00e1veis e objetos em geral com o mesmo nome. Para evitar que eles colidam e n\u00e3o se saiba a qual estamos nos referindo cada nome deve ser definido um <code>namespace</code> (literalmente espaco de nomes). Podemos ter <code>namespace</code>s aninhados.Por exemplo, <code>std::chrono</code> cont\u00e9m as fun\u00e7\u00f5es relacionadas contagem de tempo durante a execu\u00e7\u00e3o de um programa. </p> <p>Todas as fun\u00e7\u00f5es, classes e globais na biblioteca padr\u00e3o est\u00e3o definidas no espa\u00e7o <code>std</code>. Se quisermos, podemos omitir escrever <code>std::</code> toda vez digitando <code>using namespace std</code>. Isso pode ser feito tamb\u00e9m com namespaces aninhados. </p> <p>A implementa\u00e7\u00e3o de algoritmos definidos usando express\u00f5es matem\u00e1ticas \u00e9 uma habilidade importante neste curso.</p> <p>Example</p> <p>Escreva um programa que receba um inteiro <code>n</code> e calcule a seguinte s\u00e9rie.</p>  S = \\sum_{i=0}^n \\frac{1}{2^i}  <p>Mostre as primeiras 15 casas decimais de <code>S</code>. Veja a documenta\u00e7\u00e3o de <code>std::setprecision</code> aqui. </p> Resposta <p>Essa s\u00e9rie converge para o n\u00famero 2, mas sua resposta dever\u00e1 ser sempre menor que este n\u00famero. Logo, quanto maior <code>n</code> mais pr\u00f3xima sua resposta ser\u00e1. Seu programa dever\u00e1 implementar algo como o algoritmo abaixo.</p> <pre><code>leia inteiro n\ns = 0.0\npara i=0 at\u00e9 n\n    s += 1 / (2 elevado a i)\n\nprint(s)\n</code></pre>"},{"location":"aulas/02-03-implementacao-c%2B%2B/#vetores-em-c-com-vector","title":"Vetores em C++ com Vector","text":"<p>A estrutura <code>std::vector</code> \u00e9 um vetor din\u00e2mico que tem funcionalidades parecidas com a lista de Python ou o <code>ArrayList</code> de Java. O c\u00f3digo abaixo exemplifica seu uso e mostra algumas de suas fun\u00e7\u00f5es. Note que omitimos o uso de <code>std</code> no c\u00f3digo abaixo.</p> <pre><code>int n;\ncin &gt;&gt; n;\nvector&lt;double&gt; vec;\nfor (int i = 0; i &lt; n; i++) {\n    vec.push_back(i * i)\n}\ncout &lt;&lt; \"Tamanho do vetor: \" &lt;&lt; vec.size() &lt;&lt; \"\\n\";\ncout &lt;&lt; \"Primeiro elemento: \" &lt;&lt; vec.front() &lt;&lt; \"\\n\";\ncout &lt;&lt; \"\u00daltimo elemento: \" &lt;&lt; vec.back() &lt;&lt; \"\\n\";\ncout &lt;&lt; \"Elemento 3: \" &lt;&lt; vec[2] &lt;&lt; \"\\n\";\n</code></pre> <p>Alguns pontos interessantes deste exemplo:</p> <ol> <li>N\u00e3o sabemos o tamanho de <code>vec</code> ao cri\u00e1-lo. O m\u00e9todo <code>push_back</code> aumenta ele quando necess\u00e1rio e n\u00e3o precisamos nos preocupar com isso. </li> <li>O n\u00famero de elementos colocados no vetor \u00e9 retornado pelo m\u00e9todo <code>size()</code></li> <li>O acesso \u00e9 feito exatamente igual ao array de C, usando os colchetes <code>[]</code></li> </ol> <p>E esse <code>&lt;double&gt;</code> na declara\u00e7\u00e3o?</p> <p>Em C++ tipos passados entre <code>&lt; &gt;</code> s\u00e3o usados para parametrizar tipos gen\u00e9ricos. Ou seja, um vetor pode guardar qualquer tipo de dado e precisamos indicar qual ao cri\u00e1-lo. </p> <p>Note que, portanto, um vetor <code>vector&lt;int&gt;</code> e um vetor <code>vector&lt;double&gt;</code> s\u00e3o considerados de tipos diferentes e n\u00e3o posso passar o primeiro para uma fun\u00e7\u00e3o esperando o segundo. </p> <p>Example</p> <p>Crie um programa que l\u00ea um n\u00famero inteiro <code>n</code> e depois l\u00ea <code>n</code> n\u00fameros fracion\u00e1rios x_i. Fa\u00e7a os seguintes c\u00e1lculos e motre-os no terminal com 10 casas decimais. </p> \\mu = \\frac{1}{n} \\sum_{i=1}^n x_i \\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (x_i - \\mu)^2 <p>Resposta</p> <p>Use o programa <code>t4.py</code> para gerar entradas e sa\u00eddas de teste para seu programa. </p> <p>Question</p> <p>Voc\u00ea reconhece as f\u00f3rmulas acima? Elas calculam quais medidas estat\u00edsticas?</p> Resposta <p>M\u00e9dia e vari\u00e2ncia.</p>"},{"location":"aulas/02-03-implementacao-c%2B%2B/#matrizes-versao-1","title":"Matrizes (vers\u00e3o 1)","text":"<p>Dados <code>N</code> pontos com coordenadas (x_i, y_i)_{i=0}^N, computar a matriz de dist\u00e2ncias D tal que </p>  D_{i,j} = \\textrm{Dist\u00e2ncia entre } (x_i, y_i) \\textrm{ e } (x_j, y_j)  <p>Tip</p> <p>Use <code>t6.py</code> para gerar os arquivos de entrada/sa\u00edda da tarefa abaixo. </p> <p>Example</p> <p>Implemente um programa que calcule a matriz <code>D</code> acima. Sua entrada dever\u00e1 estar no formato dos arquivos <code>t6-in-*.txt</code> e sua sa\u00edda no formato dos arquivos <code>t6-out-*.txt</code>. Mostre as dist\u00e2ncias com 2 casas decimais.  </p> <p>Dicas:</p> <ol> <li>a maneira mais f\u00e1cil (n\u00e3o necessariamente a melhor) de alocar uma matriz \u00e9 usando um vetor em que cada elemento \u00e9 outro vetor. </li> <li>fa\u00e7a uma implementa\u00e7\u00e3o o mais simples poss\u00edvel. Vamos melhor\u00e1-la nas pr\u00f3ximas tarefas.</li> </ol> Resposta <pre><code>leia inteiro N\nleia vetores X e Y \n\nseja D uma matriz NxN\n\npara i=1..N:\n    para j=1..N:\n        DX = X[i] - X[j]\n        DY = Y[i] - Y[j]\n        D[i,j] = sqrt(DX*DX + DY*DY)\n</code></pre> <p>Question</p> <p>Anote abaixo o tempo de execu\u00e7\u00e3o para os arquivos <code>t6-in-*.txt</code> e <code>t6-out-*.txt</code></p> <p>Question</p> <p>Qual \u00e9 a complexidade computacional de sua implementa\u00e7\u00e3o? </p>"},{"location":"aulas/02-03-implementacao-c%2B%2B/#referencias-e-passagem-de-dados","title":"Refer\u00eancias e passagem de dados","text":"<p>Na parte anterior fizemos nosso programa inteiro no <code>main</code>. Vamos agora organiz\u00e1-lo melhor. </p> <p>Example</p> <p>Crie uma fun\u00e7\u00e3o <code>calcula_distancias</code> que recebe a matriz e os dados recebidos na entrada e a preenche. Sua fun\u00e7\u00e3o n\u00e3o dever\u00e1 retornar nenhum valor. </p> <p>Ao terminar, me\u00e7a o tempo de execu\u00e7\u00e3o para o arquivo <code>t6-out-4.txt</code>.</p> Resposta <p>Aqui podem ocorrer dois problemas:</p> <ol> <li>Seu programa deu \"Segmentation Fault\". </li> <li>Seu programa rodou at\u00e9 o fim, mas a sa\u00edda \u00e9 vazia (ou cheia de 0).</li> </ol> <p>O problema em si depende de como voc\u00ea fez o <code>for</code> duplo para mostrar os resultados. De qualquer maneira, simplesmente mover c\u00f3digo para uma outra fun\u00e7\u00e3o n\u00e3o funciona neste caso. </p> <p>Ambos problemas descritos na solu\u00e7\u00e3o s\u00e3o previs\u00edveis e ocorrem pela mesma raz\u00e3o: ao passar um <code>vector</code> para uma fun\u00e7\u00e3o \u00e9 feita uma c\u00f3pia de seu conte\u00fado. Ou seja, a matriz usada dentro de <code>calcula_distancias</code> n\u00e3o \u00e9 a mesma do <code>main</code>! </p> <p>Isto \u00e9 considerado uma feature em <code>C++</code>: por padr\u00e3o toda vari\u00e1vel \u00e9 passada por c\u00f3pia. Isto evita que uma fun\u00e7\u00e3o modifique um valor sem que o c\u00f3digo chamador fique sabendo. </p> <p>Em C podemos passar vari\u00e1veis por refer\u00eancia passando um ponteiro para elas. Apesar de funcional, isso n\u00e3o \u00e9 muito pr\u00e1tico pois temos que acessar a vari\u00e1vel sempre usando <code>*</code>.  Em C++ temos um novo recurso: refer\u00eancias. Ao declarar uma vari\u00e1vel como uma refer\u00eancia crio uma esp\u00e9cie de ponteiro constante que sempre acessa a vari\u00e1vel apontada. Veja o exemplo abaixo.</p> <pre><code>int x = 10;\nint &amp;ref = x; // refer\u00eancias s\u00e3o declaradas colocando &amp; na frente do nome da vari\u00e1vel\n// a partir daqui ref e x representam a mesma vari\u00e1vel\nref = 15;\ncout &lt;&lt; x &lt;&lt; \"\\n\"; // 15\n</code></pre> <p>O mesmo poderia ser feito com ponteiros (como mostrado abaixo). A grande vantagem da refer\u00eancia \u00e9 que n\u00e3o precisamos usar <code>*ref</code> para nos referirmos \u00e0 vari\u00e1vel <code>x</code>! Na atribui\u00e7\u00e3o tamb\u00e9m podemos usar direto <code>int &amp;ref = x</code>, o que torna o c\u00f3digo mais limpo e f\u00e1cil de entender.  </p> <pre><code>int x = 10;\nint *ref = &amp;x; // precisamos de &amp;x para apontar ref para a vari\u00e1vel x\n*ref = 15; // precisamos indicar *ref para atribuir a vari\u00e1vel x\ncout &lt;&lt; x &lt;&lt; \"\\n\"; // 15\n</code></pre> <p>Dicas</p> <p>Note que uma refer\u00eancia tem que ser inicializada com a vari\u00e1vel a que ela se refere. Ou seja, ao declarar tenho que j\u00e1 indicar a vari\u00e1vel destino e esse destino n\u00e3o pode ser modificado. </p> <p>Example</p> <p>Modifique sua fun\u00e7\u00e3o para usar refer\u00eancias. Verifique que ele volta a funcionar e que seu tempo de execu\u00e7\u00e3o continua parecido com a vers\u00e3o que rodava no <code>main</code>.</p> Resposta <p>Basta adicionar <code>&amp;</code> na frente dos nomes dos argumentos (vetores x, y e matriz). A chamada da fun\u00e7\u00e3o n\u00e3o muda. </p> <p>Dica</p> <p>Em C++ precisamos estar sempre atentos \u00e0 maneira que passamos os dados. Se n\u00e3o indicarmos ser\u00e1 por c\u00f3pia. Para compartilhar o mesmo objeto entre v\u00e1rias fun\u00e7\u00f5es usamos refer\u00eancias <code>&amp;</code>. </p>"},{"location":"aulas/02-03-implementacao-c%2B%2B/#uma-primeira-otimizacao","title":"Uma primeira otimiza\u00e7\u00e3o","text":"<p>Nossa primeira implementa\u00e7\u00e3o \u00e9 bastante direta da defini\u00e7\u00e3o e n\u00e3o tenta ser eficiente. </p> <p>Question</p> <p>Analisando a defini\u00e7ao da Tarefa 1, como seria poss\u00edvel economizar trabalho?</p> Resposta <p>Podemos ver que a matriz <code>D</code> \u00e9 sim\u00e9trica. Ou seja, <code>D[i,j] == D[j,i]</code>. Isso significa que poder\u00edamos calcular s\u00f3 um deles e copiar o valor para a outra posi\u00e7\u00e3o.</p> <p>Question</p> <p>Como isso poderia ser usado para melhorar o tempo de execu\u00e7\u00e3o de <code>calcula_distancias</code>?</p> <p>Question</p> <p>Seu programa criado na tarefa 1 consegue ser adaptado para implementar sua ideia da quest\u00e3o  anterior? O que precisaria ser modificado?</p> Resposta <p>Duas respostas s\u00e3o poss\u00edveis e corretas aqui:</p> <ol> <li> <p>Preciso checar se o <code>i &gt; j</code> e usar o valor j\u00e1 calculado de <code>D[j,i]</code>.</p> </li> <li> <p>\u00c9 preciso alocar a matriz inteira antes de come\u00e7ar. Se formos dando <code>push_back</code> linha a linha n\u00e3o conseguimos atribuir um valor ao mesmo tempo a <code>D[i,j]</code> e <code>D[j,i]</code>, j\u00e1 que um deles ainda n\u00e3o ter\u00e1 sido criado. </p> </li> </ol> <p>Baseado na resposta acima vamos tentar nossa primeira otimiza\u00e7\u00e3o: s\u00f3 vamos calcular <code>D[i,j]</code> para <code>i &lt;= j</code> (ou seja, s\u00f3 a metade \"de cima\" de <code>D</code>).</p> <p>Example</p> <p>Use a estrat\u00e9gia acima para evitar calcular a matriz inteira. Verifique se houve melhora no tempo do teste <code>t6-in-3.txt</code>.</p> <p>Dica: tente de novo usar a ideia mais simples poss\u00edvel e implemente adicionando um so <code>if</code> no seu programa.</p> Resposta <p>N\u00e3o dever\u00e1 haver ganho de desempenho significativo. Veremos exatamente o por que na pr\u00f3xima aula. </p>"},{"location":"aulas/02-slurm/","title":"Aula 02: Explorando Comandos SLURM","text":"<p>Objetivo: Entender como a solicita\u00e7\u00e3o de recursos impacta o tempo de execu\u00e7\u00e3o de uma tarefa e compreender como pedir recursos ao SLURM.</p> <p>Recursos Necess\u00e1rios: Acesso ao cluster Franky configurado.</p>"},{"location":"aulas/02-slurm/#programa-c-para-realizar-a-convolucao-de-uma-matriz","title":"Programa C++ para realizar a convolu\u00e7\u00e3o de uma matriz","text":"<p>Crie um arquivo chamado <code>convolucao.cpp</code> com o seguinte conte\u00fado:</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda.\n#include &lt;mpi.h&gt;      // Inclui a biblioteca MPI para paralelismo entre m\u00faltiplos processos.\n#include &lt;omp.h&gt;      // Inclui a biblioteca OpenMP para paralelismo com threads.\n#include &lt;chrono&gt;     // Inclui a biblioteca para medi\u00e7\u00e3o de tempo.\n\n#define N 1000 // Define o tamanho da matriz NxN.\n#define FILTER_SIZE 5 // Define o tamanho do filtro 5x5.\n#define ITERATIONS 15 // Define o n\u00famero de itera\u00e7\u00f5es de convolu\u00e7\u00e3o.\n\n\n// Fun\u00e7\u00e3o para realizar a convolu\u00e7\u00e3o em um elemento da matriz.\nint apply_filter(int x, int y, int matrix[N][N], int filter[FILTER_SIZE][FILTER_SIZE]) {\n    int result = 0;\n    int filter_offset = FILTER_SIZE / 2;  // Calcula o deslocamento do filtro para centralizar.\n\n    // Aplica o filtro 5x5 ao elemento (x, y) da matriz.\n    for (int i = -filter_offset; i &lt;= filter_offset; i++) {\n        for (int j = -filter_offset; j &lt;= filter_offset; j++) {\n            int xi = x + i;\n            int yj = y + j;\n            // Verifica se o \u00edndice est\u00e1 dentro dos limites da matriz.\n            if (xi &gt;= 0 &amp;&amp; xi &lt; N &amp;&amp; yj &gt;= 0 &amp;&amp; yj &lt; N) {\n                result += matrix[xi][yj] * filter[i + filter_offset][j + filter_offset];\n            }\n        }\n    }\n    return result;  // Retorna o valor convolu\u00eddo.\n}\n\nint main(int argc, char *argv[]) {\n    MPI_Init(&amp;argc, &amp;argv);  // Inicializa o ambiente MPI.\n\n    int rank, size;\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank); // Obt\u00e9m o rank (identificador) do processo atual.\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;size); // Obt\u00e9m o n\u00famero total de processos.\n\n    int matrix[N][N]; // Declara a matriz original.\n    int filter[FILTER_SIZE][FILTER_SIZE] = {{1, 1, 1, 1, 1}, \n                                            {1, 1, 1, 1, 1}, \n                                            {1, 1, 1, 1, 1}, \n                                            {1, 1, 1, 1, 1}, \n                                            {1, 1, 1, 1, 1}}; // Define o filtro 5x5 (exemplo de suaviza\u00e7\u00e3o).\n    int result[N][N]; // Declara a matriz resultante ap\u00f3s a convolu\u00e7\u00e3o.\n\n    // Inicializa\u00e7\u00e3o da matriz pelo processo mestre (rank 0).\n    if (rank == 0) {\n        for (int i = 0; i &lt; N; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                matrix[i][j] = i + j; // Exemplo de inicializa\u00e7\u00e3o: a soma dos \u00edndices.\n            }\n        }\n    }\n\n    // Sincroniza todos os processos antes de come\u00e7ar a medir o tempo.\n    MPI_Barrier(MPI_COMM_WORLD);\n    auto start = std::chrono::high_resolution_clock::now(); // Inicia a medi\u00e7\u00e3o de tempo.\n\n    // Broadcast da matriz original para todos os processos.\n    MPI_Bcast(matrix, N*N, MPI_INT, 0, MPI_COMM_WORLD);\n\n    // Divide a matriz entre os processos.\n    int rows_per_process = N / size; // Calcula o n\u00famero de linhas que cada processo ir\u00e1 processar.\n    int start_row = rank * rows_per_process; // Determina a linha inicial que cada processo ir\u00e1 processar.\n    int end_row = (rank == size - 1) ? N : start_row + rows_per_process; // Determina a linha final (\u00faltimo processo pode pegar as linhas restantes).\n\n    // Loop de m\u00faltiplas convolu\u00e7\u00f5es.\n    for (int iter = 0; iter &lt; ITERATIONS; iter++) {\n        #pragma omp parallel for collapse(2) // Paraleliza a convolu\u00e7\u00e3o usando OpenMP.\n        for (int i = start_row; i &lt; end_row; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                result[i][j] = apply_filter(i, j, matrix, filter); // Aplica o filtro na matriz local.\n            }\n        }\n        // Sincroniza os processos MPI para garantir que a matriz esteja atualizada para a pr\u00f3xima itera\u00e7\u00e3o.\n        MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL, result[start_row], rows_per_process*N, MPI_INT, MPI_COMM_WORLD);\n\n        // Copia a matriz resultante para a matriz original para a pr\u00f3xima itera\u00e7\u00e3o.\n        #pragma omp parallel for collapse(2) // Paraleliza a c\u00f3pia usando OpenMP.\n        for (int i = start_row; i &lt; end_row; i++) {\n            for (int j = 0; j &lt; N; j++) {\n                matrix[i][j] = result[i][j];\n            }\n        }\n    }\n\n    // Sincroniza todos os processos antes de finalizar a medi\u00e7\u00e3o de tempo.\n    MPI_Barrier(MPI_COMM_WORLD);\n    auto end = std::chrono::high_resolution_clock::now(); // Finaliza a medi\u00e7\u00e3o de tempo.\n\n    // Calcula o tempo de execu\u00e7\u00e3o.\n    std::chrono::duration&lt;double&gt; duration = end - start;\n    double exec_time = duration.count(); // Tempo de execu\u00e7\u00e3o em segundos.\n\n    // Coleta os tempos de execu\u00e7\u00e3o de todos os processos e exibe no processo mestre.\n    double max_exec_time;\n    MPI_Reduce(&amp;exec_time, &amp;max_exec_time, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);\n\n    if (rank == 0) { // Apenas o processo mestre imprime o tempo de execu\u00e7\u00e3o.\n        std::cout &lt;&lt; \"A tarefa levou \" &lt;&lt; max_exec_time &lt;&lt; \" segundos para ser executada\" &lt;&lt; std::endl;\n    }\n\n    MPI_Finalize();  // Finaliza o ambiente MPI.\n    return 0;  // Retorna 0, indicando que o programa terminou com sucesso.\n}\n</code></pre> <p>Compile o programa dentro do Cluster:</p> <pre><code>mpic++ -fopenmp convolucao.cpp -o convolucao\n</code></pre>"},{"location":"aulas/02-slurm/#criacao-de-scripts-slurm","title":"Cria\u00e7\u00e3o de Scripts SLURM","text":"<p>Crie um arquivo convolucao_limitado.slurm com a seguinte configura\u00e7\u00e3o:</p> <p><pre><code>#!/bin/bash\n#SBATCH --job-name=convolucao_limitado    # Nome do job\n#SBATCH --output=limitado_%j.txt   # Gera um novo arquivo de sa\u00edda a cada execu\u00e7\u00e3o\n#SBATCH --ntasks=1                               # N\u00famero de tarefas (apenas 1 processos)\n#SBATCH --cpus-per-task=1                        # N\u00famero de threads por tarefa (apenas 1 thread por processo)\n#SBATCH --mem=512MB                             # Mem\u00f3ria total alocada por n\u00f3 (512 MB)\n#SBATCH --time=00:10:00                          # Tempo m\u00e1ximo de execu\u00e7\u00e3o (at\u00e9 10 minutos)\n#SBATCH --partition=espec                       # Fila do cluster a ser utilizada\n\n# Exporta a vari\u00e1vel de ambiente para configurar o n\u00famero de threads OpenMP\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n# Executa o programa usando MPI e OpenMP\nmpirun ./convolucao\n</code></pre> Este .slurm submete um job que executa 1 tarefas, com 1 CPU por tarefa, 512MB de mem\u00f3ria por n\u00f3, e um tempo m\u00e1ximo de execu\u00e7\u00e3o de 10 minutos.</p> <p>Vamos solicitar mais recursos e ver o que acontece, crie um arquivo convolucao_buffado.slurm com a seguinte configura\u00e7\u00e3o:</p> <p><pre><code>#!/bin/bash\n#SBATCH --job-name=convolucao_buffado             # Nome do job\n#SBATCH --output=buffado_%j.txt          # Nome do arquivo de sa\u00edda\n#SBATCH --ntasks=4                              # N\u00famero de tarefas (4 processos)\n#SBATCH --cpus-per-task=4                       # N\u00famero de threads por tarefa (2 threads por processo)\n#SBATCH --mem=1024                               # Mem\u00f3ria total alocada por n\u00f3 (1024 MB = 1 GB)\n#SBATCH --time=00:10:00                         # Tempo m\u00e1ximo de execu\u00e7\u00e3o (10 minutos)\n#SBATCH --partition=espec                      # fila do cluster a ser utilizada\n\n# Exporta a vari\u00e1vel de ambiente para configurar o n\u00famero de threads OpenMP\nexport OMP_NUM_THREADS=$SLURM_CPUS_PER_TASK\n\n\n# Executa o programa usando MPI e OpenMP\nmpirun ./convolucao\n</code></pre> Este .slurm submete um job que executa 4 tarefas simultaneamente, com 4 CPUs por tarefa, 1 GB de mem\u00f3ria por n\u00f3, e um tempo m\u00e1ximo de execu\u00e7\u00e3o de 10 minutos.</p>"},{"location":"aulas/02-slurm/#exploracao-dos-comandos-slurm","title":"Explora\u00e7\u00e3o dos Comandos SLURM","text":"<p>Submeta os jobs usando o comando <code>sbatch</code>:</p> <pre><code>sbatch convolucao_limitado.slurm\nsbatch convolucao_buffado.slurm\n</code></pre> <p>Execute o programa <code>convolucao</code> usando <code>srun</code>:</p> <p><pre><code>srun --ntasks=2 --cpus-per-task=2 --mem=500M ./convolucao\n</code></pre> O comando srun est\u00e1 solicitando ao SLURM que aloque os recursos necess\u00e1rios para executar o programa convolucao diretamente via terminal. Ele solicita 2 tarefas para serem executadas, cada tarefa ter\u00e1 acesso a 2 CPUs (ou n\u00facleos de processamento), e ter\u00e1 at\u00e9 500 MB de mem\u00f3ria dispon\u00edvel. </p> <p>Esse comando permite testar ou rodar programas interativamente com os recursos solicitados, podendo observar em tempo real o comportamento do programa.</p> <p>Utilize o comando <code>sinfo</code> para observar o estado dos n\u00f3s e das filas:</p> <pre><code>sinfo\n</code></pre> <p>Use o comando <code>squeue</code> para observar o estado dos jobs em execu\u00e7\u00e3o no Cluster Franky:</p> <pre><code>squeue\n</code></pre> <p>Utilize o comando <code>scancel</code> para cancelar um job:</p> <pre><code>scancel jobid\n</code></pre> <p>Use o comando <code>sprio</code> para visualizar a prioridade dos jobs:</p> <pre><code>sprio\n</code></pre> <p>Use <code>strigger</code> para definir um gatilho que notifique quando o job se aproximar do limite de tempo:</p> <p><pre><code>strigger --set --jobid=&lt;JOB_ID&gt; --threshold=60 --action=\"echo 'Job est\u00e1 pr\u00f3ximo de atingir o limite de tempo!'\"\n</code></pre> Explicando as flags</p> <p>--set: Indica que voc\u00ea est\u00e1 criando um novo gatilho. Este gatilho ser\u00e1 ativado quando a condi\u00e7\u00e3o especificada for atendida.</p> <p>--jobid=: Especifica o ID do job para o qual o gatilho ser\u00e1 configurado.  <p>--threshold=60: Define o limiar (threshold) de tempo restante para o job. Neste caso, o gatilho ser\u00e1 acionado quando o job tiver 60 segundos restantes antes de atingir seu limite de tempo de execu\u00e7\u00e3o. Sempre configure o tempo em segundos. </p> <p>--action=\"echo 'Job est\u00e1 pr\u00f3ximo de atingir o limite de tempo!'\": Especifica a a\u00e7\u00e3o que ser\u00e1 executada quando o gatilho for ativado. Neste exemplo, a a\u00e7\u00e3o \u00e9 um simples comando echo que imprimir\u00e1 a mensagem \"Job est\u00e1 pr\u00f3ximo de atingir o limite de tempo!\" no terminal ou no arquivo de sa\u00edda do job.</p> <p>Esse comando strigger define um gatilho que ser\u00e1 acionado automaticamente quando o job especificado () estiver a 60 segundos de atingir seu limite de tempo de execu\u00e7\u00e3o. Quando o gatilho for ativado, ele executar\u00e1 o comando especificado na op\u00e7\u00e3o --action, que neste caso \u00e9 imprimir uma mensagem de aviso. Se voc\u00ea tem um job que tem um tempo longo de execu\u00e7\u00e3o e voc\u00ea n\u00e3o quer ficar monitorando, pode configurar esse gatilho para ser notificado quando o tempo do job estiver prestes a terminar. <p>Tip</p> <p>Se quiser entender melhor sobre este comando e testar outros exemplos verifique o material dispon\u00edvel aqui</p>"},{"location":"aulas/02-slurm/#atividade-02-explorando-comandos-slurm","title":"Atividade 02: Explorando comandos SLURM","text":"<ol> <li> <p>Modifique o N\u00famero de Itera\u00e7\u00f5es da Convolu\u00e7\u00e3o no C\u00f3digo convolucao.cpp; Aumente o n\u00famero de itera\u00e7\u00f5es de    convolu\u00e7\u00e3o no c\u00f3digo para 30, 50, e 100. Isso aumentar\u00e1 a complexidade computacional, observe como o desempenho do c\u00f3digo \u00e9 afetado por essa modifica\u00e7\u00e3o.</p> </li> <li> <p>Ajuste o arquivo .slurm para garantir que os recursos de hardware (n\u00famero de tarefas, CPUs por tarefa, e mem\u00f3ria) e o tempo de execu\u00e7\u00e3o sejam adequados para processar o aumento no n\u00famero de itera\u00e7\u00f5es de convolu\u00e7\u00e3o. Experimente diferentes configura\u00e7\u00f5es de recursos para observar como eles impactam o tempo de execu\u00e7\u00e3o.</p> </li> <li> <p>Gere um gr\u00e1fico comparando o tempo de execu\u00e7\u00e3o do algoritmo para cada n\u00famero de itera\u00e7\u00f5es. Analise o impacto da aloca\u00e7\u00e3o de mais recursos, como o n\u00famero de CPUs e a quantidade de mem\u00f3ria, no tempo de execu\u00e7\u00e3o. </p> </li> <li> <p>Explore e explique como os comandos <code>sinfo</code>, <code>squeue</code>, <code>sprio</code>, <code>srun</code>, <code>sstat</code>, e <code>strigger</code> podem ser utilizados para monitorar e gerenciar jobs no cluster.</p> </li> </ol>"},{"location":"aulas/03-cpp/03-cpp/","title":"Aula 03 - Usando o C++ direito =D","text":""},{"location":"aulas/03-cpp/03-cpp/#1-passagem-de-parametros-e-manipulacao-de-arquivos","title":"1. Passagem de Par\u00e2metros e Manipula\u00e7\u00e3o de Arquivos","text":"<p>Objetivo: Praticar a passagem de par\u00e2metros por valor, refer\u00eancia e ponteiro em C++, al\u00e9m de trabalhar com leitura e escrita de arquivos.</p> <p>Exerc\u00edcio: - Implemente uma fun\u00e7\u00e3o que leia um arquivo de texto contendo n\u00fameros inteiros e armazene-os em um <code>std::vector&lt;int&gt;</code>. Use passagem por refer\u00eancia para garantir que o vetor seja preenchido corretamente. - Crie duas fun\u00e7\u00f5es: uma que dobra os valores no vetor usando passagem por refer\u00eancia, e outra que faz o mesmo usando ponteiros. - Escreva os valores dobrados em um novo arquivo de texto.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Os arquivos est\u00e3o dispon\u00edveis em entrada.txt, saida_ponteiro.txt, saida_referencia.txt</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda, usada para opera\u00e7\u00f5es como std::cout.\n#include &lt;fstream&gt;    // Inclui a biblioteca para manipula\u00e7\u00e3o de arquivos, usada para ler e escrever arquivos.\n#include &lt;vector&gt;     // Inclui a biblioteca de vetores, usada para armazenar e manipular listas de n\u00fameros.\n\n// Declara\u00e7\u00e3o de fun\u00e7\u00f5es:\n\n// Fun\u00e7\u00e3o que l\u00ea n\u00fameros de um arquivo e os armazena em um vetor.\nvoid lerArquivo(const std::string&amp; nomeArquivo, std::vector&lt;int&gt;&amp; numeros);\n\n// Fun\u00e7\u00e3o que dobra os valores de um vetor de n\u00fameros, passando o vetor original por refer\u00eancia.\nvoid dobrarValoresReferencia(const std::vector&lt;int&gt;&amp; numerosOriginais, std::vector&lt;int&gt;&amp; numerosDobrados);\n\n// Fun\u00e7\u00e3o que dobra os valores de um vetor de n\u00fameros, passando o vetor original por ponteiro.\nvoid dobrarValoresPonteiro(const std::vector&lt;int&gt;* numerosOriginais, std::vector&lt;int&gt;* numerosDobrados);\n\n// Fun\u00e7\u00e3o que escreve os n\u00fameros de um vetor em um arquivo.\nvoid escreverArquivo(const std::string&amp; nomeArquivo, const std::vector&lt;int&gt;&amp; numeros);\n\n// Implementa\u00e7\u00e3o das fun\u00e7\u00f5es...\n\nint main() {\n    // Declara\u00e7\u00e3o de dois vetores de inteiros: um para armazenar os n\u00fameros lidos do arquivo e outro para armazenar os n\u00fameros dobrados.\n    std::vector&lt;int&gt; numeros, numerosDobrados;\n\n    // Chama a fun\u00e7\u00e3o para ler os n\u00fameros do arquivo \"entrada.txt\" e armazena-os no vetor 'numeros'.\n    lerArquivo(\"entrada.txt\", numeros);\n\n    // Chama a fun\u00e7\u00e3o que dobra os valores do vetor 'numeros' usando passagem por refer\u00eancia e armazena o resultado no vetor 'numerosDobrados'.\n    dobrarValoresReferencia(numeros, numerosDobrados);\n\n    // Chama a fun\u00e7\u00e3o que escreve os n\u00fameros do vetor 'numerosDobrados' no arquivo \"saida_referencia.txt\".\n    escreverArquivo(\"saida_referencia.txt\", numerosDobrados);\n\n    // Chama a fun\u00e7\u00e3o que dobra os valores do vetor 'numeros' usando passagem por ponteiro e armazena o resultado no vetor 'numerosDobrados'.\n    dobrarValoresPonteiro(&amp;numeros, &amp;numerosDobrados);\n\n    // Chama a fun\u00e7\u00e3o que escreve os n\u00fameros do vetor 'numerosDobrados' no arquivo \"saida_ponteiro.txt\".\n    escreverArquivo(\"saida_ponteiro.txt\", numerosDobrados);\n\n    // Retorna 0, indicando que o programa terminou com sucesso.\n    return 0;\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#2-const-correctness","title":"2. Const Correctness","text":"<p>Objetivo: Praticar o uso de <code>const</code> para garantir a imutabilidade de dados onde necess\u00e1rio, melhorando a seguran\u00e7a e otimiza\u00e7\u00f5es de c\u00f3digo.</p> <p>Exerc\u00edcio: - Implemente uma fun\u00e7\u00e3o para multiplica\u00e7\u00e3o de matrizes que utiliza <code>const</code> para garantir que as matrizes de entrada n\u00e3o sejam modificadas. - Crie uma classe <code>Matriz</code> que encapsule as opera\u00e7\u00f5es b\u00e1sicas de uma matriz quadrada, utilizando m\u00e9todos <code>const</code> para opera\u00e7\u00f5es de leitura.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Classe Matriz para representar uma matriz quadrada\nclass Matriz {\npublic:\n    // Construtor que inicializa uma matriz quadrada de dimens\u00e3o N x N\n    Matriz(int N) {\n        data.resize(N, std::vector&lt;int&gt;(N, 0));  // Inicializa a matriz com zeros\n    }\n\n    // M\u00e9todo para acessar um elemento espec\u00edfico da matriz (leitura)\n    // Use 'const' para garantir que este m\u00e9todo n\u00e3o modifica a matriz\n    int get(int i, int j) const {\n        // Retorna o elemento na posi\u00e7\u00e3o (i, j)\n        return data[i][j];\n    }\n\n    // M\u00e9todo para modificar um elemento espec\u00edfico da matriz (escrita)\n    void set(int i, int j, int valor) {\n        // Modifica o elemento na posi\u00e7\u00e3o (i, j)\n        data[i][j] = valor;\n    }\n\n    // M\u00e9todo para imprimir a matriz\n    void imprime() const {\n        for (const auto&amp; linha : data) {\n            for (int valor : linha) {\n                std::cout &lt;&lt; valor &lt;&lt; \" \";\n            }\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n\n    // M\u00e9todo para acessar o tamanho da matriz (n\u00famero de linhas ou colunas)\n    int tamanho() const {\n        return data.size();\n    }\n\nprivate:\n    std::vector&lt;std::vector&lt;int&gt;&gt; data;  // Armazena os elementos da matriz\n};\n\n// Fun\u00e7\u00e3o que multiplica duas matrizes A e B, armazenando o resultado em C\n// Garanta que A e B s\u00e3o constantes para evitar modifica\u00e7\u00f5es\nvoid multiplicaMatriz(const Matriz&amp; A, const Matriz&amp; B, Matriz&amp; C) {\n    int N = A.tamanho();  // Sup\u00f5e que as matrizes s\u00e3o quadradas e de mesma dimens\u00e3o\n\n    // La\u00e7o para realizar a multiplica\u00e7\u00e3o de matrizes\n    for (int i = 0; i &lt; N; i++) {\n        for (int j = 0; j &lt; N; j++) {\n            int soma = 0;\n            for (int k = 0; k &lt; N; k++) {\n                // Multiplica os elementos correspondentes de A e B\n                soma += A.get(i, k) * B.get(k, j);\n            }\n            // Armazena o resultado em C\n            C.set(i, j, soma);\n        }\n    }\n}\n\nint main() {\n    int N = 3;  // Define o tamanho da matriz (N x N)\n\n    // Cria as matrizes: A, B, e C, todas de dimens\u00e3o N x N\n    Matriz A(N), B(N), C(N);\n\n    // Exemplo de preenchimento das matrizes A e B\n    // Sinta-se a vontade para modificar os valores\n    A.set(91, 16, 18); A.set(79, 1, 33); A.set(1, 2, 3);\n    A.set(31, 42, 43); A.set(61, 12, 53); A.set(4, 5, 6);\n    A.set(2, 52, 79); A.set(25, 18, 85); A.set(7, 8, 9);\n\n    B.set(13, 23, 9); B.set(14, 62, 8); B.set(13, 2, 47);\n    B.set(1, 42, 6); B.set(22, 75, 5); B.set(17, 2, 54);\n    B.set(2, 59, 3); B.set(2, 44, 2); B.set(98, 2, 74);\n\n    // Multiplica as matrizes A e B, armazenando o resultado em C\n    multiplicaMatriz(A, B, C);\n\n    // Imprime a matriz resultante C\n    C.imprime();\n\n    return 0;  // Retorna 0, indicando que o programa terminou com sucesso\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#3-alocacao-de-memoria-dinamica","title":"3. Aloca\u00e7\u00e3o de Mem\u00f3ria Din\u00e2mica","text":"<p>Objetivo: Entender a aloca\u00e7\u00e3o e libera\u00e7\u00e3o de mem\u00f3ria din\u00e2mica em C++, muito importante para gerenciar grandes volumes de dados em HPC.</p> <p>Exerc\u00edcio: - Implemente uma fun\u00e7\u00e3o que aloca dinamicamente uma matriz de inteiros de tamanho N x N e realiza uma soma simples de todos os seus elementos. - Em seguida, substitua a aloca\u00e7\u00e3o din\u00e2mica manual pela utiliza\u00e7\u00e3o de <code>std::vector</code> e compare o desempenho das duas abordagens.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;   // Inclui a biblioteca padr\u00e3o de entrada e sa\u00edda, usada para opera\u00e7\u00f5es como std::cout.\n#include &lt;chrono&gt;     // Inclui a biblioteca para medi\u00e7\u00e3o de tempo, usada para medir a performance do c\u00f3digo.\n\nint main() {\n    int N = 1000;  // Define o tamanho da matriz como N x N, onde N \u00e9 1000.\n\n    // Aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria para uma matriz N x N.\n    // Primeiro, aloca um array de ponteiros, onde cada ponteiro ir\u00e1 apontar para uma linha da matriz.\n    int** matriz = new int*[N];\n\n    // Para cada linha da matriz, aloca um array de inteiros de tamanho N.\n    for (int i = 0; i &lt; N; ++i) {\n        matriz[i] = new int[N];\n    }\n\n    // Aqui voc\u00ea pode inicializar e somar os elementos da matriz.\n    // Por exemplo, voc\u00ea pode preencher a matriz com valores e calcular a soma total.\n\n    // Libera\u00e7\u00e3o da mem\u00f3ria alocada dinamicamente.\n    // Primeiro, libera a mem\u00f3ria alocada para cada linha (os arrays de inteiros).\n    for (int i = 0; i &lt; N; ++i) {\n        delete[] matriz[i];\n    }\n\n    // Finalmente, libera a mem\u00f3ria alocada para o array de ponteiros.\n    delete[] matriz;\n\n    return 0;  // Retorna 0, indicando que o programa terminou com sucesso.\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#algumas-dicas","title":"Algumas dicas","text":"<p>1 - Para alocar dinamicamente uma matriz <code>N x N</code>, voc\u00ea precisar\u00e1 criar um ponteiro para um ponteiro (ou seja, um array de ponteiros) e, em seguida, alocar um espa\u00e7o de mem\u00f3ria para cada linha da matriz.</p> <p>2 - Ap\u00f3s alocar a matriz, voc\u00ea pode preench\u00ea-la com valores (por exemplo, aleat\u00f3rios ou sequenciais) e somar todos os elementos.</p> <p>3 - \u00c9 fundamental liberar toda a mem\u00f3ria alocada dinamicamente para evitar vazamentos de mem\u00f3ria. Isso significa liberar cada linha e depois o array de ponteiros.</p> <p>4 - Use a biblioteca chrono para medir o tempo de execu\u00e7\u00e3o das partes chave do seu c\u00f3digo.</p>"},{"location":"aulas/03-cpp/03-cpp/#perguntas-para-reflexao","title":"Perguntas para Reflex\u00e3o:","text":"<p>Qual abordagem foi mais r\u00e1pida? Quais vantagens voc\u00ea percebe ao usar <code>std::vector</code>? Como a aloca\u00e7\u00e3o autom\u00e1tica e a libera\u00e7\u00e3o de mem\u00f3ria pelo <code>std::vector</code> afetam a seguran\u00e7a e robustez do c\u00f3digo?</p>"},{"location":"aulas/03-cpp/03-cpp/#4-manipulacao-de-vetores","title":"4. Manipula\u00e7\u00e3o de Vetores","text":"<p>Objetivo: Trabalhar com <code>std::vector</code> para realizar opera\u00e7\u00f5es comuns em HPC, como a inicializa\u00e7\u00e3o, modifica\u00e7\u00e3o, e itera\u00e7\u00e3o sobre grandes conjuntos de dados.</p> <p>Exerc\u00edcio: - Implemente uma fun\u00e7\u00e3o que inicializa um vetor com valores espec\u00edficos e realiza opera\u00e7\u00f5es matem\u00e1ticas b\u00e1sicas, como multiplica\u00e7\u00e3o por um escalar. - Crie uma classe <code>Vector</code> que encapsule a l\u00f3gica de manipula\u00e7\u00e3o de vetores, incluindo m\u00e9todos para adicionar, remover e acessar elementos. Garanta que a classe seja eficiente usando aloca\u00e7\u00e3o din\u00e2mica e fun\u00e7\u00f5es <code>inline</code>.</p> <p>Tip</p> <p>N\u00e3o faz ideia de como come\u00e7ar? leia o material dispon\u00edvel aqui ou consulte a documenta\u00e7\u00e3o oficial</p> <p>Pontap\u00e9 Inicial:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass Vector {\npublic:\n    Vector(int tamanho);\n    ~Vector();\n    void inicializa(int valor);\n    int get(int index) const;\n    void set(int index, int valor);\n    void inserir(int index, int valor);\n    void remover(int index);\n    void imprime() const;\n\nprivate:\n    int* dados;\n    int tam;\n    int capacidade;\n    void redimensiona(int novaCapacidade);\n};\n\n// Implementa\u00e7\u00e3o das fun\u00e7\u00f5es...\n\nint main() {\n    Vector vec(5);\n    vec.inicializa(0);\n    vec.imprime();\n\n    return 0;\n}\n</code></pre>"},{"location":"aulas/03-cpp/03-cpp/#entrega-da-atividade-03","title":"Entrega da Atividade 03","text":"<p>Crie um reposit\u00f3rio no GitHub com os seus c\u00f3digos e an\u00e1lises, envie o link pelo BlackBoard</p>"},{"location":"aulas/04-profiling/","title":"04 - Medi\u00e7\u00e3o de desempenho","text":"<p>Apesar de podermos medir o tempo que nosso programa demora usando o comando <code>time</code>, n\u00e3o conseguimos nenhuma informa\u00e7\u00e3o importante de qual parte do programa est\u00e1 consumindo mais tempo. Este processo de dissecar um programa e entender exatamente qual parte demora quanto \u00e9 chamada de Profiling. </p> <p>Software</p> <p>Para esta aula precisaremos dos seguintes pacotes instalados. </p> <ul> <li><code>valgrind</code> - ferramenta de an\u00e1lise de c\u00f3digo execut\u00e1vel</li> <li><code>kcachegrind</code> - visualizador de resultados do <code>valgrind</code></li> </ul>"},{"location":"aulas/04-profiling/#warm-up-o-problema-da-soma-de-uma-matriz","title":"Warm-up: O problema da soma de uma matriz","text":"<p>O c\u00f3digo abaixo apresenta duas formas de realizar a soma de todos os elementos de uma matriz. </p> <p>Compile o c\u00f3digo e execute.</p> <p>Voc\u00ea sabe dizer qual a diferen\u00e7a de <code>naive_sum</code> e <code>improved_sum</code>?</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconstexpr int M = 2048;\nconstexpr int N = 2048;\n\ndouble naive_sum(const double a[][N]){\n    double sum = 0.0;\n    for(int j = 0; j &lt; N; ++j) {\n        for(int i = 0; i &lt; M; ++i)\n            sum += a[i][j];\n    }\n    return sum;\n}\n\ndouble improved_sum(const double a[][N]) {\n    double sum = 0.0;\n    for(int i = 0; i &lt; M; ++i)\n        for(int j = 0; j &lt; N; ++j)\n            sum +=a[i][j];\n    return sum;\n}\n\nint main() {\n    static double a[M][N];\n    fill_n(&amp;a[0][0], M*N, 1.0 / (M*N));\n    cout &lt;&lt; naive_sum(a) &lt;&lt; endl;\n    static double b[M][N];\n    fill_n(&amp;b[0][0], M*N, 1.0 / (M*N));\n    cout &lt;&lt; improved_sum(b) &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Vamos usar o <code>Valgrind</code> para verificar se h\u00e1 diferen\u00e7as entre <code>naive_sum</code> e <code>improved_sum</code>. </p> <p>Supondo que o seu arquivo se chama <code>sum.cpp</code> execute:</p> <pre><code>g++ -Wall -O3 -g sum.cpp -o sum\n</code></pre> <p>E execute ent\u00e3o programa via <code>valgrind</code>:</p> <pre><code>valgrind --tool=callgrind ./sum\n</code></pre> <p>O <code>valgrind</code> ir\u00e1 retornar algo como:</p> <pre><code>==3079146== Callgrind, a call-graph generating cache profiler\n==3079146== Copyright (C) 2002-2017, and GNU GPL'd, by Josef Weidendorfer et al.\n==3079146== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info\n==3079146== Command: ./sum\n==3079146== \n==3079146== For interactive control, run 'callgrind_control -h'.\n1\n1\n==3079146== \n==3079146== Events    : Ir\n==3079146== Collected : 50553796\n==3079146== \n==3079146== I   refs:      50,553,796\n</code></pre> <p>Onde <code>3079146</code> \u00e9 o PID da execu\u00e7\u00e3o. Na sua m\u00e1quina ser\u00e1 um outro valor. Ele tamb\u00e9m gerou um arquivo <code>callgrind.out.{PID}</code>. </p> <p>Execute a ferramenta <code>callgrind_annotate</code> para verificar o resultado do profiling.</p> <pre><code>callgrind_annotate callgrind.out.3079146 sum.cpp \n</code></pre> <p>E seu output ser\u00e1 como segue:</p> <pre><code>--------------------------------------------------------------------------------\nProfile data file 'callgrind.out.3079146' (creator: callgrind-3.15.0)\n--------------------------------------------------------------------------------\nI1 cache: \nD1 cache: \nLL cache: \nTimerange: Basic block 0 - 10863316\nTrigger: Program termination\nProfiled target:  ./sum (PID 3079146, part 1)\nEvents recorded:  Ir\nEvents shown:     Ir\nEvent sort order: Ir\nThresholds:       99\nInclude dirs:     \nUser annotated:   sum.cpp\nAuto-annotation:  off\n\n--------------------------------------------------------------------------------\nIr         \n--------------------------------------------------------------------------------\n50,553,796  PROGRAM TOTALS\n\n--------------------------------------------------------------------------------\nIr          file:function\n--------------------------------------------------------------------------------\n31,479,818  sum.cpp:main [/home/user/andre/profile/sum]\n16,777,221  /usr/include/c++/9/bits/stl_algobase.h:main\n   948,840  /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:_dl_lookup_symbol_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so]\n   554,233  /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:do_lookup_x [/usr/lib/x86_64-linux-gnu/ld-2.31.so]\n   273,488  /build/glibc-eX1tMB/glibc-2.31/elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object\n   117,179  /build/glibc-eX1tMB/glibc-2.31/elf/dl-lookup.c:check_match [/usr/lib/x86_64-linux-gnu/ld-2.31.so]\n\n--------------------------------------------------------------------------------\n-- User-annotated source: sum.cpp\n--------------------------------------------------------------------------------\nIr         \n\n         .  #include&lt;iostream&gt;\n         .  #include&lt;algorithm&gt;\n         .  using namespace std;\n         .  \n         .  constexpr int M = 2048;\n         .  constexpr int N = 2048;\n         .  \n         .  double naive_sum(const double a[][N]){\n         1      double sum = 0.0;\n     6,144      for(int j = 0; j &lt; N; ++j) {\n12,587,008          for(int i = 0; i &lt; M; ++i)\n 4,194,304              sum += a[i][j];\n         .      }\n         .      return sum;\n         .  }\n         .  \n         .  double improved_sum(const double a[][N]) {\n     4,097      double sum = 0.0;\n     8,192      for(int i = 0; i &lt; M; ++i)\n 4,194,304          for(int j = 0; j &lt; N; ++j)\n10,485,760              sum +=a[i][j];\n         .      return sum;\n         .  }\n         .  \n         5  int main() {\n         .      static double a[M][N];\n         .      fill_n(&amp;a[0][0], M*N, 1.0 / (M*N));\n         .      cout &lt;&lt; naive_sum(a) &lt;&lt; endl;\n         .      static double b[M][N];\n         .      fill_n(&amp;b[0][0], M*N, 1.0 / (M*N));\n         .      cout &lt;&lt; improved_sum(b) &lt;&lt; endl;\n         .      return 0;\n         6  }\n\n--------------------------------------------------------------------------------\nIr         \n--------------------------------------------------------------------------------\n31,479,821  events annotated\n</code></pre> <p>O que voc\u00ea pode dizer sobre o desempenho do programa? Por que h\u00e1 diferen\u00e7a de <code>instruction fetch</code> (IR) entre <code>naive_sum</code> e <code>improved_sum</code>?</p> <p>Tip</p> <p>Dica: Verifique a discuss\u00e3o no StackOverflow sobre isso. Neste link https://stackoverflow.com/questions/9936132/why-does-the-order-of-the-loops-affect-performance-when-iterating-over-a-2d-arra</p>"},{"location":"aulas/04-profiling/#visualizacao-grafica","title":"Visualiza\u00e7\u00e3o gr\u00e1fica","text":"<p>Muitas vezes o output do valgrind \u00e9 suficiente para a nossa an\u00e1lise. Todavia, \u00e9 poss\u00edvel tamb\u00e9m obter visualiza\u00e7\u00f5es gr\u00e1ficas do n\u00famero de chamadas das fun\u00e7\u00f5es. H\u00e1 uma ferramenta bem interessante, desenvolvida em Python, denominada <code>gprof2dot</code>. Essa ferramenta converte dados de perfil de desempenho, gerados por ferramentas como o Callgrind do Valgrind, em gr\u00e1ficos de chamadas visualmente compreens\u00edveis. Ao processar os resultados de profiling, ele cria um gr\u00e1fico que representa as intera\u00e7\u00f5es entre fun\u00e7\u00f5es, evidenciando as chamadas mais onerosas e ajudando a identificar gargalos de desempenho em um programa. Isso permite uma an\u00e1lise mais intuitiva e abrangente das rela\u00e7\u00f5es entre as fun\u00e7\u00f5es e a aloca\u00e7\u00e3o de recursos computacionais, auxiliando na otimiza\u00e7\u00e3o de c\u00f3digos e no aprimoramento da efici\u00eancia do software.</p> <p>Vamos fazer um teste nessa ferramenta? Para isso, voc\u00ea vai precisar instalar a bibliteca <code>graphviz</code> (com <code>apt-get install graphviz</code>, por exemplo) e tamb\u00e9m a biblioteca <code>gprof2dot</code> do Python (com <code>pip install gprof2dot</code>).</p> <p>Considere o seguinte c\u00f3digo em C++ para analisarmos com essa ferramenta:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;chrono&gt;\n\nvoid heavyCalculation() {\n    for (int i = 0; i &lt; 100000; ++i) {\n        double result = std::sqrt(static_cast&lt;double&gt;(i));\n    }\n}\n\nvoid intermediateFunction() {\n    for (int i = 0; i &lt; 1000; ++i) {\n        heavyCalculation();\n    }\n}\n\nvoid mainFunction() {\n    for (int i = 0; i &lt; 5; ++i) {\n        intermediateFunction();\n    }\n}\n\nint main() {\n    auto start = std::chrono::high_resolution_clock::now();\n\n    mainFunction();\n\n    auto end = std::chrono::high_resolution_clock::now();\n    auto duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start);\n\n    std::cout &lt;&lt; \"Time taken: \" &lt;&lt; duration.count() &lt;&lt; \" milliseconds\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Nesse c\u00f3digo, temos tr\u00eas fun\u00e7\u00f5es:</p> <ul> <li> <p>heavyCalculation: Uma fun\u00e7\u00e3o que realiza um grande n\u00famero de opera\u00e7\u00f5es matem\u00e1ticas (c\u00e1lculos de raiz quadrada) em um loop.</p> </li> <li> <p>intermediateFunction: Chama a fun\u00e7\u00e3o heavyCalculation repetidamente para criar um cen\u00e1rio onde a fun\u00e7\u00e3o intermedi\u00e1ria \u00e9 onerosa.</p> </li> <li> <p>mainFunction: Chama a fun\u00e7\u00e3o intermedi\u00e1ria v\u00e1rias vezes.</p> </li> </ul> <p>Ao executar esse c\u00f3digo, voc\u00ea deve obter um tempo de execu\u00e7\u00e3o consider\u00e1vel, j\u00e1 que o loop dentro de heavyCalculation \u00e9 repetido muitas vezes. Isso deve gerar um perfil de desempenho interessante quando analisado com o gprof2dot.py.</p> <p>Ao compilar, use a op\u00e7\u00e3o <code>-O0</code>, para que o compilador n\u00e3o otimize as chamadas recorrentes e possamos visualizar melhor nosso grafo.</p> <p>Supondo que seu c\u00f3digo foi salvo com o nome <code>profile.cpp</code>, execute os seguintes comandos:</p> <pre><code>g++ -Wall -O0 -g profile.cpp -o profile\n</code></pre> <p>Na sequencia, execute o valgrind:</p> <pre><code>valgrind --tool=callgrind ./profile\n</code></pre> <p>Neste caso, um poss\u00edvel output seria:</p> <pre><code>==9228== Callgrind, a call-graph generating cache profiler\n==9228== Copyright (C) 2002-2017, and GNU GPL'd, by Josef Weidendorfer et al.\n==9228== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info\n==9228== Command: ./profile\n==9228== \n==9228== For interactive control, run 'callgrind_control -h'.\nTime taken: 243965 milliseconds\n==9228== \n==9228== Events    : Ir\n==9228== Collected : 10002410933\n==9228== \n==9228== I   refs:      10,002,410,933\n</code></pre> <p>Por fim, execute a gprof2dot:</p> <pre><code>!gprof2dot  -n0.1 -f callgrind callgrind.out.9228 | dot -Tsvg -o output.svg\n</code></pre> <p>Voc\u00ea deve obter um grafo similar ao abaixo:</p> <p></p>"},{"location":"aulas/04-profiling/#distancia-euclides-ingenuo","title":"Dist\u00e2ncia: Euclides ing\u00eanuo","text":"<p>Compile o c\u00f3digo-fonte da implementa\u00e7\u00e3o ing\u00eanua que fizemos na aula passada, com profiling habilitado para medir os tempos de execu\u00e7\u00e3o. </p> <pre><code>g++ -g euclides-ingenuo.cpp -o euclides-ingenuo\n</code></pre> <p>Ap\u00f3s este passo, execute o programa usando o <code>valgrind</code> com as op\u00e7\u00f5es abaixo.</p> <pre><code>valgrind --tool=callgrind ./seu_exec &lt; entrada &gt; saida\n</code></pre> <p>Para mostrar os resultados usando o <code>kcachegrind</code> usamos o seguinte comando. </p> <pre><code>kcachegrind callgrind.out.(pid aqui)\n</code></pre> <p>O que tomou mais tempo de execu\u00e7\u00e3o da vers\u00e3o ing\u00eanua?</p>"},{"location":"aulas/04-profiling/#medindo-os-tempos-no-seu-proprio-programa","title":"Medindo os tempos no seu pr\u00f3prio programa","text":"<p>Voc\u00ea vai perceber, ao executar a atividade anterior, que boa parte do tempo \u00e9 gasto mostrando a sa\u00edda no terminal. Isto nos leva \u00e0 primeira conclus\u00e3o da atividade de hoje:</p> <p>Entrada e sa\u00edda de dados s\u00e3o opera\u00e7\u00f5es muito lentas</p> <p>Example</p> <p>Fa\u00e7a o teste da demonstra\u00e7\u00e3o em seu pr\u00f3prio programa e anote abaixo, para as duas vers\u00f5es de <code>calcula_distancias</code>,</p> <ol> <li>o tempo relativo de execu\u00e7\u00e3o </li> <li>o n\u00famero absoluto de instru\u00e7\u00f5es executadas</li> </ol> <p>Question</p> <p>O n\u00famero absoluto de intru\u00e7\u00f5es executadas diminuiu significativamente depois de nossa otimiza\u00e7\u00e3o? Teoricamente s\u00f3 calculamos metade da matriz, esse n\u00famero \u00e9 quase metade da vers\u00e3o n\u00e3o otimizada? Voc\u00ea consegue dizer por que?</p> Resposta <p>Deve ter havido uma diminui\u00e7\u00e3o, mas n\u00e3o chega nem perto de metade. Isso ocorre por v\u00e1rias raz\u00f5es:</p> <ol> <li>nosso <code>for</code> duplo continua percorrendo a matriz inteira, apesar de s\u00f3 fazer o c\u00e1lculo em metade das posi\u00e7\u00f5es. </li> <li>alocamos a matriz elemento a elemento enquanto fazemos os c\u00e1lculos.</li> </ol> <p>Com isso em mente, vamos agora otimizar a fun\u00e7\u00e3o <code>calcula_distancias</code>. J\u00e1 sabemos que o efeito no tempo final n\u00e3o ser\u00e1 grande. Nosso objetivo ent\u00e3o ser\u00e1 verificar a seguinte afirma\u00e7\u00e3o. </p> <p>Dois algoritmos de mesma complexidade computacional podem ter tempos de execu\u00e7\u00e3o muito diferentes</p> <p>Question</p> <p>A resposta da quest\u00e3o anterior indica que s\u00f3 usar um <code>if</code> para evitar o c\u00e1lculo repetido n\u00e3o \u00e9 suficiente. Precisamos efetivamente fazer um <code>for</code> que percorre s\u00f3 metade da matriz. Supondo que a matriz j\u00e1 esteja inteira alocada, escreva em pseudo-c\u00f3digo como faz\u00ea-lo.</p> Resposta <pre><code>para i=1..N:\n    para j=i..N:\n        DX = X[i] - X[j]\n        DY = Y[i] - Y[j]\n        DIST = sqrt(DX*DX + DY*DY)\n        D[i,j] = DIST\n        D[j,i] = DIST\n</code></pre>"},{"location":"aulas/04-profiling/#matrizes-versao-2","title":"Matrizes (vers\u00e3o 2)","text":"<p>Nossa implementa\u00e7\u00e3o usando <code>vector&lt;vector&lt;double&gt;&gt;</code> tem um problema s\u00e9rio: ela aloca elemento a elemento uma estrutura grande que j\u00e1 sabemos o tamanho de in\u00edcio. Seria muito melhor se pud\u00e9ssemos alocar todas as N^2 posi\u00e7\u00f5es da matriz de  uma s\u00f3 vez!</p> <p>Fazemos isso trabalhando com um layout de mem\u00f3ria cont\u00ednuo. Ou seja, armazenaremos a matriz linha a linha como um \u00fanico vetor de tamanho <code>n*n</code>. Temos v\u00e1rias vantagens:</p> <ol> <li>tempo de aloca\u00e7\u00e3o de mem\u00f3ria \u00e9 reduzido, j\u00e1 que s\u00f3 fazemos uma chamada</li> <li>podemos acessar qualquer posi\u00e7\u00e3o a qualquer momento</li> <li>melhor desempenho de cache</li> </ol> <p>A figura abaixo exemplifica esse layout de mem\u00f3ria:</p> <p></p> <p>Question</p> <p>Em uma matriz de tamanho <code>4x7</code> (4 linhas, 7 colunas), qual \u00e9 o elemento do vetor que representa a posi\u00e7\u00e3o <code>2x5</code> (linha 3, coluna 6)?</p> Details <p>Estamos considerando que come\u00e7amos a contar as linhas e colunas do zero. A posi\u00e7\u00e3o do vetor \u00e9 <code>19</code>. Este n\u00famero \u00e9 obtido pela express\u00e3o</p> <p><code>i * c + j</code></p> <ul> <li><code>i</code> \u00e9 a linha a ser acessada</li> <li><code>j</code> \u00e9 a coluna</li> <li><code>c</code> \u00e9 o n\u00famero de colunas da matriz</li> </ul> <p><code>19 = 2 * 7 + 5</code></p> <p>Tip</p> <p>Conseguimos redimensionar um vetor usando o m\u00e9todo <code>resize</code>, que recebe o novo n\u00famero de elementos do vetor. </p> <p>Example</p> <p>Fa\u00e7a uma terceira vers\u00e3o de <code>calcula_distancias</code>, desta vez usando o layout de mem\u00f3ria acima. Verifique que o programa continua retornando os mesmos resultados que as vers\u00f5es anteriores. </p> <p>Question</p> <p>Rode novamente os testes de profiling e verifique o n\u00famero de instru\u00e7\u00f5es para esta nova vers\u00e3o. Compare este valor com os anteriores e comente. </p>"},{"location":"aulas/05-heuristicas/","title":"05 - Heur\u00edsticas","text":"<p>A atividade pr\u00e1tica de hoje consiste em implementar heur\u00edsticas para a solu\u00e7\u00e3o do problema da Mochila bin\u00e1ria.</p>"},{"location":"aulas/05-heuristicas/#resumo-do-problema","title":"Resumo do problema","text":"<p>Dados <code>N</code> objetos e uma mochila que comporta at\u00e9 <code>W</code> quilos, cada um com peso w_i e valor v_i, selecionar objetos com o maior valor poss\u00edvel que caibam dentro da mochila.</p> <p>Entrada: <pre><code>N W\nw1 v1\n....\nwN vN\n</code></pre></p> <p>Sa\u00edda: <pre><code>W V opt\no1 ... oT\n</code></pre></p> <ul> <li><code>W</code> - peso dos objetos selecionados</li> <li><code>V</code> - valor dos objetos selecionados</li> <li><code>opt</code><ul> <li><code>0</code> se for usada uma heur\u00edstica ou busca local</li> <li><code>1</code> se a solu\u00e7\u00e3o for \u00f3timo global</li> </ul> </li> <li><code>oi</code> s\u00e3o os \u00edndices (em ordem crescente) dos objetos selecionados</li> </ul> <p>Tip</p> <p>Arquivos para verificar a corretude das suas implementa\u00e7\u00f5es est\u00e3o dispon\u00edveis nesta pasta. Eles est\u00e3o nomeados como <code>in-*.txt</code>, <code>mais-caro-out-*.txt</code> e <code>mais-leve-out-*.txt</code>.</p>"},{"location":"aulas/05-heuristicas/#mais-caro-primeiro","title":"Mais caro primeiro","text":"<p>A ideia desta heur\u00edstica \u00e9 n\u00e3o deixar nenhum objeto valioso para tr\u00e1s! Por isso vamos ser ganaciosos e pegar primeiro os objetos mais caros! Se um objeto valioso n\u00e3o couber passamos para os mais baratos e prosseguimos at\u00e9 examinar todos objetos.</p> <p>Question</p> <p>Escreva abaixo um algoritmo em pseudo-c\u00f3digo para implementar a heur\u00edstica descrita acima.</p> Resposta <pre><code>ids = // vetor inicializado com ids[i] = i\nordene os vetores ids, v e w de acordo com o vetor de valores v\npeso = 0\nvalor = 0\nresposta = //vetor inicializado com 0\nT = 0 // n\u00famero de objetos selecionados\npara i=1..N\n    se peso + w[i] &lt; W ent\u00e3o\n        resposta[T] = ids[i]\n        peso += w[i]\n        valor += v[i]\n        T += 1\n\nprint peso, valor, 0\nprint resposta[0 .. T]\n</code></pre> <p>Question</p> <p>Qual \u00e9 a complexidade computacional deste algoritmo? Ele \u00e9 a melhor implementa\u00e7\u00e3o poss\u00edvel?</p> Resposta <p>Se o algoritmo descrito em sua resposta anterior envolver ordena\u00e7\u00e3o, ent\u00e3o ele tem complexidade \\mathcal{O}(n\\log n) e \u00e9 o melhor poss\u00edvel sim (voc\u00ea consegue explicar por que?). Se voc\u00ea fez um loop duplo que procura pelo maior a cada itera\u00e7\u00e3o ent\u00e3o seu algoritmo \u00e9 \\mathcal{O}(n^2).</p> <p>Example</p> <p>Agora que temos um algoritmo, crie uma implementa\u00e7\u00e3o do programa acima.</p> <p>Dicas:</p> <ul> <li>C++ j\u00e1 possui um algoritmo de ordena\u00e7\u00e3o implementado no cabe\u00e7alho <code>&lt;algorithm&gt;</code>. Use-o.</li> <li>Busque por ordena\u00e7\u00e3o indireta para entender como ordenar os tr\u00eas vetores ao mesmo tempo.</li> <li>Pode ser conveniente organizar os dados usando <code>struct</code>.</li> </ul>"},{"location":"aulas/05-heuristicas/#mais-leve-primeiro","title":"Mais leve primeiro","text":"<p>Vamos testar uma abordagem oposta: quantidade agora \u00e9 o foco. Por isso vamos ser pr\u00e1ticos e pegar o maior n\u00famero de objetos poss\u00edvel! Come\u00e7aremos agora pelos objetos mais leves e vamos torcer para que a quantidade grande de objetos selecionados resulte em uma mochila com alto valor.</p> <p>Question</p> <p>Compare esta heur\u00edstica com a da se\u00e7\u00e3o anterior levando em conta o algoritmo em pseudo-c\u00f3digo e sua complexidade computacional.</p> <p>Question</p> <p>Quais partes do programa da heur\u00edstica anterior podem ser aproveitadas para implementar a descrita acima?</p> <p>Example</p> <p>Implemente agora a heur\u00edstica do mais leve. Chame seu programa de <code>mais_leve</code>, mantendo tamb\u00e9m o c\u00f3digo do anterior.</p>"},{"location":"aulas/05-heuristicas/#analisando-nossas-heuristicas","title":"Analisando nossas heur\u00edsticas","text":"<p>Question</p> <p>Crie uma entrada em que a heur\u00edstica do mais valioso seja muito melhor que a do mais leve. Escreva abaixo as sa\u00eddas de cada programa.</p> <p>Question</p> <p>Crie uma entrada em que a heur\u00edstica do mais leve seja muito melhor que a do mais valioso. Escreva abaixo as sa\u00eddas de cada programa.</p> <p>Question</p> <p>Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais valioso \u00e9 melhor?</p> <p>Question</p> <p>Com base nas suas respostas acima, em quais situa\u00e7\u00f5es a heur\u00edstica do mais leve \u00e9 melhor?</p>"},{"location":"aulas/06-aleatorizacao/","title":"06 - Algoritmos Aleatorizados","text":"<p>Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar:</p> <ul> <li>determin\u00edstico: Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed. Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada (seed).</li> <li>parece aleat\u00f3ria: Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual sequ\u00eancia foi gerada pelo RNG.</li> </ul> <p>Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio</p> <ol> <li>que o programa permita escolher o seed da simula\u00e7\u00e3o;</li> <li>que o seed usado seja publicado junto com os resultados.</li> </ol> <p>Question</p> <p>E se quisermos gerar uma sequ\u00eancia diferente a cada execu\u00e7\u00e3o do programa? Como poder\u00edamos configurar o seed para que isto aconte\u00e7a?</p>"},{"location":"aulas/06-aleatorizacao/#iniciando-com-rngs","title":"Iniciando com RNGs","text":"<p>Muitas implementa\u00e7\u00f5es de RNGs  s\u00e3o divididas em duas partes:</p> <ol> <li>engine/random state: algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria.</li> <li>distribution: utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme).</li> </ol> <p>Question</p> <p>A biblioteca padr\u00e3o de C++ disponibiliza diversas fun\u00e7\u00f5es para utiliza\u00e7\u00e3o de *RNG*s (cabe\u00e7alho <code>&lt;random&gt;</code> - documenta\u00e7\u00e3o neste link). Se voc\u00ea quisesse sortear n\u00fameros aleat\u00f3rios inteiros entre <code>-2</code> e <code>5</code> quais fun\u00e7\u00f5es usaria?</p> Resposta <pre><code>#include &lt;random&gt;\n\n...\n\nstd::default_random_engine generator;\nstd::uniform_int_distribution&lt;int&gt; distribution(-2,5);\ndistribution(generator); // gera n\u00famero\n</code></pre> <p>Question</p> <p>E se voc\u00ea quisesse sortear um n\u00famero real entre <code>0</code> e <code>1</code>?</p> Resposta <pre><code>#include &lt;random&gt;\n\n...\n\nstd::default_random_engine generator;\nstd::uniform_real_distribution&lt;double&gt; distribution(0.0, 1.0);\ndistribution(generator); // gera n\u00famero\n</code></pre> <p>Agora que voc\u00ea j\u00e1 consegue gerar n\u00fameros aleat\u00f3rios, vamos implementar nossa primeira vers\u00e3o de uma heur\u00edstica aleatorizada.</p> <p>Example</p> <p>Adicionaremos a seguinte varia\u00e7\u00e3o na nossa heur\u00edstica: a cada passo de sele\u00e7\u00e3o temos <code>25%</code> de chance de selecionar um objeto aleat\u00f3rio que ainda n\u00e3o foi utilizado. Ou seja, cada passo do algoritmo segue a seguinte regra</p> <ol> <li>Fa\u00e7a um sorteio aleat\u00f3rio</li> <li>Com probabilidade <code>75%</code> pegue o pr\u00f3ximo objeto n\u00e3o selecionado de acordo com a heur\u00edstica (mais leve ou mais caro)</li> <li>Com probabilidade <code>25%</code> selecione um objeto qualquer dos que n\u00e3o foram analisados ainda.</li> </ol> <p>Note que n\u00e3o mudamos o pr\u00f3ximo elemento ao fazer a sele\u00e7\u00e3o aleat\u00f3ria. Adote <code>seed=10</code> nesta tarefa.</p> <p>Dica: agora \u00e9 poss\u00edvel que eu olhe um produto mais de uma vez. Voc\u00ea precisar\u00e1 checar isso no seu programa!</p> Resposta <p>Os arquivos <code>in-*.txt</code> cont\u00e9m entradas para teste. Os arquivos <code>out-caro-(rand-?)*.txt</code> cont\u00e9m as sa\u00eddas esperadas para as heur\u00edsticas do mais caro. Note que como estamos falando de uma probabilidade, o sorteio dever\u00e1 ser feito no intervalo <code>[0, 1]</code>.</p> <p>Question</p> <p>Rode a heur\u00edstica aleatorizada 10 vezes (como fazer isso?) e anote os valores das mochilas obtidas. Em m\u00e9dia, \u00e9 melhor ou pior que a heuristca sem aleatoriza\u00e7\u00e3o?</p>"},{"location":"aulas/06-aleatorizacao/#construindo-uma-solucao-inteira-aleatoria","title":"Construindo uma solu\u00e7\u00e3o inteira aleat\u00f3ria","text":"<p>Vamos agora fazer algo mais absurdo: e se criarmos uma solu\u00e7\u00e3o toda aleat\u00f3ria?</p> <p>Question</p> <p>Como voc\u00ea criaria uma solu\u00e7\u00e3o aleatoriamente?</p> Resposta <p>N\u00e3o existe uma resposta certa aqui. Duas solu\u00e7\u00f5es s\u00e3o mais comuns:</p> <ol> <li>passando por cada objeto, pegue-o com probabilidade <code>50%</code>.</li> <li>percorra a lista em ordem aleat\u00f3ria, fazendo o mesmo algoritmo do mais caro/leve.</li> </ol> <p>Example</p> <p>Tente implementar a abordagem 1 da resposta acima.</p> <p>Example</p> <p>Tente implementar a abordagem 2 da resposta acima.</p> <p>Question</p> <p>Rode ambos programas acima com v\u00e1rios seeds diferentes e anote abaixo os resultados.</p> <p>Question</p> <p>Anote aqui coment\u00e1rios sobre a qualidade das solu\u00e7\u00f5es aleat\u00f3rias. Considere tanto o valor dos objetos selecionados quanto o peso.</p> <p>Warning</p> <p>Iremos discutir esses resultados na pr\u00f3xima aula.</p>"},{"location":"aulas/06-aleatorizacao/#algoritmos-geneticos","title":"Algoritmos Gen\u00e9ticos","text":"<p>Nesta aula tamb\u00e9m abordamos o trade-off entre exploration e exploitation. Para isso, foi poss\u00edvel conhecer uma implementa\u00e7\u00e3o por algoritmos gen\u00e9ticos para o problema da Mochila Bin\u00e1ria em Python. Caso queira executar essa solu\u00e7\u00e3o, acesse esse link. </p> <p>Question</p> <p>Implemente essa solu\u00e7\u00e3o em C++. Explore as taxas de sele\u00e7\u00e3o, cross-over e muta\u00e7\u00e3o. Escreva um pequeno relat\u00f3rio (de at\u00e9 1 p\u00e1gina) e comente os principais pontos observados. A entrega desse exerc\u00edcio pode lhe render 0,5 ponto extra, a ser computado ao final da disciplina. </p>"},{"location":"aulas/07-busca-local/","title":"07 - Busca local","text":"<p>Nesta aula trabalharemos com um algoritmo chamado \"Busca local\", que consiste basicamente em fazer pequenas atualiza\u00e7\u00f5es que melhoram sucessivamente uma solu\u00e7\u00e3o.</p>"},{"location":"aulas/07-busca-local/#solucao-aleatorizada","title":"Solu\u00e7\u00e3o aleatorizada","text":"<p>Vamos iniciar criando solu\u00e7\u00f5es aleat\u00f3rias. Isto nos permitiria criar uma grande quantidade de solu\u00e7\u00f5es e, eventualmente, pegar a melhor delas. Apesar de ser muito mais simples que a busca heur\u00edstica, a quantidade massiva de solu\u00e7\u00f5es geradas tem potencial de encontrar boas solu\u00e7\u00f5es.</p> <p>Vamos trabalhar com um algoritmo bem simples para gerar solu\u00e7\u00f5es aleat\u00f3rias:</p> <ul> <li>Para cada objeto, selecione-o com probabilidade <code>0.5</code>.</li> <li>Se o objeto for selecionado, coloque-o na mochila se couber.</li> </ul> <p>Question</p> <p>Supondo que s\u00f3 existe uma solu\u00e7\u00e3o \u00f3tima global, qual \u00e9 a chance de a encontrarmos repetindo o algoritmo acima?</p> <p>Question</p> <p>Supondo que todos os objetos caibam na mochila, quantos s\u00e3o selecionados em m\u00e9dia?</p> <p>Example</p> <p>Implemente o algoritmo acima. Use <code>seed=10</code>.</p> <p>Example</p> <p>Repita o algoritmo 10 vezes e pegue somente a melhor solu\u00e7\u00e3o.</p> <p>Tip</p> <p>Use os arquivos de entrada/sa\u00edda disponibilizados nas aulas passadas.</p>"},{"location":"aulas/07-busca-local/#busca-local","title":"Busca local","text":"<p>Vamos agora implementar uma busca local para a Mochila Bin\u00e1ria seguindo os dois algoritmos vistos na expositiva.</p>"},{"location":"aulas/07-busca-local/#mochila-cheia","title":"Mochila cheia","text":"<p>Para implementar a Mochila cheia iremos adotar a seguinte estrat\u00e9gia:</p> <ol> <li>Gere uma solu\u00e7\u00e3o aleat\u00f3ria.</li> <li>Percorra novamente todos os objetos (na ordem da entrada)</li> <li>Se um objeto couber na mochila, inclua-o.</li> </ol> <p>Example</p> <p>Implemente o algoritmo acima.</p> <p>Example</p> <p>Rode a Mochila cheia 10 vezes e retorne a melhor solu\u00e7\u00e3o.</p> <p>Question</p> <p>Houve melhoria em rela\u00e7\u00e3o ao aleat\u00f3rio sozinho? Foi significativa?</p>"},{"location":"aulas/07-busca-local/#fechamento","title":"Fechamento","text":"<p>Question</p> <p>Como voc\u00ea avalia os ganhos obtidos pela busca local em rela\u00e7\u00e3o ao aleat\u00f3rio? E em rela\u00e7\u00e3o a heur\u00edstica?</p>"},{"location":"aulas/08-busca-global/","title":"08 - Busca exaustiva","text":""},{"location":"aulas/08-busca-global/#pseudo-codigo","title":"Pseudo-c\u00f3digo","text":"<p>Vamos iniciar tentando escrever um algoritmo em pseudo-c\u00f3digo para a seguinte ideia:</p> <ul> <li>Iniciando com o objeto 0:<ul> <li>N\u00e3o inclua ele na mochila: resolva o problema com o restante dos objetos e retorne esse resultado</li> <li>Inclua ele na mochila: resolva o problema com o restante dos objetos e uma mochila de capacidade <code>C - p[0]</code>. Retorne o resultado <code>+ v[0]</code>.</li> <li>Escolhe a melhor das duas op\u00e7\u00f5es acima e retorne.</li> </ul> </li> </ul> <p>Tip</p> <p>Note que pedimos para resolver o problema de novo, mas com menos objetos. Parece que esse \u00e9 um algoritmo recursivo!</p> <p>Question</p> <p>Escreva um algoritmo recursivo em pseudo-c\u00f3digo para resolver o problema da mochila. Seu algoritmo dever\u00e1 retornar o valor da mochila \u00f3tima, mas N\u00c3O precisa ainda retornar a mochila que tem esse valor.</p> <p>Question</p> <p>Adapte seu algoritmo acima para, al\u00e9m de retornar a melhor solu\u00e7\u00e3o, tamb\u00e9m retornar a mochila que tem esse valor.</p> <p>Dica: pode ser \u00fatil passar um vetor para guardar a melhor solu\u00e7\u00e3o encontrada.</p>"},{"location":"aulas/08-busca-global/#implementacao","title":"Implementa\u00e7\u00e3o","text":"<p>Vamos agora tentar implementar o algoritmo de busca global que fizemos.</p> <p>Example</p> <p>Implemente em C++ seu algoritmo acima.</p> <p>Question</p> <p>Teste o seu programa com a entrada <code>in-aula.txt</code> (que \u00e9 a entrada dos slides). Voc\u00ea consegue agora responder \u00e0 pergunta Existe mochila com valor maior que 13?</p>"},{"location":"aulas/08-busca-global/#fechamento","title":"Fechamento","text":"<p>Question</p> <p>Como voc\u00ea avalia os ganhos obtidos pela busca global em rela\u00e7\u00e3o \u00e0 busca local?</p>"},{"location":"aulas/09-busca-global-II/","title":"09 - Compara\u00e7\u00e3o de resultados","text":"<p>J\u00e1 implementamos diversos algoritmos para o problema da mochila bin\u00e1ria e chegou a hora de compararmos os resultados por eles obtidos. Nossa ideia aqui \u00e9 exercitar nossa capacidade de responder perguntas abertas com base em dados.</p>"},{"location":"aulas/09-busca-global-II/#ate-qual-tamanho-de-mochila-a-busca-global-resolve-rapido","title":"At\u00e9 qual tamanho de mochila a busca global resolve r\u00e1pido?","text":""},{"location":"aulas/09-busca-global-II/#o-algoritmo-de-busca-local-e-melhor-que-as-heuristicas","title":"O algoritmo de busca local \u00e9 melhor que as heur\u00edsticas?","text":""},{"location":"aulas/09-busca-global-II/#vale-a-pena-esperar-pela-busca-global-ate-que-ponto","title":"Vale a pena esperar pela busca global? At\u00e9 que ponto?","text":""},{"location":"aulas/09-busca-global-II/#formulando-a-pergunta-com-precisao","title":"Formulando a pergunta com precis\u00e3o","text":"<p>Todas as perguntas acima s\u00e3o abertas. Elas admitem diferentes respostas dependendo de nossa interpreta\u00e7\u00e3o. Nesta se\u00e7\u00e3o iremos aprender a reformul\u00e1-las de maneira (mais) precisa e a planejar uma s\u00e9rie de experimentos que possam apoiar nossa resposta.</p> <p>Question</p> <p>Escolha uma das quest\u00f5es acima para trabalhar nesta quest\u00e3o.</p> <p>Question</p> <p>Alguns qualificadores comumente usados em discursos informais s\u00e3o considerados \"vazios\" quanto usados em um contexto mais cient\u00edfico, onde \u00e9 importante ser preciso nas mensagens. Express\u00f5es como</p> <ul> <li>\"A melhor que B\"</li> <li>\"r\u00e1pido, devagar, significativo\"</li> <li>\"vale a pena\"</li> </ul> <p>s\u00e3o ruins pois n\u00e3o deixam expl\u00edcito as expectativas de quem as escreveu. Por exemplo, poder\u00edamos ainda perguntar:</p> <ul> <li>\"A \u00e9 melhor que B\"** sob qual m\u00e9trica**?</li> <li>O que \u00e9 considerado \"r\u00e1pido, devagar ou significativo\"? 1 minuto \u00e9 r\u00e1pido ou devagar (depende da aplica\u00e7\u00e3o)</li> <li>Qual \u00e9 o crit\u00e9rio usado para \"valer a pena\"? Tempo? Valor da mochila? O qu\u00e3o pr\u00f3ximo do \u00f3timo vale a pena?</li> </ul> <p>Reescreva a pergunta escolhida agora especificando exatamente o que voc\u00ea gostaria de responder.</p> <p>Importante</p> <p>N\u00e3o existe resposta certa para a pergunta acima. Desde que voc\u00ea seja preciso em sua formula\u00e7\u00e3o a resposta est\u00e1 correta. Ou seja, neste momento n\u00e3o estamos questionando se a pergunta faz sentido, somente se ela est\u00e1 bem formulada.</p> <p>Agora que temos uma pergunta mais precisamente formulada, vamos planejar</p> <p>Question</p> <p>Como voc\u00ea usaria um gerador para gerar dados que te ajudem a responder a pergunta escolhida? Especifique tamanhos de entrada e comente por que voc\u00ea faria estes testes.</p> <p>Question</p> <p>Com os dados da quest\u00e3o acima em m\u00e3os, que ferramentas visuais voc\u00ea usaria para facilitar a comunica\u00e7\u00e3o dos resultados?</p> <ul> <li>Se sua resposta incluir tabelas, diga o que ser\u00e1 mostrado em cada eixo e qual sua interpreta\u00e7\u00e3o dos dados.</li> <li>Se sua resposta incluir gr\u00e1ficos, explique qual tipo e qual informa\u00e7\u00e3o voc\u00ea estaria colocando em evid\u00eancia.</li> </ul>"},{"location":"aulas/09-busca-global-II/#implementando-de-maneira-reprodutivel","title":"Implementando de maneira reprodut\u00edvel","text":"<p>Vamos agora tentar implementar seu plano acima de maneira reprodut\u00edvel. Ou seja, qualquer pessoa com a infra necess\u00e1ria poderia reexecutar seus experimentos e obter os mesmos dados que voc\u00ea.</p> <p>Example</p> <p>Re\u00fana todos os arquivos de entrada usados em uma pasta in.</p> <p>Example</p> <p>Crie um script python que executa seu programa para todas as entradas acima.</p> <p>Dicas:</p> <ul> <li>reveja a nossa aula 01 e relembre como criar testes reprodut\u00edveis.</li> </ul> <p>Example</p> <p>Salve os resultados acima em um dataframe do Pandas. Se quiser, salve seus resultados correntes para um arquivo CSV.</p> <p>Example</p> <p>Crie tabelas ou gr\u00e1ficos a partir do dataframe criado.</p> <p>Question</p> <p>Usando as tabelas e gr\u00e1ficos criados, responda \u00e0 pergunta escolhida no in\u00edcio do handout.</p>"},{"location":"aulas/10-branch-and-bound/","title":"10 - Branch and Bound","text":"<p>Vamos come\u00e7ar nossa atividade instrumentando nossa busca exaustiva. Dado que a promessa do nosso algoritmo Branch and Bound \u00e9 evitar chegar at\u00e9 o fim de uma solu\u00e7\u00e3o parcial que n\u00e3o tem chance de ser \u00f3tima, faz todo sentido ent\u00e3o contarmos quantas vezes chegamos at\u00e9 o fim.</p> <p>Example</p> <p>Vamos adicionar dois contadores ao nosso programa</p> <ol> <li><code>num_leaf</code> conta quantas vezes uma solu\u00e7\u00e3o completa foi comparada com a melhor poss\u00edvel</li> <li><code>num_copy</code> conta quantas vezes foi encontrada uma solu\u00e7\u00e3o melhor que a atual.</li> </ol> <p>Question</p> <p>Rode para o exemplo <code>in150.txt</code> e anote os valores obtidos abaixo.</p>"},{"location":"aulas/10-branch-and-bound/#um-bound-simples-ignorar-peso","title":"Um bound simples: ignorar peso","text":"<p>Nesta se\u00e7\u00e3o implementaremos um Branch and Bound simples com a seguinte ideia:</p> <p>BOUND</p> <p>Complete uma solu\u00e7\u00e3o parcial incluindo na mochila todos os objetos n\u00e3o selecionados. Isto \u00e9 equivalente a relaxar a restri\u00e7\u00e3o do peso.</p> <p>Question</p> <p>Os contadores <code>num_leaf</code> e <code>num_copy</code> se modificariam ao implementar o Branch and Bound? Se sim, quais deles?</p> Resposta <p>Somente <code>num_leaf</code>, j\u00e1 que deixamos de chegar em folhas que n\u00e3o tem chance de serem \u00f3timos globais. <code>num_copy</code> continua igual, j\u00e1 que conta o n\u00famero de vezes que o melhor foi atualizado.</p> <p>Example</p> <p>Implemente no seu c\u00f3digo o Branch and Bound usando o Bound acima. Ou seja, voc\u00ea dever\u00e1, ao chegar em um objeto</p> <ol> <li>Checar se a soma da solu\u00e7\u00e3o atual mais o bound \u00e9 melhor que o melhor poss\u00edvel.</li> <li>Se n\u00e3o for retorna</li> <li>Se for prossegue fazendo a escolha para o objeto atual.</li> </ol> <p>Example</p> <p>Adicione ao seu programa um contador <code>num_bounds</code> que conta o n\u00famero de vezes em que evitamos de testar uma solu\u00e7\u00e3o parcial at\u00e9 o fim.</p> <p>Question</p> <p>Teste seu programa novamente com a entrada <code>in150.txt</code>. Anote abaixo os contadores e interprete seu resultado.</p>"},{"location":"aulas/10-branch-and-bound/#analisando-nosso-bound","title":"Analisando nosso bound","text":"<p>Conseguimos algum ganho de desempenho ao criar o \u00faltimo bound. Vamos agora descobrir se ele \u00e9 bom mesmo.</p> <p>Question</p> <p>Como voc\u00ea mediria a altura em que o bound agiu? Seria melhor cortar mais para cima ou mais para baixo?</p> <p>O valor <code>num_bound</code> n\u00e3o ajuda muito a entender se o bound \u00e9 bom, j\u00e1 que cortar muito pode significar faz\u00ea-lo pr\u00f3ximo das folhas (e isto gera ganho pequeno de desempenho).</p> <p>Example</p> <p>Fa\u00e7a seu programa contar o n\u00famero de vezes em que o bound \u00e9 ativado em cada n\u00edvel da recurs\u00e3o. Mostre esses valores no terminal.</p> <p>Question</p> <p>Interprete os resultados acima.</p>"},{"location":"aulas/10-branch-and-bound/#implementacao-eficiente-do-bound","title":"Implementa\u00e7\u00e3o eficiente do bound","text":"<p>Question</p> <p>O bound Ignorar peso depende das escolhas feitas at\u00e9 o momento? Ou seja, se tenho 4 objetos, o bound da solu\u00e7\u00e3o parcial <code>(1, 0, -, -)</code> \u00e9 igual ou diferente do bound da solu\u00e7\u00e3o parcial <code>(1, 1, -, -)</code>?</p> <p>Question</p> <p>Como voc\u00ea poderia economizar trabalho ao calcular o bound? \u00c9 poss\u00edvel pr\u00e9-calcular algo?</p> <p>Example</p> <p>Reimplemente seu bound, desta vez pr\u00e9-calculando tudo antes de iniciar a busca_exaustiva.</p> <p>Question</p> <p>Rode novamente com a entrada <code>in150.txt</code> e verifique se houve ganho de tempo de execu\u00e7\u00e3o.</p>"},{"location":"aulas/10-branch-and-bound/#avancado-o-quao-justo-e-um-bound","title":"Avan\u00e7ado: o qu\u00e3o justo \u00e9 um bound?","text":"<p>Podemos medir qu\u00e3o justo \u00e9 um bound verificando a diferen\u00e7a entre seu valor e o valor real da melhor solu\u00e7\u00e3o da sub\u00e1rvore de recurs\u00e3o atual. Ou seja, comparamos nossa estimativa otimista com o que aconteceu de verdade ao examinar todas essas solu\u00e7\u00f5es.</p> <p>Example</p> <p>Fa\u00e7a seu programa guardar a diferen\u00e7a m\u00e9dia entre o valor do bound (que \u00e9 uma estimativa da qualidade final de uma solu\u00e7\u00e3o) e o melhor valor encontrado para aquele ramo da recurs\u00e3o.</p> <p>Dica: voc\u00ea vai precisar retornar o valor da melhor mochila encontrada em cada parte.</p> <p>Question</p> <p>Interprete os resultados acima.</p>"},{"location":"aulas/10-branch-and-bound/revisao/","title":"Revis\u00e3o para P1","text":"<p>Um investidor possui um or\u00e7amento de R$ 100.000,00 para aplicar no mercado de a\u00e7\u00f5es. Uma institui\u00e7\u00e3o financeira lhe d\u00e1 as seguintes op\u00e7\u00f5es para construir o seu portif\u00f3lio de investimentos, a ser composto por lotes de a\u00e7\u00f5es:</p> A\u00c7\u00c3O VALOR DO LOTE RETORNO DO LOTE IMPOSTO A PAGAR PETR4 R$ 30.000,00 R$ 2.700,00 R$ 640,00 DELL6 R$ 60.000,00 R$ 4.500,00 R$ 900,00 MICR7 R$ 30.000,00 R$ 6.400,00 R$ 1.200,00 IBMC3 R$ 40.000,00 R$ 4.600,00 R$ 940,00 <p>N\u00e3o \u00e9 poss\u00edvel comprar a\u00e7\u00f5es fracionadas, somente o lote inteiro. Com base neste cen\u00e1rio:</p> <ol> <li>Modele este problema como um problema de otimiza\u00e7\u00e3o.</li> <li>Crie uma entrada de dados para a inst\u00e2ncia do problema como mostrado acima.</li> <li>Implemente em C++ uma busca exaustiva para montar uma proposta de portif\u00f3lio para o cliente.</li> <li>Implemente uma estrat\u00e9gia do tipo branch-and-bound em C++ para a busca exaustiva da quest\u00e3o 3.</li> <li>Implemente em C++ uma heur\u00edstica para acelerar a busca exaustiva da quest\u00e3o 3.</li> <li>Obtenha e compare os tempos de execu\u00e7\u00e3o das tr\u00eas implementa\u00e7\u00f5es anteriores.</li> </ol>"},{"location":"aulas/11-paralelismo/","title":"10 - Introdu\u00e7\u00e3o a paralelismo","text":"<p>OpenMP \u00e9 uma tecnologia de computa\u00e7\u00e3o multi-core usada para paralelizar programas. Sua principal vantagem \u00e9 oferecer uma transi\u00e7\u00e3o suave entre c\u00f3digo sequencial e c\u00f3digo paralelo.</p> <p>Fizemos em sala de aula uma s\u00e9rie de programas b\u00e1sicos no OpenMP e agora \u00e9 a hora de praticar.</p>"},{"location":"aulas/11-paralelismo/#calculo-do-pi-por-meio-de-uma-serie-infinita-de-leibniz","title":"C\u00e1lculo do PI por meio de uma s\u00e9rie infinita de Leibniz","text":"<p>Voc\u00ea sabia que \u00e9 poss\u00edvel calcular o valor do PI por meio de uma s\u00e9rie infinita de Leibniz? Veja abaixo:</p>  1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} - \\dots  = \\frac{\\pi}{4}    \\sum_{0}^{\\infty} = \\frac{(-1)^n}{2n + 1} = \\frac{\\pi}{4}  <p>Essa s\u00e9rie converge muito lentamente, o que \u00e9 bom para n\u00f3s. </p>"},{"location":"aulas/11-paralelismo/#sua-tarefa","title":"Sua tarefa","text":"<p>Implemente a vers\u00e3o serial do c\u00e1lculo do PI a partir da s\u00e9rie infinita de Leibniz. Fa\u00e7a <code>n = 1000000000</code>. </p> <p>Ap\u00f3s implementar a vers\u00e3o serial e calcular o tempo de sua execu\u00e7\u00e3o, implemente a vers\u00e3o em <code>openmp</code>. Voc\u00ea deve fazer sua implementa\u00e7\u00e3o de duas formas:</p> <p>a) A primeira implementa\u00e7\u00e3o voc\u00ea deve trabalhar com <code>2</code> threads e a partir do <code>id</code> da thread, voc\u00ea deve dividir a soma em duas partes, cada thread executando a sua por\u00e7\u00e3o.</p> <p>b) A segunda implementa\u00e7\u00e3o voc\u00ea deve trabalhar com <code>for</code> do openmp e tratar como uma <code>redu\u00e7\u00e3o</code> do valor de PI. Calcule o tempo de execu\u00e7\u00e3o.  </p> <p>O speedup \u00e9 uma m\u00e9trica que representa a raz\u00e3o entre o tempo de execu\u00e7\u00e3o de um programa sequencial e o tempo de execu\u00e7\u00e3o de sua vers\u00e3o paralela. Por isso, trata-se de uma boa medida para avaliarmos quantitativamente a melhoria trazida pela vers\u00e3o paralela de um programa paralelo em rela\u00e7\u00e3o \u00e0 sua vers\u00e3o sequencial. Calcule tamb\u00e9m o speed up de cada uma das solu\u00e7\u00f5es.</p>"},{"location":"aulas/11-paralelismo/#tasks-tarefas-em-openmp","title":"Tasks (tarefas) em OpenMP","text":"<p>Vamos agora criar tarefas que podem ser executadas em paralelo.</p> <p>Defini\u00e7\u00e3o</p> <p>Uma tarefa \u00e9 um bloco de c\u00f3digo que \u00e9 rodado de maneira paralela usando OpenMP. Tarefas s\u00e3o agendadas para cada uma das threads criadas em um regi\u00e3o paralela. N\u00e3o existe uma associa\u00e7\u00e3o 1-1 entre threads e tarefas. Posso ter mais tarefas que threads e mais threads que tarefas.</p> <p>Veja abaixo um exemplo de cria\u00e7\u00e3o de tarefas.</p> <pre><code>#pragma omp parallel\n{\n    #pragma omp task\n    {\n        std::cout &lt;&lt; \"Estou rodando na tarefa \" &lt;&lt; omp_get_thread_num() &lt;&lt; \"\\n\";\n    }\n}\nstd::cout &lt;&lt; \"eu s\u00f3 rodo quanto TODAS tarefas acabarem.\\n\";\n</code></pre> <p>Question</p> <p>O exemplo acima cria quantas tarefas, supondo que <code>OMP_NUM_THREADS=4</code>?</p> <ul> <li> 1</li> <li> 4, uma para cada thread</li> <li> Nenhuma das anteriores</li> </ul> <p>Details</p> <p>Como cada thread roda o c\u00f3digo da regi\u00e3o paralela, cada uma cria exatamente um tarefa.</p> <p>Para controlar a cria\u00e7\u00e3o de tarefas em geral usamos a diretiva <code>master</code>, que executa somente na thread de \u00edndice <code>0</code>. Assim conseguimos criar c\u00f3digo leg\u00edvel e que deixa bem claro quantas e quais tarefas s\u00e3o criadas.</p> <pre><code>#pragma omp parallel\n{\n    #pragma omp master\n    {\n        std::cout &lt;&lt; \"s\u00f3 roda uma vez na thread:\" &lt;&lt; omp_get_thread_num() &lt;&lt; \"\\n\";\n        #pragma omp task\n        {\n            std::cout &lt;&lt; \"Estou rodando na thread:\" &lt;&lt; omp_get_thread_num() &lt;&lt; \"\\n\";\n        }\n    }\n}\n</code></pre> <p>Somente lendo o c\u00f3digo acima, responda as quest\u00f5es abaixo.</p> <p>Question</p> <p>Quantas tarefas s\u00e3o criadas no exemplo acima?</p> <ul> <li> 1</li> <li> N, uma para cada thread</li> <li> Nenhuma das anteriores</li> </ul> <p>Question</p> <p>A(s) tarefa(s) criada(s) roda(m) em qual thread?</p> <ul> <li> 0</li> <li> 1</li> <li> Imposs\u00edvel dizer. Em cada execu\u00e7\u00e3o rodar\u00e1 em uma thread diferente.</li> </ul> <p>Example</p> <p>Complete exercicio1.cpp criando duas tarefas. A primeira dever\u00e1 rodar <code>funcao1</code> e a segunda <code>funcao2</code>. Salve seus resultados nas vari\u00e1veis indicadas no c\u00f3digo.</p> <p>Question</p> <p>Leia o c\u00f3digo e responda. Quanto tempo o c\u00f3digo sequencial demora? E o paralelo? Verifique que sua implementa\u00e7\u00e3o est\u00e1 de acordo com suas expectativas.</p> <p>Details</p> <p>Sequencial demora a soma dos tempos das duas fun\u00e7\u00f5es. Paralelo demora o tempo da maior delas.</p>"},{"location":"aulas/12-efeitos-colaterais/","title":"11 - Scheduling e  Efeitos Colaterais","text":""},{"location":"aulas/12-efeitos-colaterais/#scheduling","title":"Scheduling","text":"<p>Vamos come\u00e7ar compreendendo melhor os <code>schedulers</code> que existem no openmp. No github, obtenha o arquivo <code>omp_schedulers.cpp</code>, compile e execute-o. Voc\u00ea dever\u00e1 obter um output similar ao abaixo. Verifique na documenta\u00e7\u00e3o do OpenMP (link) e busque compreender melhor como funciona cada scheduler. </p> <pre><code>default:               \n****************                                                \n                ****************                                \n                                ****************                \n                                                ****************\n\nschedule(static):      \n****************                                                \n                ****************                                \n                                ****************                \n                                                ****************\n\nschedule(static, 4):   \n****            ****            ****            ****            \n    ****            ****            ****            ****        \n        ****            ****            ****            ****    \n            ****            ****            ****            ****\n\nschedule(static, 8):   \n********                        ********                        \n        ********                        ********                \n                ********                        ********        \n                        ********                        ********\n\nschedule(dynamic):     \n**  ******** ** ***** * ** ****** * *  ****  *   *  **  *  *  * \n   *        *        *             *  *         * **   *        \n  *            *       *         *   *     ** **      *  *  ** *\n                          *                               *     \n\nschedule(dynamic, 1):  \n* **  ** * **  *   *  * * * ** * *    *** *  * * *******  * *  *\n *   *       *         * *        ** *     *            **   *  \n    *   * *   * *** **     *  * *   *    *  * * *          *  * \n\n\nschedule(dynamic, 4):  \n****    ********************************    ********************\n    ****                                                        \n\n                                        ****                    \n\nschedule(dynamic, 8):  \n********                ****************************************\n        ********                                                \n                ********                                        \n\n\nschedule(guided):      \n****************            ****************     ***************\n                ************                                    \n\n                                            *****               \n\nschedule(guided, 2):   \n****************                     ***************************\n                ************                                    \n                            *********                           \n\n\nschedule(guided, 4):   \n****************            ************************************\n\n                ************                                    \n\n\nschedule(guided, 8):   \n                ************         ************************   \n                            *********                           \n****************                                             ***\n\n\nschedule(auto):        \n****************                                                \n                ****************                                \n                                ****************                \n                                                ****************\n\nschedule(runtime):     \n****************                                                \n                ****************                                \n                                ****************                \n                                                ****************\n</code></pre>"},{"location":"aulas/12-efeitos-colaterais/#revisitando-parallel-for-tasks-e-sections","title":"Revisitando <code>Parallel for</code>, <code>tasks</code> e <code>sections</code>","text":"<p>Agora que j\u00e1 conseguimos resolver problemas simples usando tr\u00eas abordagens diferentes, vamos aumentar a complexidade dos problemas tratados. Vimos tr\u00eas abordagens</p> <ul> <li><code>parallel for</code> - \u00fatil para quando precisamos executar a mesma opera\u00e7\u00e3o em um conjunto grande de dados.</li> <li><code>tasks</code> - \u00fatil para paralelizar tarefas heterog\u00eaneas.</li> <li><code>sections</code> - permite paralelizar tarefas heterog\u00eanas, com o controle adicional que uma <code>section</code> \u00e9 executada apenas por uma thread.</li> </ul> <p>Teremos ent\u00e3o dois desafios relacionados a paralelizar programas que n\u00e3o s\u00e3o obviamente paraleliz\u00e1veis.</p>"},{"location":"aulas/12-efeitos-colaterais/#calculo-do-pi-recursivo","title":"C\u00e1lculo do <code>pi</code> recursivo","text":"<p>Vamos iniciar com um c\u00f3digo recursivo para c\u00e1lculo do pi.</p> <p>Example</p> <p>Examine o c\u00f3digo em pi_recursivo.cpp. Procure entender bem o que est\u00e1 acontecendo antes de prosseguir.</p> <p>Question</p> <p>Onde est\u00e3o as oportunidades de paralelismo? O c\u00f3digo tem depend\u00eancias?</p> <p>Question</p> <p>Se o c\u00f3digo tiver depend\u00eancias, \u00e9 poss\u00edvel refator\u00e1-lo para elimin\u00e1-las?</p> <p>Question</p> <p>Quantas n\u00edveis de chamadas recursivas s\u00e3o feitas? Quando o programa para de chamar recursivamente e faz sequencial?</p> <p>Vamos agora tentar paralelizar o programa usando as duas t\u00e9cnicas.</p>"},{"location":"aulas/12-efeitos-colaterais/#usando-for-paralelo","title":"Usando <code>for</code> paralelo","text":"<p>Question</p> <p>Em quais linhas pode haver oportunidade para usar <code>parallel for</code>?</p> <p>Example</p> <p>Crie uma implementa\u00e7\u00e3o do pi_recursivo usando for paralelo. Me\u00e7a seu tempo e anote.</p> <p>Example</p> <p>O n\u00famero <code>MIN_BLK</code> afeta seu algoritmo? \u00c9 melhor aument\u00e1-lo ou diminu\u00ed-lo? </p> <p>Question</p> <p>Os ganhos de desempenho foram significativos?</p> <p>Question</p> <p>Como voc\u00ea fez o paralelismo? Precisou definir o n\u00famero do <code>for</code> manualmente ou conseguiu realizar a divis\u00e3o automaticamente? Comente abaixo sua implementa\u00e7\u00e3o.</p>"},{"location":"aulas/12-efeitos-colaterais/#usando-task","title":"Usando <code>task</code>","text":"<p>Agora vamos usar <code>task</code>. Neste caso \u00e9 vamos adotar a seguinte estrat\u00e9gia: usaremos tarefas para paralelizar as chamadas recursivas feitas em pi_recursivo.cpp. </p> <p>Example</p> <p>Crie uma implementa\u00e7\u00e3o do pi_recursivo usando tarefas. Me\u00e7a seu tempo e anote.</p> <p>Dica: se voc\u00ea precisar esperar tarefas pode usar a diretiva <code>#pragma omp taskwait</code>. Ela espera por todas as tarefas criadas pela thread atual.</p> <p>Question</p> <p>Os ganhos de desempenho foram significativos?</p> <p>Question</p> <p>Quantas tarefas foram criadas? Voc\u00ea escolheu essa valor como?</p> <p>Example</p> <p>Tente n\u00fameros diferentes de tarefas e verifique se o desempenho melhora ou piora. Anote suas conclus\u00f5es abaixo. </p>"},{"location":"aulas/12-efeitos-colaterais/#comparacao","title":"Compara\u00e7\u00e3o","text":"<p>Question</p> <p>Compare seus resultados das duas abordagens. Anote abaixo seus resultados.</p> <p>Warning</p> <p>\u00c9 poss\u00edvel conseguir tempos muito parecidos com ambas, ent\u00e3o se uma delas ficou muito mais lenta \u00e9 hora de rever o que foi feito.</p>"},{"location":"aulas/12-efeitos-colaterais/#efeitos-colaterais","title":"Efeitos Colaterais","text":"<p>Agora que j\u00e1 conseguimos resolver um problema um pouco mais complexo usando abordagens diferentes, vamos aumentar um pouco mais a complexidade dos problemas tratados.</p> <p>No c\u00f3digo <code>pi_recursivo.cpp</code> t\u00ednhamos uma vari\u00e1vel global que podia ser eliminada do c\u00f3digo mudando a fun\u00e7\u00e3o recursiva. Isso, por\u00e9m, nem sempre \u00e9 poss\u00edvel e precisamos lidar com estas situa\u00e7\u00f5es.</p>"},{"location":"aulas/12-efeitos-colaterais/#um-primeiro-teste","title":"Um primeiro teste","text":"<p>Vamos iniciar trabalhando com o seguinte trecho de c\u00f3digo (arquivo <code>vetor_insert.cpp</code>):</p> <pre><code>std::vector&lt;double&gt; vec;\nfor (int i = 0; i &lt; N; i++) {\n    vec.push_back(conta_complexa(i));\n}\n</code></pre> <p>Vamos supor agora que usaremos o seguinte comando para paralelizar o c\u00f3digo acima usando OpenMP:</p> <pre><code>#pragma omp parallel for\n</code></pre> <p>Question</p> <p>A vari\u00e1vel <code>i</code> \u00e9</p> <ul> <li> shared</li> <li> private</li> <li> firstprivate</li> </ul> <p>Question</p> <p>A vari\u00e1vel <code>vec</code> \u00e9</p> <ul> <li> shared</li> <li> private</li> <li> firstprivate</li> </ul> <p>Question</p> <p>O c\u00f3digo paralelizado rodaria sem dar erros? Os resultados seriam os esperados?</p> <ul> <li> Sim, o <code>vector</code> \u00e9 capaz de gerenciar os acessos simult\u00e2neos</li> <li> O c\u00f3digo acima roda sem erros, mas o conte\u00fado do vetor pode n\u00e3o estar correto ao fim do programa</li> <li> N\u00e3o, o c\u00f3digo acima d\u00e1 erro ao executar.</li> </ul> <p>Resposta</p> <p>Rode e veja o que acontece ;)</p> <p>Progress</p> <p>Clique ap\u00f3s rodar o programa</p> <p>Agora que vimos o que acontece, vamos consertar isso!</p> <p>Danger</p> <p>Nosso c\u00f3digo d\u00e1 erro pois a opera\u00e7\u00e3o <code>push_back</code> modifica o vetor!</p> <p>Vamos ver ent\u00e3o duas abordagens importantes para contornar esse problema.</p>"},{"location":"aulas/12-efeitos-colaterais/#secoes-criticas","title":"Se\u00e7\u00f5es cr\u00edticas","text":"<p>Antes de come\u00e7ar, vamos aprender mais um aspecto de OpenMP: diretivas para compartilhamento de dados. J\u00e1 vimos as 3 principais op\u00e7\u00f5es:</p> <ul> <li><code>shared</code> - compartilhado entre threads</li> <li><code>private</code> - privados entre threads</li> <li><code>firstprivate</code> - Especifica que cada thread deve ter sua pr\u00f3pria inst\u00e2ncia de uma vari\u00e1vel e que a vari\u00e1vel deve ser inicializada com o valor da vari\u00e1vel antes da se\u00e7\u00e3o paralela.</li> </ul> <p>Podemos for\u00e7ar a especifica\u00e7\u00e3o de diretivas de compartilhamento para todas as vari\u00e1veis usadas nas constru\u00e7\u00f5es <code>omp parallel</code>, <code>omp task</code> e <code>omp parallel for</code>.</p> <p>Tip</p> <p>Ao adicionarmos <code>default(none)</code> logo ap\u00f3s as diretivas acima precisaremos especificar, para cada vari\u00e1vel usada, sua diretiva de compartilhamento. Isso torna muito mais f\u00e1cil identificar casos de compartilhamento indevido de dados.</p> <p>A partir desse ponto estaremos supondo que todo c\u00f3digo criado usar\u00e1 <code>default(none)</code>.</p> <p>A primeira abordagem usada ter\u00e1 a miss\u00e3o de indicar que um conjunto de linhas cont\u00e9m uma opera\u00e7\u00e3o que possui efeitos colaterais. Dessa maneira, podemos evitar conflitos se s\u00f3 permitirmos que essa regi\u00e3o rode em uma thread por vez.</p> <p>Fazemos isso usando a diretiva <code>omp critical</code>:</p> <pre><code>#pragma omp critical\n{\n    // c\u00f3digo aqui dentro roda somente em uma thread por vez.\n}\n</code></pre> <p>Se duas threads chegam ao mesmo tempo no bloco <code>critical</code>, uma delas ficar\u00e1 esperando at\u00e9 a outra acabar o bloco. Quando isso ocorrer a thread que esperou poder\u00e1 prosseguir. Vamos tentar aplicar isso ao c\u00f3digo de <code>vetor_insert.cpp</code>.</p> <p>Example</p> <p>Use <code>omp critical</code> para solucionar os problemas de concorr\u00eancia do c\u00f3digo acima.</p> <p>Question</p> <p>Escreva abaixo o tempo que seu c\u00f3digo levou para rodar.</p> <p>Progress</p> <p>Clique ap\u00f3s rodar seu c\u00f3digo</p> <p>Se sua implementa\u00e7\u00e3o se parecer com o c\u00f3digo abaixo, ent\u00e3o \u00e9 bem prov\u00e1vel que a vers\u00e3o paralela na verdade tenha demorado o mesmo tempo ou mais que o original.</p> <pre><code>....\n#pragma omp parallel for default(none) shared(vec)\nfor (int i = 0; i &lt; N; i++) {\n    #pragma omp critical\n    {\n        vec.push_back(conta_complexa(i));\n    }\n}\n....\n</code></pre> <p>Question</p> <p>Analise o c\u00f3digo novamente e tente explicar por que o programa n\u00e3o ganhou velocidade.</p> <p>Resposta</p> <p>A opera\u00e7\u00e3o que produz efeitos colaterais \u00e9 <code>vec.push_back</code>, mas nossa se\u00e7\u00e3o cr\u00edtica envolve tamb\u00e9m a chamada <code>conta_complexa(i)</code>.</p> <p>Example</p> <p>Modifique seu c\u00f3digo de acordo com a resposta acima. Me\u00e7a o desempenho e veja que agora h\u00e1 melhora.</p> <p>Vamos analisar agora a ordem dos dados em <code>vec</code>.</p> <p>Question</p> <p>A ordem se mant\u00e9m igual ao programa sequencial? Voc\u00ea consegue explicar por que?</p> <p>Resposta</p> <p>N\u00e3o se mant\u00e9m. Cada thread chega ao <code>push_back</code> em um momento diferente, logo a ordem em que os dados s\u00e3o adicionados no vetor muda.</p>"},{"location":"aulas/12-efeitos-colaterais/#manejo-de-conflitos-usando-pre-alocacao-de-memoria","title":"Manejo de conflitos usando pr\u00e9-aloca\u00e7\u00e3o de mem\u00f3ria","text":"<p>Se\u00e7\u00f5es cr\u00edticas s\u00e3o muito \u00fateis quando n\u00e3o conseguimos evitar o compartilhamento de dados. Por\u00e9m, elas s\u00e3o caras e e feitas especialmente para situa\u00e7\u00f5es em que regi\u00e3o cr\u00edtica \u00e9 pequena e chamada um n\u00famero relativamente pequeno de vezes. </p> <p>Como regra, desejamos entrar na regi\u00e3o cr\u00edtica o menor n\u00famero poss\u00edvel de vezes.</p> <p>Question</p> <p>Reveja o c\u00f3digo do inicial da se\u00e7\u00e3o de efeitos colaterais. Seria poss\u00edvel reescrev\u00ea-lo para n\u00e3o usar <code>push_back</code>?</p> <p>Resposta</p> <p>Sim, bastaria alocar o vetor com tamanho <code>N</code> ao cri\u00e1-lo. Assim poder\u00edamos atribuir <code>conta_complexa</code> direto para a posi\u00e7\u00e3o de mem\u00f3ria desejada.</p> <p>A estrat\u00e9gia acima \u00e9 muito importante em alto desempenho e representa uma maneira de evitar se\u00e7\u00f5es cr\u00edticas e sincroniza\u00e7\u00e3o.</p> <p>\u00c9 sempre melhor alocar mem\u00f3ria em blocos grandes antes do paralelismo do que alocar mem\u00f3ria frequentemente dentro de regi\u00f5es paralelas.</p> <p>Note que fizemos isso na parte de tarefas: ao criarmos vari\u00e1veis para cada tarefa preencher evitamos a necessidade de usar sincroniza\u00e7\u00e3o.</p> <p>Example</p> <p>Modifique o programa para usar a ideia da quest\u00e3o anterior. Me\u00e7a o desempenho e verifique que tudo funciona normalmente e mais r\u00e1pido que o original.</p>"},{"location":"aulas/12-efeitos-colaterais/#dica","title":"Dica","text":"<p>A Microsoft possui uma p\u00e1gina bem completa sobre o <code>OpenMP</code>. Vale a pena conferir neste link.</p>"},{"location":"aulas/13-efeitos-colaterais-II/","title":"Efeitos colaterais II","text":"<p>Na aula de hoje iremos trabalhar com um algoritmo de sorteios aleat\u00f3rios para calcular o <code>pi</code>. Ele \u00e9 baseado em uma t\u00e9cnica de Otimiza\u00e7\u00e3o, Simula\u00e7\u00e3o e Estima\u00e7\u00e3o Param\u00e9trica chamada Monte Carlo. Um bom v\u00eddeo para compreender essa t\u00e9cnica, est\u00e1 dispon\u00edvel aqui.</p> <p>O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado <code>2</code>. Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi. Veja abaixo um resumo do algoritmo.</p> <p></p> <ol> <li><code>sum = 0</code></li> <li>De <code>i=0</code> at\u00e9 <code>N</code>:<ol> <li>sorteie pontos x,y \\in [0,1]</li> <li>se x^2 + y^2 \\leq 1, <code>sum += 1</code></li> </ol> </li> <li>devolva <code>4 * sum / N</code></li> </ol> <p>Example</p> <p>Fa\u00e7a uma implementa\u00e7\u00e3o sequencial desse algoritmo. Chama seu programa de <code>pi_montecarlo.cpp</code>. Para fins de debug das pr\u00f3ximas vers\u00f5es, mostre o valor de <code>sum</code> na sa\u00edda de erros. Adote <code>N=100 000</code>.</p>"},{"location":"aulas/13-efeitos-colaterais-II/#e-possivel-paralelizar-o-problema","title":"\u00c9 poss\u00edvel paralelizar o problema?","text":"<p>Vamos iniciar pensando um pouco sobre o problema acima.</p> <p>Question</p> <p>O algoritmo acima \u00e9 paraleliz\u00e1vel? Qual t\u00e9cnica voc\u00ea utilizaria para paraleliz\u00e1-lo?</p> <p>Resposta</p> <p>O <code>for</code> paralelo parece encaixar muito bem neste problema, com a vari\u00e1vel <code>sum</code> sendo usada na op\u00e7\u00e3o <code>reduction</code></p> <p>Question</p> <p>Al\u00e9m da vari\u00e1vel <code>sum</code>, existe outra opera\u00e7\u00e3o que gera efeitos colaterais no c\u00f3digo acima? Qual?</p> <p>Resposta</p> <p>O sorteio de pontos! Lembramos da aula 06 que a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial que depende dos n\u00fameros anteriormente sorteados.</p> <p>Progress</p> <p>Continuar</p> <p>Agora que sabemos que gerar n\u00fameros aleat\u00f3rios \u00e9 um processo sequencial, vamos considerar o quanto isso atrapalha nosso programa. Nas pr\u00f3ximas quest\u00f5es leve em conta que o gerador de n\u00fameros aleat\u00f3rios \u00e9 uma vari\u00e1vel compartilhada.</p> <p>Question</p> <p>Como evitar\u00edamos problemas ao compartilhar o gerador de n\u00fameros aleat\u00f3rios?</p> <p>Resposta</p> <p>Podemos envolver o passo 2a do algoritmo em uma se\u00e7\u00e3o cr\u00edtica usando <code>omp critical</code></p> <p>Question</p> <p>Se o <code>for</code> acima rodar em uma ordem completamente diferente os resultados se alterar\u00e3o?</p> <p>Resposta</p> <p>Desde de que os pares <code>x,y</code> sorteados sejam os mesmos ent\u00e3o n\u00e3o haver\u00e1 problema.</p> <p>Example</p> <p>Com base em todas as suas respostas dos exerc\u00edcios anteriores, fa\u00e7a uma implementa\u00e7\u00e3o paralela do <code>pi_montecarlo.cpp</code>. Verifique que o valor de <code>sum</code> \u00e9 igual ao sequencial. Por enquanto, n\u00e3o se preocupe com o tempo de execu\u00e7\u00e3o.</p> <p>Question</p> <p>Anote o tempo de execu\u00e7\u00e3o sequencial e paralelo para o programa acima.</p> <p>Progress</p> <p>Vamos discutir esse resultado juntos!</p>"},{"location":"aulas/13-efeitos-colaterais-II/#paralelizando-processos-inerentemente-sequenciais","title":"Paralelizando processos inerentemente sequenciais","text":"<p>Como discutimos agora h\u00e1 pouco, a gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 um processo inerentemente sequencial. N\u00e3o \u00e9 que seja imposs\u00edvel paraleliz\u00e1-lo eficientemente, \u00e9 que \u00e9 imposs\u00edvel paraleliz\u00e1-lo at all. Vamos tentar contornar isso ent\u00e3o usando a resposta da Quest\u00e3o 4:</p> <p>O <code>for</code> do algoritmo depende dos pontos gerados, n\u00e3o da ordem que eles foram gerados.</p> <p>Vamos ent\u00e3o adotar uma solu\u00e7\u00e3o simples: a cada itera\u00e7\u00e3o do <code>for</code> criamos um novo gerador de n\u00fameros aleat\u00f3rios e sorteamos um par de pontos dele.</p>"},{"location":"aulas/13-efeitos-colaterais-II/#primeira-tentativa","title":"Primeira tentativa","text":"<p>Question</p> <p>Sabemos que um gerador de n\u00fameros aleat\u00f3rios gera sempre a mesma sequ\u00eancia de n\u00fameros, dado um par\u00e2metro <code>seed</code> fixo. O qu\u00ea acontece se usarmos o mesmo <code>seed</code> em todas as itera\u00e7\u00f5es? Como consertar isso?</p> <p>Resposta</p> <p>Sortearemos o mesmo ponto em todas as itera\u00e7\u00f5es. Para consertar isso podemos fazer o <code>seed</code> ser baseado no <code>i</code> da itera\u00e7\u00e3o atual.</p> <p>Example</p> <p>Crie uma implementa\u00e7\u00e3o baseada na ideia acima.</p> <p>Question</p> <p>Anote abaixo o valor do pi encontrado e o tempo de execu\u00e7\u00e3o.</p> <p>Question</p> <p>Os resultados obtidos s\u00e3o id\u00eanticos aos do programa original? S\u00e3o pr\u00f3ximos?</p> <p>Progress</p> <p>Vamos discutir esse resultado.</p>"},{"location":"aulas/13-efeitos-colaterais-II/#segunda-tentativa","title":"Segunda tentativa","text":"<p>O problema da nossa tentativa anterior \u00e9 que n\u00e3o temos de verdade sequ\u00eancias de pontos aleat\u00f3rias. Bom, na verdade nunca temos, mas o problema \u00e9 que violamos a promessa que o <code>RNG</code> faz. Ele promete que</p> <p>dado um seed fixo, a sequ\u00eancia de n\u00fameros geradas \u00e9 indistingu\u00edvel de uma sequ\u00eancia aleat\u00f3ria de verdade</p> <p>Ele n\u00e3o promete que, se criarmos v\u00e1rios <code>RNG</code>s, a sequ\u00eancia formada pelo primeiro par de n\u00fameros gerados por cada um ser\u00e1 aleat\u00f3ria.</p> <p>Vamos agora tentar uma nova ideia:</p> <p>Cada thread ir\u00e1 gerar <code>N/NUM_THREADS</code> n\u00fameros aleat\u00f3rios, atualizando <code>sum</code> com os pontos dentro do semi-c\u00edrculo.</p> <p>Question</p> <p>Como esta ideia melhora o algoritmo acima?</p> <p>Resposta</p> <p>Agora teremos <code>NUM_THREADS</code> sequ\u00eancias pseudo-aleat\u00f3rias \"v\u00e1lidas\" e junt\u00e1-las passa a ser um problema menor. Continuamos precisando usar uma <code>seed</code> para cada, mas ao menos agora temos um n\u00famero pequeno de <code>RNG</code>s.</p> <p>Example</p> <p>Fa\u00e7a uma implementa\u00e7\u00e3o da ideia acima. Voc\u00ea pode usar os comandos do OpenMP que quiser. </p> <p>Question</p> <p>Anote o tempo de execu\u00e7\u00e3o e o pi encontrado.</p>"},{"location":"aulas/14-intro-gpu/","title":"17 - Introdu\u00e7\u00e3o a GPU","text":"<p>Como visto em aula, programa\u00e7\u00e3o para GPU requer ferramentas especializadas capazes de gerar c\u00f3digo que rode parte na CPU (chamada de host) e parte na GPU (chamada de target). Nesta parte introdut\u00f3ria usaremos a biblioteca <code>cuda::thrust</code>. Ela possui um pequeno conjunto de opera\u00e7\u00f5es otimizadas para GPU e que podem ser customizadas para diversos prop\u00f3sitos.</p> <p>Documenta\u00e7\u00e3o oficial</p> <p>A documenta\u00e7\u00e3o oficial da Thrust est\u00e1 dispon\u00edvel no endere\u00e7o https://thrust.github.io/doc/modules.html.</p> <p>Tamb\u00e9m vamos focar em usar m\u00e1quinas pr\u00e9-configuradas.</p>"},{"location":"aulas/14-intro-gpu/#compilacao-para-gpu","title":"Compila\u00e7\u00e3o para GPU","text":"<p>Para compilar programas para rodar na GPU devemos usar o compilador <code>nvcc</code>. Ele identifica quais por\u00e7\u00f5es do c\u00f3digo dever\u00e3o ser compiladas para a GPU. O restante do c\u00f3digo, que roda exclusivamente na CPU, \u00e9 passado diretamente para um compilador C++ regular e um \u00fanico execut\u00e1vel \u00e9 gerado contendo o c\u00f3digo para CPU e chamadas inseridas pelo <code>nvcc</code> para invocar as fun\u00e7\u00f5es que rodam na GPU.</p> <p>O <code>nvcc</code> e todas as bibliotecas que precisamos est\u00e3o dispon\u00edveis no pacote <code>nvidia-cuda-toolkit</code> pronto para instala\u00e7\u00e3o via apt. A vers\u00e3o disponibilizada n\u00e3o \u00e9 a mais atual, mas tudo funciona de maneira integrada e n\u00e3o \u00e9 necess\u00e1rio instalar nada manualmente.</p> <p>Se voc\u00ea usar as VMs do Insper ent\u00e3o n\u00e3o precisa fazer nada. Todas as ferramentas j\u00e1 est\u00e3o instaladas l\u00e1 e a VM j\u00e1 vem pronta para uso.</p> <p>Example</p> <p>Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo.</p> <p>$ nvcc -arch=sm_70 -std=c++14 exemplo1-criacao-iteracao.cu -o exemplo1</p> <p>Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel <code>exemplo1</code> que roda e produz o seguinte resultado.</p> <pre><code>Host vector: 0 0 12 0 35\nDevice vector 0 0 0 0 35\n</code></pre>"},{"location":"aulas/14-intro-gpu/#compilacao-para-cpu","title":"Compila\u00e7\u00e3o para CPU","text":"<p>Se voc\u00ea ainda n\u00e3o tem uma GPU pode usar o suporte da <code>thrust</code> para OpenMP nas nossas primeiras aulas.</p> <p>Todos os trabalhos ser\u00e3o corrigidos usando GPU usando <code>nvcc</code>. Esta alternativa \u00e9 importante somente para as primeiras aulas, em que nem todos ter\u00e3o acesso ainda a uma GPU. Usaremos isso somente para facilitar o primeiro contato, mas essa op\u00e7\u00e3o n\u00e3o \u00e9 v\u00e1lida para avalia\u00e7\u00f5es.</p> <ol> <li>baixar o c\u00f3digo fonte da <code>thrust</code> no github.</li> <li>adicionar as seguintes flags no g++<ul> <li><code>-DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP</code>: diz que a paraleliza\u00e7\u00e3o de <code>device_vetor</code> ser\u00e1 usando OpenMP</li> <li><code>-I/home/....</code>: o caminho passado ser\u00e1 usado na busca por <code>include</code>s. Coloque o caminho do reposit\u00f3rio da <code>thrust</code></li> <li><code>-fopenmp</code>: j\u00e1 conhecemos este ;)</li> <li><code>-x c++</code>: for\u00e7a a compila\u00e7\u00e3o de arquivos <code>.cu</code> como c\u00f3digo fonte C++</li> </ul> </li> </ol> <p>Example</p> <p>Verifique que sua instala\u00e7\u00e3o funciona compilando o arquivo abaixo.</p> <p>$ g++ -DTHRUST_DEVICE_SYSTEM=THRUST_DEVICE_SYSTEM_OMP -I/caminho/para/thrust/  -fopenmp -x c++ exemplo1-criacao-iteracao.cu -o exemplo1-cpu</p> <p>Se der tudo certo a execu\u00e7\u00e3o do programa acima dever\u00e1 gerar um execut\u00e1vel <code>exemplo1-cpu</code> que roda e produz o seguinte resultado.</p> <pre><code>Host vector: 0 0 12 0 35\nDevice vector 0 0 0 0 35\n</code></pre> <p>Nem tudo o que roda usando thrust/OpenMP roda em GPU. Por essa raz\u00e3o, esse recurso ser\u00e1 usado somente para testes e nunca para avalia\u00e7\u00e3o.</p>"},{"location":"aulas/14-intro-gpu/#transferencia-de-dados","title":"Transfer\u00eancia de dados","text":"<p>Como visto na expositiva, a CPU e a GPU possuem espa\u00e7os de endere\u00e7amento completamente distintos. Ou seja, a CPU n\u00e3o consegue acessar os dados na mem\u00f3ria da GPU e vice-versa. A <code>thrust</code> disponibiliza somente um tipo de container (<code>vector</code>) e facilita este gerenciamento deixando expl\u00edcito se ele est\u00e1 alocado na CPU (<code>host</code>) ou na GPU (<code>device</code>).  A c\u00f3pia CPU\\leftrightarrow GPU \u00e9 feita implicitamente quando criamos um <code>device_vector</code> ou quando usamos a opera\u00e7\u00e3o de atribui\u00e7\u00e3o entre <code>host_vector</code> e <code>device_vector</code>. Veja o exemplo abaixo:</p> <pre><code>thrust::host_vector&lt;double&gt; vec_cpu(10); // alocado na CPU\n\nvec1[0] = 20;\nvec2[1] = 30;\n\n// aloca vetor na GPU e transfere dados CPU-&gt;GPU\nthrust::device_vector&lt;double&gt; vec_gpu (vec_cpu);\n\n//processa vec_gpu\n\nvec_cpu = vec_gpu; // copia dados GPU -&gt; CPU\n</code></pre> <p>A <code>thrust</code> usa iteradores em todas as suas fun\u00e7\u00f5es. Pense em um iterador como um ponteiro para os elementos do array. Por\u00e9m, um iterador \u00e9 mais esperto: ele guarda tamb\u00e9m o tipo do vetor original e suporta opera\u00e7\u00f5es <code>++</code> e <code>*</code> para qualquer tipo de dado iterado de maneira transparente.</p> <p>Vetores <code>thrust</code> aceitam os m\u00e9todos <code>v.begin()</code> para retornar um iterador para o come\u00e7o do vetor e <code>v.end()</code> para um iterador para o fim (depois do \u00faltimo elemento). Podemos tamb\u00e9m somar um valor <code>n</code> a um iterador. Isto \u00e9 equivalente a fazer <code>n</code> vezes a opera\u00e7\u00e3o <code>++</code>.  Veja abaixo um exemplo de uso das fun\u00e7\u00f5es <code>fill</code> e <code>sequence</code> para preencher valores em um vetor de maneira eficiente.</p> <pre><code>thrust::device_vector&lt;int&gt; v(5, 0); // vetor de 5 ints zerado\n// v = {0, 0, 0, 0, 0}\nthrust::sequence(v.begin(), v.end()); // preenche com 0, 1, 2, ....\n// v = {0, 1, 2, 3, 4}\nthrust::fill(v.begin(), v.begin()+2, 13); // dois primeiros elementos = 13\n// v = {13, 13, 2, 3, 4}\n</code></pre> <p>Question</p> <p>Consulte o arquivo exemplo1-criacao-iteracao.cu para um exemplo completo de aloca\u00e7\u00e3o e transfer\u00eancia de dados e do uso de iteradores.</p> <p>Example</p> <p>O fluxo de trabalho \"normal\" de aplica\u00e7\u00f5es usando GPU \u00e9 receber os dados em um vetor na CPU e copi\u00e1-los para a GPU para fazer processamentos. Crie um programa que l\u00ea uma sequ\u00eancia de <code>double</code>s da entrada padr\u00e3o em um <code>thrust::host_vector</code> e os copia para um <code>thrust::device_vector</code>. Teste seu programa com o arquivo stocks-google.txt, que cont\u00e9m o pre\u00e7o das a\u00e7\u00f5es do Google nos \u00faltimos 10 anos.</p> <p>Example</p> <p>A cria\u00e7\u00e3o de um <code>device_vector</code> \u00e9 demorada. Me\u00e7a o tempo que a opera\u00e7\u00e3o de aloca\u00e7\u00e3o e c\u00f3pia demora e imprima na sa\u00edda de erros. (Use <code>std::chrono</code>).</p>"},{"location":"aulas/14-intro-gpu/#operacoes-de-reducao","title":"Opera\u00e7\u00f5es de redu\u00e7\u00e3o","text":"<p>Uma opera\u00e7\u00e3o gen\u00e9rica de redu\u00e7\u00e3o transforma um vetor em um \u00fanico valor. Exemplos cl\u00e1ssicos de opera\u00e7\u00f5es de redu\u00e7\u00e3o incluem soma, m\u00e9dia e m\u00ednimo/m\u00e1ximo de um vetor.</p> <p>A <code>thrust</code> disponibiliza este tipo de opera\u00e7\u00e3o otimizada em GPU usando a fun\u00e7\u00e3o <code>thrust::reduce</code>:</p> <pre><code>val = thrust::reduce(iter_comeco, iter_fim, inicial, op);\n// iter_comeco: iterador para o come\u00e7o dos dados\n// iter_fim: iterador para o fim dos dados\n// inicial: valor inicial\n// op: opera\u00e7\u00e3o a ser feita.\n</code></pre> <p>Um exemplo de uso de redu\u00e7\u00e3o para computar o m\u00e1ximo pode ser visto aqui. A lista completa de fun\u00e7\u00f5es que podem ser usadas no lugar de <code>op</code> pode ser vista neste link.</p> <p>Example</p> <p>Continuando o exerc\u00edcio anterior, calcule as seguintes medidas. N\u00e3o se esque\u00e7a de passar o <code>device_vector</code> para a sua fun\u00e7\u00e3o <code>reduce</code></p> <ol> <li>O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es nos \u00faltimos 10 anos.</li> <li>O pre\u00e7o m\u00e9dio das a\u00e7\u00f5es no \u00faltimo ano (365 dias atr\u00e1s).</li> <li>O maior e o menor pre\u00e7o da sequ\u00eancia inteira e do \u00faltimo ano.</li> </ol> <p>Voc\u00ea pode consultar todos os tipos de redu\u00e7\u00f5es dispon\u00edveis no site da thrust.</p>"},{"location":"aulas/14-intro-gpu/#transformacoes-ponto-a-ponto","title":"Transforma\u00e7\u00f5es ponto a ponto","text":"<p>Al\u00e9m de opera\u00e7\u00f5es de redu\u00e7\u00e3o tamb\u00e9m podemos fazer opera\u00e7\u00f5es ponto a ponto em somente um vetor (como negar todas as componentes ou calcular os quadrados) quanto entre dois vetores (como somar dois vetores componente por componente ou comparar cada elemento com seu correspondente em outro vetor). A <code>thrust</code> d\u00e1 o nome de <code>transformation</code> para este tipo de opera\u00e7\u00e3o.</p> <pre><code>// para opera\u00e7\u00f5es entre dois vetores iter1 e iter2. resultado armazenado em out\nthrust::transform(iter1_comeco, iter1_fim, iter2_comeco, out_comeco, op);\n// iter1_comeco: iterador para o come\u00e7o de iter1\n// iter1_fim: iterador para o fim de iter1\n// iter2_comeco: iterador para o come\u00e7o de iter2\n// out_comeco: iterador para o come\u00e7o de out\n// op: opera\u00e7\u00e3o a ser realizada.\n</code></pre> <p>Um exemplo concreto pode ser visto abaixo. O c\u00f3digo completo est\u00e1 em <code>exemplo2-transform.cu</code></p> <pre><code>thrust::device_vector&lt;double&gt; V1(10, 0);\nthrust::device_vector&lt;double&gt; V2(10, 0);\nthrust::device_vector&lt;double&gt; V3(10, 0);\nthrust::device_vector&lt;double&gt; V4(10, 0);\n// inicializa V1 e V2 aqui\n\n//soma V1 e V2\nthrust::transform(V1.begin(), V1.end(), V2.begin(), V3.begin(), thrust::plus&lt;double&gt;());\n\n// multiplica V1 por 0.5\nthrust::transform(V1.begin(), V1.end(),\n                  thrust::constant_iterator&lt;double&gt;(0.5),\n                  V4.begin(), thrust::multiplies&lt;double&gt;());\n</code></pre> <p>As opera\u00e7\u00f5es que foram usadas no <code>reduce</code> tamb\u00e9m podem ser usadas em um <code>transform</code>. N\u00e3o se esque\u00e7a de consultar a lista de opera\u00e7\u00f5es para fazer este exerc\u00edcio.</p> <p>Example</p> <p>Vamos agora trabalhar com o arquivo <code>stocks2.csv</code>. Ele cont\u00e9m a s\u00e9rie hist\u00f3rica de a\u00e7\u00f5es da Apple e da Microsoft. Seu objetivo \u00e9 calcular a diferen\u00e7a m\u00e9dia entre os pre\u00e7os das a\u00e7\u00f5es AAPL e MSFT.</p> <p>Dica: quebre o problema em duas partes. Primeiro calcule a diferen\u00e7a entre os pre\u00e7os e guarde isto em um vetor. Depois compute a m\u00e9dia deste vetor.</p>"},{"location":"aulas/15-gpu-iteradores/","title":"18 - Iteradores em Thrust","text":"<p>Na \u00faltima aula conseguimos rodar algumas fun\u00e7\u00f5es em GPU e medir o custo de transfer\u00eancia de dados. Chegamos a conclus\u00e3o de que, para valer a pena usar a GPU, ou precisamos tratar muitos dados ou precisamos fazer tratamentos pesados.</p> <p>Warning</p> <p>Nesta aula trabalharemos extensivamente com a API da <code>thrust</code> e pediremos para que voc\u00eas consultem a documenta\u00e7\u00e3o oficial da biblioteca. Tamb\u00e9m pode ser \u00fatil ver a se\u00e7\u00e3o de exemplos do reposit\u00f3rio.</p>"},{"location":"aulas/15-gpu-iteradores/#iteradores","title":"Iteradores","text":"<p>Continuando a partir do \u00faltimo item da aula anterior, suponha que voc\u00ea deseja calcular a vari\u00e2ncia das diferen\u00e7as. Agora que j\u00e1 temos a m\u00e9dia, a f\u00f3rmula da vari\u00e2ncia \u00e9 dada por</p> \\frac{1}{n}\\sum_{i=0}^n (x_i - \\mu)^2 <p>Example</p> <p>J\u00e1 sabemos tudo o que precisamos para fazer este c\u00e1lculo. Crie um vetor em que todas as componentes sejam iguais a m\u00e9dia (usando <code>thrust::fill</code>) e compute a vari\u00e2ncia usando a f\u00f3rmula acima.</p> <p>Apesar do c\u00f3digo acima funcionar, ele tem um problema grave: \u00e9 preciso alocar um vetor inteiro somente para preench\u00ea-lo com valores iguais! Se estivermos trabalhando com muitos dados isto significa diminuir bastante a quantidade de dados que conseguimos tratar antes de acabar com a mem\u00f3ria da GPU. Podemos contornar isso usando iteradores, que s\u00e3o vetores gerados dinamicamente pela thrust a partir de um valor \u00fanico ou a partir de outros vetores.</p> <p>Example</p> <p>Pesquise a documenta\u00e7\u00e3o de thrust::constant_iterator e use-o para substituir a aloca\u00e7\u00e3o de mem\u00f3ria extra no exerc\u00edcio acima.</p> <p>Vamos agora nos preparar para a parte 2 criando um programa novamente em cima do arquivo <code>stocks.txt</code>.</p> <p>Example</p> <p>Leia o arquivo <code>stocks.txt</code> e crie um vetor contendo a diferen\u00e7a entre o dia atual e o anterior. Ou seja, dado que o vetor de sa\u00edda tenha nome <code>ganho_diario</code> e o de entrada <code>stocks</code>, temos que</p> <p><code>ganho_diario[i] = stocks[i+1] - stocks[i]</code></p> <p>Claramente <code>ganho_diario.size() == stocks.size() - 1</code>. Leve isto em conta ao utilizar a opera\u00e7\u00e3o <code>transform</code> para criar o vetor <code>ganho_diario</code>.</p>"},{"location":"aulas/15-gpu-iteradores/#operacoes-customizaveis","title":"Opera\u00e7\u00f5es customiz\u00e1veis","text":"<p>Com o vetor <code>ganho_diario</code> acima conseguimos saber se o valor da a\u00e7\u00e3o subiu ou caiu de um dia para o outro! Duas perguntas se seguem:</p> <ol> <li>quantas vezes o valor subiu?</li> <li>qual \u00e9 o aumento m\u00e9dio, considerando s\u00f3 as vezes em que o valor aumentou de fato?</li> </ol> <p>Podemos implementar essas l\u00f3gicas usando opera\u00e7\u00f5es customizadas. Apesar de ser poss\u00edvel escrever essas fun\u00e7\u00f5es do zero, a <code>thrust</code> j\u00e1 possui diversas fun\u00e7\u00f5es de redu\u00e7\u00f5es customiz\u00e1veis.</p> <p>Warning</p> <p>\u00c9 sempre importante consultar a documenta\u00e7\u00e3o para entender como essa fun\u00e7\u00e3o ser\u00e1 aplicada. Em alguns casos \u00e9 necess\u00e1rio que a fun\u00e7\u00e3o passada obede\u00e7a algumas restri\u00e7\u00f5es para que os resultados obtidos fa\u00e7am sentido.</p> <p>Question</p> <p>A <code>thrust</code> j\u00e1 tem suporte a opera\u00e7\u00f5es de redu\u00e7\u00e3o que s\u00e3o contagens. Veja sua documenta\u00e7\u00e3o oficial neste link. Qual fun\u00e7\u00e3o dessa p\u00e1gina voc\u00ea usaria para contar somente os elementos positivos de <code>ganhos_diarios</code>?</p> <p>Warning</p> <p>A fun\u00e7\u00e3o <code>count_if</code> est\u00e1 atualmente com um erro em sua documenta\u00e7\u00e3o (link da issue). N\u00e3o se esque\u00e7a de colocar <code>const</code> no par\u00e2metro de <code>operator()</code>.</p> <p>Example</p> <p>Use a fun\u00e7\u00e3o acima para calcular quantas vezes o valor da a\u00e7\u00e3o subiu.</p> Resposta <p><code>1309</code></p> <p>Vamos agora para o segundo item: \"Calcular o aumento m\u00e9dio, considerando somente as vezes em que o valor aumentou de fato\". Uma estrat\u00e9gia poss\u00edvel \u00e9 zerar todos os elementos negativos do vetor e depois calcular sua soma.</p> <p>Question</p> <p>A documenta\u00e7\u00e3o sobre transforma\u00e7\u00f5es \u00e9 bastante vasta. Voc\u00ea consegue encontrar alguma fun\u00e7\u00e3o que possa substituir elementos de um vetor baseado em uma condi\u00e7\u00e3o booleana?</p> <p>Details</p> <p><code>replace_if</code></p> <p>Example</p> <p>Use a fun\u00e7\u00e3o acima para substituir todos os valores negativos por <code>0</code> em <code>ganhos_diarios</code>.</p> <p>\u00df</p> <p>Example</p> <p>Calcule agora e m\u00e9dia dos valores positivos do vetor. Voc\u00ea j\u00e1 tem todos os que s\u00e3o positivos no exerc\u00edcio acima e a quantidade de valores positivos.</p> Resposta <p><code>5,25179</code></p>"},{"location":"aulas/16-gpu-customizacao/","title":"Thrust - Opera\u00e7\u00f5es customizadas","text":"<p>Vamos conhecer como criar opera\u00e7\u00f5es customizadas com Thrust. Para isso, vamos resolver um problema cl\u00e1ssico denominado <code>Saxpy</code>, o que significa <code>Single precision A X plus Y</code> . Na pr\u00e1tica, consiste em calcular um valor <code>z</code>, que \u00e9 dado por <code>ax + y</code>, onde <code>a</code> \u00e9 uma constante e <code>x</code> e <code>y</code> s\u00e3o vetores.</p> <p>O c\u00f3digo-fonte abaixo resolve o <code>Saxpy</code> em C++/Thrust. Vamos avali\u00e1-lo.</p> <pre><code> #include &lt;thrust/host_vector.h&gt;\n #include &lt;thrust/device_vector.h&gt;\n #include &lt;thrust/generate.h&gt;\n #include &lt;thrust/functional.h&gt;\n #include &lt;thrust/copy.h&gt;\n #include &lt;cstdlib&gt;\n #include &lt;algorithm&gt;\n #include &lt;iostream&gt;\n #include &lt;iomanip&gt;\n\n using namespace  std;\n\nstruct saxpy\n{\n    int a;    \n    saxpy(int a_) : a(a_) {};\n    __host__ __device__\n    double operator()(const int&amp; x, const int&amp; y) {\n           return a * x + y;\n    }\n};\n\nint main(int argc, char* argv[]) {\n     if (argc != 3) {\n         cerr &lt;&lt;\n          \"***Numero incorreto de argumentos ***\\n\";\n         return 1;\n     }\n\n     int n = atoi(argv[1]);\n     int m = atoi(argv[2]);\n\n     //gerar numeros aleatorios\n     thrust::host_vector&lt;int&gt; a(n);\n     thrust::host_vector&lt;int&gt; b(n);\n     thrust::host_vector&lt;int&gt; c(n);\n     thrust::generate(a.begin(), a.end(), rand);\n     thrust::generate(b.begin(), b.end(), rand);\n\n     //transferimos para a GPU\n     thrust::device_vector&lt;int&gt; d_a = a;\n     thrust::device_vector&lt;int&gt; d_b = b;\n\n     //transformacao\n\n     thrust::transform(d_a.begin(), d_a.end(),\n                       d_b.begin(), d_b.end(),\n                       saxpy(m));\n\n     thrust::copy(d_b.begin(), d_b.end(),\n     c.begin()); \n\n     for (int i = 0; i &lt; n; i++ )\n         cout &lt;&lt; setw(6) &lt;&lt; c[i] &lt;&lt; \" = \" \n          &lt;&lt; setw(2) &lt;&lt; m\n          &lt;&lt; \"*\" &lt;&lt; setw(5) &lt;&lt; a[i]\n          &lt;&lt; \"+\" &lt;&lt; setw(5) &lt;&lt; b[i]\n          &lt;&lt; endl;\n\n}\n</code></pre>"},{"location":"aulas/16-gpu-customizacao/#operacoes-customizadas-em-transform","title":"Opera\u00e7\u00f5es customizadas em <code>transform</code>","text":"<p>Para criar nossas pr\u00f3prias opera\u00e7\u00f5es usamos a seguinte sintaxe:</p> <pre><code>struct custom_transform\n{\n    // essas marca\u00e7\u00f5es indicam que o c\u00f3digo deve ser compilado para CPU (host) \n    // e GPU (device)\n    // IMPORTANTE: somente c\u00f3digo com a marca\u00e7\u00e3o __device__ \u00e9 compilado para GPU\n    __host__ __device__\n\n        double operator()(const double&amp; x, const double&amp; y) {\n            // isto pode ser usado com um transform que usa dois vetores \n            // e coloca o resultado em um terceiro.\n\n            // x \u00e9 um elemento do primeiro vetor\n            // y \u00e9 o elemento correspondente do segundo vetor\n\n            // o valor retornado \u00e9 colocado no vetor de resultados\n\n            // para fazer opera\u00e7\u00f5es un\u00e1rias basta receber somente um argumento.\n        }\n};\n</code></pre> <p>A opera\u00e7\u00e3o acima seria aceita em um transform como o abaixo:</p> <pre><code>thrust::device_vector&lt;double&gt; A, B, C;\nthrust::transform(A.begin(), A.end(), B.begin(), C.begin(), custom_transform());\n</code></pre> <p>Note que os tipos dos vetores devem bater com os tipos declarados no <code>struct</code>. Por vezes precisamos receber par\u00e2metros para a opera\u00e7\u00e3o customizada funcionar. Um truque comum \u00e9 adicionar atributos no <code>struct</code> usado como opera\u00e7\u00e3o:</p> <pre><code>struct T {\n    int attr;\n\n    T(int a): attr(a) {};\n\n    // TODO: opera\u00e7\u00e3o customizada aqui\n};\n</code></pre> <p>O valor <code>attr</code> estar\u00e1 dispon\u00edvel para uso dentro da opera\u00e7\u00e3o customizada. A linha <code>T(int a): attr(a) {}</code> declara o construtor do <code>struct T</code>. Ela faz com que o atributo <code>attr</code> seja inicializado com o valor do par\u00e2metro <code>a</code>. Se houver mais de uma atribui\u00e7\u00e3o par\u00e2metro - atributo \u00e9 s\u00f3 usar <code>,</code> para separar as inicializa\u00e7\u00f5es. </p>"},{"location":"aulas/16-gpu-customizacao/#calculando-a-norma-magnitude-de-um-vetor","title":"Calculando a norma / magnitude de um vetor","text":"<p>A magnitude de um vetor consiste na raiz quadrada da soma do quadrado de seus elementos. Dessa forma, voc\u00ea deve complementar o c\u00f3digo abaixo, de modo a criar uma transforma\u00e7\u00e3o customizada <code>square</code>, a qual faz uma transforma\u00e7\u00e3o no vetor transformando os seus elementos ao quadrado, e posteriormente voc\u00ea deve fazer uma redu\u00e7\u00e3o, de modo a obter a magnitude do vetor.</p> <pre><code> #include &lt;iostream&gt;\n #include &lt;iomanip&gt;\n #include &lt;cstdlib&gt;\n #include &lt;chrono&gt;\n #include &lt;cstdlib&gt;\n #include &lt;algorithm&gt;\n//INSIRA AS IMPORTACOES NECESSARIAS DA THRUST\n #include &lt;cmath&gt;\n #include &lt;random&gt;\n\n using namespace std::chrono;\n\n void reportTime(const char* msg, steady_clock::duration span) {\n     auto ms = duration_cast&lt;milliseconds&gt;(span);\n     std::cout &lt;&lt; msg &lt;&lt; \" - levou - \" &lt;&lt;\n      ms.count() &lt;&lt; \" milisegundos\" &lt;&lt; std::endl;\n }\n\n // CRIE UMA FUNCTOR PARA CALCULAR A SQUARE\n\n\n\n // IMPLEMENTE O CALCULO DA MAGNITUDE COM THRUST\n float magnitude(                    ) {\n     float result;\n\n     // ... add Thrust calls\n     // AQUI VAO AS CHAMADAS THRUST \n\n     return result;\n }\n\n int main(int argc, char** argv) {\n     if (argc != 2) {\n         std::cerr &lt;&lt; argv[0] &lt;&lt; \": numero invalido de argumentos\\n\"; \n         std::cerr &lt;&lt; \"uso: \" &lt;&lt; argv[0] &lt;&lt; \"  tamanho do vetor\\n\"; \n         return 1;\n     }\n     int n = std::atoi(argv[1]); //numero de elementos\n     steady_clock::time_point ts, te;\n\n     // Fa\u00e7a um  vector em thrust \n\n\n\n     // inicilize o  vector\n     ts = steady_clock::now();\n\n     std::generate(                ,                      , std::rand);\n\n\n     te = steady_clock::now();\n     reportTime(\"Inicializacao\", te - ts);\n\n     // Calcule a magnitude do vetor\n     ts = steady_clock::now();\n     float len = magnitude(v_d);\n     te = steady_clock::now();\n     reportTime(\"Tempo para calculo\", te - ts);\n\n\n     std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(4);\n     std::cout &lt;&lt; \"Magnitude : \" &lt;&lt; len &lt;&lt; std::endl;\n }\n</code></pre>"},{"location":"aulas/16-gpu-customizacao/#fusion","title":"Fusion","text":"<p>H\u00e1 opera\u00e7\u00f5es de transforma\u00e7\u00e3o e redu\u00e7\u00e3o feitas anteriormente que realizam muita troca de dados. Seria poss\u00edvel otimizar isso?</p> <p>A resposta \u00e9 sim. A Thrust possui o conceito de <code>fusion kernel</code>, o que representa uma estrat\u00e9gia para otimizar transforma\u00e7\u00f5es e redu\u00e7\u00f5es. Modifique o c\u00f3digo anteriormente desenvolvido, agora fazendo uso da transforma\u00e7\u00e3o abaixo:</p> <pre><code>std::sqrt(thrust::transform_reduce( v.begin(), v.end(), unary_op, init, binary_op));\n</code></pre> <p>Pergunta: para o problema da magnitude, quem \u00e9 a <code>unary_op</code> e a <code>binary_op</code>? Qual o valor de <code>init</code>? </p>"},{"location":"aulas/17-gpu-aleatoriedade/","title":"17 - GPU e n\u00fameros aleat\u00f3rios","text":""},{"location":"aulas/17-gpu-aleatoriedade/#revisao-de-numeros-aleatorios","title":"Revis\u00e3o de n\u00fameros aleat\u00f3rios","text":"<p>Um gerador de n\u00fameros pseudo-aleat\u00f3rios (RNG) \u00e9 um algoritmo determin\u00edstico que gera uma sequ\u00eancia de n\u00fameros que parece aleat\u00f3ria. Essa frase possui dois termos importantes que precisamos destrinchar:</p> <ul> <li>determin\u00edstico: Um RNG tipicamente recebe como entrada um inteiro seed (que representa uma sequ\u00eancia de bits \"aleat\u00f3ria\") e gera uma sequ\u00eancia de n\u00fameros baseada no seed. Ou seja, o algoritmo \u00e9 determin\u00edstico pois gera sempre a mesma sequ\u00eancia para uma determinada entrada (seed).</li> <li>parece aleat\u00f3ria: Se compararmos duas sequ\u00eancias de n\u00fameros, uma gerada por um RNG e outra por uma distribui\u00e7\u00e3o uniforme de verdade, n\u00e3o conseguimos dizer qual distribui\u00e7\u00e3o foi gerada pelo RNG.</li> </ul> <p>Ou seja, ao escolhermos um seed a sequ\u00eancia gerada ser\u00e1 sempre a mesma, mesmo se executarmos o programa em outras m\u00e1quinas. Isso torna a utiliza\u00e7\u00e3o de RNGs para experimentos bastante interessante: \u00e9 poss\u00edvel reproduzir os resultados feitos por outros desenvolvedores/cientistas. Para isto \u00e9 necess\u00e1rio</p> <ol> <li>que o programa permita escolher o seed da simula\u00e7\u00e3o;</li> <li>que o seed usado seja publicado junto com os resultados.</li> </ol> <p>Muitas implementa\u00e7\u00f5es de RNGs  s\u00e3o divididas em duas partes:</p> <ol> <li>engine: algoritmo que gera um inteiro cujos bits formam uma sequ\u00eancia pseudo-aleat\u00f3ria.</li> <li>distribution: utiliza os bits acima para retornar n\u00fameros que sigam alguma distribui\u00e7\u00e3o estat\u00edstica (como normal ou uniforme).</li> </ol> <p>A <code>thrust</code> cont\u00e9m uma API de gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios muito parecida com a API da biblioteca padr\u00e3o de C++.</p> <p>Question</p> <p>Consulte a documenta\u00e7\u00e3o oficial da <code>thrust</code> e encontre as p\u00e1ginas que descrevem os engines e distributions implementados.</p> <p>Resposta</p> <pre><code>Abaixo temos um trecho de um c\u00f3digo-fonte que nos mostra como gerar n\u00fameros aleat\u00f3rios com thrust.\n</code></pre> <pre><code>#include &lt;thrust/random.h&gt;\n#include &lt;thrust/device_vector.h&gt;\n#include &lt;thrust/transform.h&gt;\n#include &lt;thrust/iterator/counting_iterator.h&gt;\n#include &lt;vector&gt;\n\nint main() {\nthrust::default_random_engine eng(10);\nthrust::uniform_real_distribution&lt;double&gt; d(20, 30);\n\nfor (int i = 0; i &lt; 10; i++) {\n    std::cout &lt;&lt; d(eng) &lt;&lt; \"\\n\";\n}\n\n}\n</code></pre> <p>Vamos agora fazer um uso b\u00e1sico dessas fun\u00e7\u00f5es.</p> <p>Example</p> <p>Crie um programa que leia um inteiro seed do terminal e:</p> <ol> <li>crie um objeto <code>default_random_engine</code> que o utilize como seed.</li> <li>mostre no terminal uma sequ\u00eancia de 10 n\u00fameros fracion\u00e1rios tirados de uma distribui\u00e7\u00e3o uniforme <code>[25, 40]</code>.</li> </ol> <p>Seu programa dever\u00e1 estar implementado usando os tipos definidos em <code>thrust::random</code>.</p> <p>Um ponto importante da API <code>thrust</code> para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios \u00e9 que essas fun\u00e7\u00f5es podem ser chamadas dentro de opera\u00e7\u00f5es customizadas! Nosso pr\u00f3ximo exerc\u00edcio trata justamente deste uso.</p> <p>Example</p> <p>Fa\u00e7a um programa que cria um vetor com 10 elementos e aplica uma opera\u00e7\u00e3o customizada que seta cada elemento com um valor aleat\u00f3rio. Use as mesmas configura\u00e7\u00f5es do exerc\u00edcio anterior. </p> <p>Resposta</p> <p>Use o trecho de c\u00f3digo disponibilizado neste gist para ver a estrutura da sua fun\u00e7\u00e3o customizada e como voc\u00ea pode criar uma transforma\u00e7\u00e3o que a invoca para cada elemento de um vetor. </p> <p>Warning</p> <p>Voc\u00ea pode prosseguir mesmo se seu vetor tem 10 n\u00fameros iguais.</p>"},{"location":"aulas/17-gpu-aleatoriedade/#gerando-numeros-pseudo-aleatorios-em-gpu","title":"Gerando n\u00fameros pseudo-aleat\u00f3rios em GPU","text":"<p>Um desafio em programas paralelos \u00e9 gerar sequ\u00eancias pseudo-aleat\u00f3rias de qualidade. Se n\u00e3o tormarmos cuidado acabamos gerando os mesmos n\u00fameros em threads diferentes e desperdi\u00e7amos grande quantidade de trabalho!</p> <p>Question</p> <p>Que abordagem voc\u00ea usou para gerar n\u00fameros aleat\u00f3rios em paralelo com OpenMP?</p> <p>Resposta</p> <p>Se voc\u00ea realizou todas as tarefas, deve ter criado um gerador de n\u00fameros pseudo-aleat\u00f3rios para cada thread para calcular o valor de \\pi usando Monte Carlo.</p> <p>Question</p> <p>Voc\u00ea acha que poder\u00edamos aplicar a mesma abordagem para gera\u00e7\u00e3o de n\u00fameros aleat\u00f3rios em GPU? Por qu\u00ea?</p> <p>Resposta</p> <p>Sem cuidados adicionais, n\u00e3o obter\u00edamos bons resultados. A abordagem usada na aula de openMP pressup\u00f5e um n\u00famero relativamente pequeno de threads, de forma que a sequ\u00eancia criada por cada gerador \u00e9 menor, por\u00e9m grande o suficiente para ter qualidade. No caso de usarmos uma GPU, o n\u00famero de threads pode ser muito grande, de forma que cada gerador geraria sequ\u00eancias muito curtas, e por isso perder\u00edamos em qualidade da sequ\u00eancia. </p>"},{"location":"aulas/17-gpu-aleatoriedade/#seeds-em-programas-massivamente-paralelos","title":"Seeds em programas massivamente paralelos","text":"<p>Em computa\u00e7\u00e3o massivamente paralela, em geral, existem duas abordagens.</p> <p>Abordagem 1: usar seeds diferentes em cada thread.</p> <p>Abordagem 2: usar a mesma seed em todas as threads, mas cada uma come\u00e7a em um ponto diferente da sequ\u00eancia daquela seed.</p> <p>Note que em ambos os casos os resultados dependem do n\u00famero de threads usadas! Como vimos em aulas anteriores, um RNG tem estado interno e n\u00e3o pode ser facilmente compartilhado entre v\u00e1rias threads.</p> <p>Example</p> <p>Implemente a abordagem 1 no exerc\u00edcio da parte anterior. Para isto voc\u00ea pode usar a estrat\u00e9gia de acesso direto aos dados e usar o \u00edndice recebido como seed. Lembre-se que a seed \u00e9 definida ao criar o <code>default_random_engine</code>. No exemplo abaixo, voc\u00ea pode ver que ela \u00e9 definida com o valor <code>10</code>. </p> <p><pre><code>    thrust::default_random_engine eng(10);\n</code></pre> Voc\u00ea deve ter percebido que todos os n\u00fameros gerados s\u00e3o parecidos, mas n\u00e3o id\u00eanticos. Isso ocorre pois geradores com *seed*s pr\u00f3ximos geram sequ\u00eancias que s\u00e3o inicialmente parecidas (e depois diferem). Podemos consertar isto usando seeds mais distantes.</p> <p>Example</p> <p>Multiplique <code>i</code> por um valor grande e tente de novo. Verifique que agora os n\u00fameros s\u00e3o diferentes</p>"},{"location":"aulas/17-gpu-aleatoriedade/#exercicio-pratico","title":"Exerc\u00edcio pr\u00e1tico","text":"<p>Vamos trabalhar com um m\u00e9todo probabil\u00edstico de estima\u00e7\u00e3o do <code>pi</code> neste \u00faltimo exerc\u00edcio. O algoritmo sequencial se baseia em sorteios de pontos dentro de um quadrado de lado <code>2</code>. Se a dist\u00e2ncia entre o ponto e o centro do quadrado for menor que 1 ent\u00e3o o ponto cai dentro do c\u00edrculo inscrito no quadrado. A quantidade de pontos que caem dentro do quadrado \u00e9 proporcional a \\pi. </p> <ol> <li><code>sum = 0</code></li> <li>De <code>i=0</code> at\u00e9 <code>N</code>:<ol> <li>sorteie pontos x,y \\in [0,1]</li> <li>se x^2 + y^2 \\leq 1, <code>sum += 1</code></li> </ol> </li> <li>devolva <code>4 * sum / N</code></li> </ol> <p>Example</p> <p>Resgate a implementa\u00e7\u00e3o sequencial deste algoritmo realizada na aula (dispon\u00edvel neste gist) e rode-a para <code>N=100000000</code></p> <p>Example</p> <p>Paralelize o c\u00f3digo acima em GPU. Use ambas as abordagens acima em programas distintos para lidar com os geradores de n\u00fameros aleat\u00f3rios.</p>"},{"location":"aulas/18-Introducao-mpi/","title":"18 - Introdu\u00e7\u00e3o a MPI","text":"<p>Message Passing Interface (MPI) \u00e9 um padr\u00e3o para comunica\u00e7\u00e3o de dados em computa\u00e7\u00e3o paralela. Existem v\u00e1rias modalidades de computa\u00e7\u00e3o paralela, e dependendo do problema que se est\u00e1 tentando resolver, pode ser necess\u00e1rio passar informa\u00e7\u00f5es entre os v\u00e1rios processadores ou nodos de um cluster, e o MPI oferece uma infraestrutura para essa tarefa.</p> <p>Para iniciarmos o nosso estudo de MPI, abra o seguinte notebook no Google Colab e siga as instru\u00e7\u00f5es contidas:</p> <p>Notebook de Introdu\u00e7\u00e3o a MPI Dica: Fa\u00e7a uma c\u00f3pia do notebook para a sua conta do Colab, no menu File (ou Arquivo), op\u00e7\u00e3o Save a Copy in Drive (Salvar uma c\u00f3pia no Drive). </p>"},{"location":"aulas/19-MPI_REDUCE-mpi/","title":"19 - Opera\u00e7\u00f5es de Redu\u00e7\u00e3o em MPI","text":"<p>Reduzir \u00e9 um conceito cl\u00e1ssico da programa\u00e7\u00e3o funcional. A redu\u00e7\u00e3o de dados envolve a redu\u00e7\u00e3o de um conjunto de n\u00fameros em um conjunto menor de n\u00fameros por meio de uma fun\u00e7\u00e3o. Por exemplo, digamos que temos uma lista de n\u00fameros [1, 2, 3, 4, 5]. Reduzir esta lista de n\u00fameros com a fun\u00e7\u00e3o sum produziria sum([1, 2, 3, 4, 5]) = 15. Da mesma forma, a redu\u00e7\u00e3o da multiplica\u00e7\u00e3o resultaria em multiplicar([1, 2, 3, 4, 5]) = 120.</p> <p>Como voc\u00ea deve ter imaginado, pode ser muito complicado aplicar fun\u00e7\u00f5es de redu\u00e7\u00e3o em um conjunto de n\u00fameros distribu\u00eddos. Junto com isso, \u00e9 dif\u00edcil programar de forma eficiente redu\u00e7\u00f5es n\u00e3o comutativas, ou seja, redu\u00e7\u00f5es que devem ocorrer em uma ordem definida. Felizmente, o MPI tem uma fun\u00e7\u00e3o \u00fatil chamada MPI_Reduce que ir\u00e1 lidar com quase todas as redu\u00e7\u00f5es comuns que um programador precisa fazer em um aplicativo paralelo.</p> <p>Para iniciarmos o nosso estudo de redu\u00e7\u00f5es em MPI, abra o seguinte notebook no Google Colab e siga as instru\u00e7\u00f5es contidas:</p> <p>Redu\u00e7\u00f5es em MPI Dica: Fa\u00e7a uma c\u00f3pia do notebook para a sua conta do Colab, no menu File (ou Arquivo), op\u00e7\u00e3o Save a Copy in Drive (Salvar uma c\u00f3pia no Drive). </p>"},{"location":"aulas/19-MPI_REDUCE-mpi/MPI_AULA2/","title":"MPI AULA2","text":"<pre><code>!apt install simgrid\n</code></pre> <pre>\n<code>Reading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nNote, selecting 'libsimgrid-dev' instead of 'simgrid'\nThe following additional packages will be installed:\n  libsimgrid3.24 lua5.1 simgrid-java\nSuggested packages:\n  java-virtual-machine\nThe following NEW packages will be installed:\n  libsimgrid-dev libsimgrid3.24 lua5.1 simgrid-java\n0 upgraded, 4 newly installed, 0 to remove and 24 not upgraded.\nNeed to get 1,644 kB of archives.\nAfter this operation, 5,797 kB of additional disk space will be used.\nGet:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid3.24 amd64 3.24+dfsg-3 [1,328 kB]\nGet:2 http://archive.ubuntu.com/ubuntu focal/universe amd64 lua5.1 amd64 5.1.5-8.1build4 [94.6 kB]\nGet:3 http://archive.ubuntu.com/ubuntu focal/universe amd64 simgrid-java amd64 3.24+dfsg-3 [76.5 kB]\nGet:4 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid-dev amd64 3.24+dfsg-3 [145 kB]\nFetched 1,644 kB in 3s (587 kB/s)\nSelecting previously unselected package libsimgrid3.24.\n(Reading database ... 122520 files and directories currently installed.)\nPreparing to unpack .../libsimgrid3.24_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid3.24 (3.24+dfsg-3) ...\nSelecting previously unselected package lua5.1.\nPreparing to unpack .../lua5.1_5.1.5-8.1build4_amd64.deb ...\nUnpacking lua5.1 (5.1.5-8.1build4) ...\nSelecting previously unselected package simgrid-java.\nPreparing to unpack .../simgrid-java_3.24+dfsg-3_amd64.deb ...\nUnpacking simgrid-java (3.24+dfsg-3) ...\nSelecting previously unselected package libsimgrid-dev.\nPreparing to unpack .../libsimgrid-dev_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid-dev (3.24+dfsg-3) ...\nSetting up libsimgrid3.24 (3.24+dfsg-3) ...\nSetting up lua5.1 (5.1.5-8.1build4) ...\nupdate-alternatives: using /usr/bin/lua5.1 to provide /usr/bin/lua (lua-interpreter) in auto mode\nupdate-alternatives: using /usr/bin/luac5.1 to provide /usr/bin/luac (lua-compiler) in auto mode\nSetting up simgrid-java (3.24+dfsg-3) ...\nSetting up libsimgrid-dev (3.24+dfsg-3) ...\nProcessing triggers for man-db (2.9.1-1) ...\nProcessing triggers for libc-bin (2.31-0ubuntu9.9) ...\n</code>\n</pre> <pre><code>!git clone https://framagit.org/simgrid/simgrid-template-smpi.git\n</code></pre> <pre>\n<code>Cloning into 'simgrid-template-smpi'...\nremote: Enumerating objects: 482, done.\nremote: Counting objects: 100% (482/482), done.\nremote: Compressing objects: 100% (338/338), done.\nremote: Total 482 (delta 181), reused 434 (delta 139), pack-reused 0\nReceiving objects: 100% (482/482), 967.28 KiB | 1.92 MiB/s, done.\nResolving deltas: 100% (181/181), done.\n</code>\n</pre> <p>Na aula passada, implementamos um c\u00f3digo para aproxima\u00e7\u00e3o de PI usando MPI com 8 e 16 nodos de um cluster, utilizando as primitivas de comunica\u00e7\u00e3o MPI_Send e MPI_Recv.</p> <pre><code>%%writefile pi_send_receive.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"mpi.h\"\n#include &lt;math.h&gt;\n#define SEED_MPI 35791246\n\nint main(int argc, char* argv[])\n{\n    long niter = 10000000;\n    int myid;                       //holds process's rank id\n    double x,y;                     //x,y value for the random coordinate\n    int i, count=0;                 //Count holds all the number of how many good coordinates\n    double z;                       //Used to check if x^2+y^2&amp;lt;=1\n    double pi;                      //holds approx value of pi\n    int nodenum;\n\n    MPI_Init(&amp;amp;argc, &amp;amp;argv);                 //Start MPI\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myid);           //get rank of node's process\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;nodenum);\n    int recieved[nodenum];\n    long recvniter[nodenum];\n    srand(SEED_MPI+myid);                       //Give rand() a seed value. Needs to be different on each node\n\n    if(myid != 0)\n    {\n        for (i=0; i&lt;niter; %f\\n\",=\"\" (myid=\"0)\" (z&lt;=\"1)\" +=\"recvniter[i];\" ++i)=\"\" 0;=\"\" &lt;=\"\" ```=\"\" a=\"\" calculated=\"\" checks=\"\" circle=\"\" close=\"\" cluster.=\"\" consider=\"\" coordinate=\"\" count++;=\"\" crossbar=\"\" div=\"\" else=\"\" explanations=\"\" finalcount=\"\" finalniter=\"\" for(i=\"0;\" gets=\"\" i&lt;nodenum;=\"\" if=\"\" in=\"\" inside=\"\" instance=\"\" int=\"\" is,=\"\" it=\"\" long=\"\" loop=\"\" main=\"\" master=\"\" mpi=\"\" mpi_finalize();=\"\" mpi_recv(&amp;recieved[i],nodenum,mpi_int,mpi_any_source,1,mpi_comm_world,mpi_status_ignore);=\"\" mpi_recv(&amp;recvniter[i],nodenum,mpi_long,mpi_any_source,2,mpi_comm_world,mpi_status_ignore);=\"\" mpi_send(&amp;count,1,mpi_int,0,1,mpi_comm_world);=\"\" mpi_send(&amp;niter,1,mpi_long,0,2,mpi_comm_world);=\"\" number=\"\" of=\"\" on=\"\" p=\"4(m/n)\" pi=\"\" pi);=\"\" point=\"\" print=\"\" printf(\"pi:=\"\" process=\"\" program=\"\" random=\"\" return=\"\" see=\"\" simulate=\"\" text.=\"\" the=\"\" this=\"\" to=\"\" unit=\"\" valid=\"\" value=\"\" we=\"\" will=\"\" x=\"\" y=\"\" z=\"sqrt(x*x+y*y);\" {=\"\" }=\"\"&gt;\n&lt;div class=\"output_wrapper\" markdown=\"1\"&gt;\n&lt;div class=\"output\" markdown=\"1\"&gt;\n&lt;div class=\"output_area\" markdown=\"1\"&gt;\n&lt;div class=\"output_subarea output_stream output_stdout output_text\"&gt;\n&lt;pre&gt;\n&lt;code&gt;Overwriting pi_send_receive.c\n&lt;/code&gt;\n&lt;/pre&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/niter;&gt;&lt;/math.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;&lt;/div&gt;\n&lt;div class=\"cell border-box-sizing text_cell rendered\" markdown=\"1\"&gt;\n&lt;div class=\"inner_cell\" markdown=\"1\"&gt;\n&lt;div class=\"text_cell_render border-box-sizing rendered_html\" markdown=\"1\"&gt;\nObserve que, nesta solu\u00e7\u00e3o, cada escravo est\u00e1 enviando um n\u00famero de mensagens igual ao n\u00famero de n\u00f3s do cluster. Isto \u00e9 necess\u00e1rio porque vamos simular a execu\u00e7\u00e3o numa topologia de cluster do tipo crossbar:\n\nhttps://simgrid.github.io/SMPI_CourseWare/topic_getting_started/platforms/\n\nNesta arquitetura, cada n\u00f3 potencialmente pode ser um mestre e s\u00f3 vamos saber qual n\u00f3 \u00e9 o mestre no momento da execu\u00e7\u00e3o. Se us\u00e1ssemos uma topologia do tipo estrela, com o mestre j\u00e1 conhecido, bastariam somente 2 mensagens de cada escravo.\n\nObserve, tamb\u00e9m, que o mestre indica que pode receber mensagens de qualquer processo remoto pelo uso do par\u00e2metro MPI_ANY_SOURCE.\n\nAgora, vamos compilar e executar este programa no nosso cluster crossbar:\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;/div&gt;\n&lt;div class=\"cell border-box-sizing code_cell rendered\" markdown=\"1\"&gt;\n&lt;div class=\"input\"&gt;\n\n```python\n!smpicc pi_send_receive.c -o pi_send_receive -lm\n</code></pre> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./pi_send_receive\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nPi: 3.142268\n</code>\n</pre> <p>Observe que todas as comunica\u00e7\u00f5es acima s\u00e3o do tipo ponto-a-ponto: cada processo-escravo envia mensagens diretamente para o nodo de rank 0 (mestre), informando a contagem de pontos que ca\u00edram dentro do quarto de c\u00edrculo e o n\u00famero de intera\u00e7\u00f5es realizado. O mestre, ent\u00e3o, recebe as mensagens de todos os escravos e sumariza os resultados. Neste caso, dizemos que o mestre reduziu os dados coletados dos escravos. </p> <p>O trecho de c\u00f3digo abaixo mostra como aplicar MPI_REDUCE para calcular uma m\u00e9dia de valores produzidos por processos-escravos:</p> <pre><code>%%writefile avg.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;time.h&gt;\n\n// Creates an array of random numbers. Each number has a value from 0 - 1\nfloat *create_rand_nums(int num_elements) {\n  float *rand_nums = (float *)malloc(sizeof(float) * num_elements);\n  assert(rand_nums != NULL);\n  int i;\n  for (i = 0; i &amp;lt; num_elements; i++) {\n    rand_nums[i] = (rand() / (float)RAND_MAX);\n  }\n  return rand_nums;\n}\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: avg num_elements_per_proc\\n\");\n    exit(1);\n  }\n\n  int num_elements_per_proc = atoi(argv[1]);\n\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;world_size);\n\n  // Create a random array of elements on all processes.\n  srand(time(NULL)*world_rank);   // Seed the random number generator to get different results each time for each processor\n  float *rand_nums = NULL;\n  rand_nums = create_rand_nums(num_elements_per_proc);\n\n  // Sum the numbers locally\n  float local_sum = 0;\n  int i;\n  for (i = 0; i &amp;lt; num_elements_per_proc; i++) {\n    local_sum += rand_nums[i];\n  }\n\n  // Print the random numbers on each process\n  printf(\"Local sum for process %d - %f, avg = %f\\n\",\n         world_rank, local_sum, local_sum / num_elements_per_proc);\n\n  // Reduce all of the local sums into the global sum\n  float global_sum;\n  MPI_Reduce(&amp;amp;local_sum, &amp;amp;global_sum, 1, MPI_FLOAT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // Print the result\n  if (world_rank == 0) {\n    printf(\"Total sum = %f, avg = %f\\n\", global_sum,\n           global_sum / (world_size * num_elements_per_proc));\n  }\n\n  // Clean up\n  free(rand_nums);\n\n  MPI_Barrier(MPI_COMM_WORLD);\n  MPI_Finalize();\n}\n</code></pre> <pre>\n<code>Writing avg.c\n</code>\n</pre> <p>EXERC\u00cdCIO 1</p> <p>Compile e teste o programa acima. </p> <pre><code>!smpicc avg.c -o avg -lm\n</code></pre> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./avg 100\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nLocal sum for process 0 - 54.682476, avg = 0.546825\nLocal sum for process 1 - 53.733265, avg = 0.537333\nLocal sum for process 2 - 50.004021, avg = 0.500040\nLocal sum for process 3 - 48.533802, avg = 0.485338\nLocal sum for process 4 - 53.392612, avg = 0.533926\nLocal sum for process 5 - 52.567123, avg = 0.525671\nLocal sum for process 6 - 46.119843, avg = 0.461198\nLocal sum for process 7 - 46.484497, avg = 0.464845\nLocal sum for process 8 - 51.973499, avg = 0.519735\nLocal sum for process 9 - 50.640781, avg = 0.506408\nLocal sum for process 10 - 46.569996, avg = 0.465700\nLocal sum for process 11 - 57.496677, avg = 0.574967\nLocal sum for process 12 - 52.161461, avg = 0.521615\nLocal sum for process 13 - 48.333683, avg = 0.483337\nLocal sum for process 14 - 46.418041, avg = 0.464180\nLocal sum for process 15 - 54.174198, avg = 0.541742\nTotal sum = 813.286011, avg = 0.508304\n</code>\n</pre> <p>Muitos aplicativos paralelos exigir\u00e3o o acesso aos resultados reduzidos em todos os processos, em vez do processo-mestre. MPI_Allreduce \u00e9 uma primitiva de comunica\u00e7\u00e3o MPI que reduzir\u00e1 os valores e distribuir\u00e1 os resultados para todos os processos. O prot\u00f3tipo da fun\u00e7\u00e3o \u00e9 o seguinte:</p> <p>MPI_Allreduce(     void* send_data,     void* recv_data,     int count,     MPI_Datatype datatype,     MPI_Op op,     MPI_Comm communicator)</p> <p>Como voc\u00ea deve ter notado, MPI_Allreduce \u00e9 id\u00eantico a MPI_Reduce com a exce\u00e7\u00e3o de que n\u00e3o precisa de um ID de processo raiz (j\u00e1 que os resultados s\u00e3o distribu\u00eddos para todos os processos). A pr\u00f3xima imagem ilustra o padr\u00e3o de comunica\u00e7\u00e3o de MPI_Allreduce:</p> <p></p> <p>Muitos problemas computacionais requerem redu\u00e7\u00f5es m\u00faltiplas para resolver problemas. Um desses problemas \u00e9 encontrar o desvio padr\u00e3o de um conjunto distribu\u00eddo de n\u00fameros. Para aqueles que podem ter esquecido, o desvio padr\u00e3o \u00e9 uma medida da dispers\u00e3o dos n\u00fameros de sua m\u00e9dia. Um desvio padr\u00e3o mais baixo significa que os n\u00fameros est\u00e3o mais pr\u00f3ximos e vice-versa para desvios padr\u00e3o mais altos.</p> <p>Para encontrar o desvio padr\u00e3o, deve-se primeiro calcular a m\u00e9dia de todos os n\u00fameros. Depois que a m\u00e9dia \u00e9 calculada, as somas da diferen\u00e7a quadrada da m\u00e9dia s\u00e3o calculadas. A raiz quadrada da m\u00e9dia das somas \u00e9 o resultado final. Dada a descri\u00e7\u00e3o do problema, sabemos que haver\u00e1 pelo menos duas somas de todos os n\u00fameros, traduzindo-se em duas redu\u00e7\u00f5es.</p> <p>O c\u00f3digo para fazer isto encontra-se abaixo:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;math.h&gt;\n#include &lt;assert.h&gt;\n\n// Creates an array of random numbers. Each number has a value from 0 - 1\n\nfloat *create_rand_nums(int num_elements) {\n  float *rand_nums = (float *)malloc(sizeof(float) * num_elements);\n  assert(rand_nums != NULL);\n  int i;\n  for (i = 0; i &amp;lt; num_elements; i++) {\n    rand_nums[i] = (rand() / (float)RAND_MAX);\n  }\n  return rand_nums;\n}\n\nint main(int argc, char** argv) {\n  if (argc != 2) {\n    fprintf(stderr, \"Usage: avg num_elements_per_proc\\n\");\n    exit(1);\n  }\n\n  int num_elements_per_proc = atoi(argv[1]);\n\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;world_size);\n\n  // Create a random array of elements on all processes.\n  srand(time(NULL)*world_rank); // Seed the random number generator of processes uniquely\n  float *rand_nums = NULL;\n  rand_nums = create_rand_nums(num_elements_per_proc);\n\n  // Sum the numbers locally\n  float local_sum = 0;\n  int i;\n  for (i = 0; i &amp;lt; num_elements_per_proc; i++) {\n    local_sum += rand_nums[i];\n  }\n\n  // Reduce all of the local sums into the global sum in order to\n  // calculate the mean\n  float global_sum;\n  MPI_Allreduce(&amp;amp;local_sum, &amp;amp;global_sum, 1, MPI_FLOAT, MPI_SUM,\n                MPI_COMM_WORLD);\n  float mean = global_sum / (num_elements_per_proc * world_size);\n\n  // Compute the local sum of the squared differences from the mean\n  float local_sq_diff = 0;\n  for (i = 0; i &amp;lt; num_elements_per_proc; i++) {\n    local_sq_diff += (rand_nums[i] - mean) * (rand_nums[i] - mean);\n  }\n\n  // Reduce the global sum of the squared differences to the root process\n  // and print off the answer\n  float global_sq_diff;\n  MPI_Reduce(&amp;amp;local_sq_diff, &amp;amp;global_sq_diff, 1, MPI_FLOAT, MPI_SUM, 0,\n             MPI_COMM_WORLD);\n\n  // The standard deviation is the square root of the mean of the squared\n  // differences.\n  if (world_rank == 0) {\n    float stddev = sqrt(global_sq_diff /\n                        (num_elements_per_proc * world_size));\n    printf(\"Mean - %f, Standard deviation = %f\\n\", mean, stddev);\n  }\n\n  // Clean up\n  free(rand_nums);\n\n  MPI_Barrier(MPI_COMM_WORLD);\n  MPI_Finalize();\n}\n</code></pre> <p>EXERC\u00cdCIO 2</p> <p>Compile e teste o programa acima. </p> <pre><code>#IMPLEMENTE SEU C\u00d3DIGO AQUI\n</code></pre> <p>EXERC\u00cdCIO 3</p> <p>Refatore o c\u00f3digo pi_send_receive.c para utilizar a primitiva MPI_Reduce ao inv\u00e9s de MPI_Send e MPI_Recv.</p> <pre><code>#IMPLEMENTE SEU C\u00d3DIGO AQUI\n</code></pre> <p>EXERC\u00cdCIO 4</p> <p>Refatore o c\u00f3digo anterior produzindo um c\u00f3digo paralelo h\u00edbrido:</p> <ul> <li>O nodo-mestre calcular\u00e1 o n\u00fameros de pontos via OpenMP com 16 threads</li> <li>Os resultados dos nodos-escravos ser\u00e3o coletados via MPI_Reduce e reduzidos no nodo-mestre.</li> </ul> <pre><code>#IMPLEMENTE SEU C\u00d3DIGO AQUI\n</code></pre>"},{"location":"aulas/19-MPI_REDUCE-mpi/MPI_AULA2/#message-passing-interface-aula-2","title":"MESSAGE PASSING INTERFACE (AULA 2)","text":""},{"location":"aulas/19-MPI_REDUCE-mpi/MPI_AULA2/#reducao-distribuida-de-processamento","title":"REDU\u00c7\u00c3O DISTRIBU\u00cdDA DE PROCESSAMENTO","text":"<p>Inicialmente, vamos reinstalar o simgrid e fazer o download do modelos de clusters:</p>"},{"location":"aulas/19-MPI_REDUCE-mpi/MPI_AULA2/#mpi_reduce-e-mpi_allreduce","title":"MPI_REDUCE e MPI_ALLREDUCE","text":"<p>MPI_Reduce \u00e9 uma primitiva de comunica\u00e7\u00e3o MPI que coleta valores calculados por cada processo-escravo e os repassa para o processo-mestre para que possam ser reduzidos. A sintaxe de MPI_Reduce \u00e9 mostrada abaixo:</p> <p>MPI_Reduce(     void* send_data,     void* recv_data,     int count,     MPI_Datatype datatype,     MPI_Op op,     int root,     MPI_Comm communicator)</p> <p>O par\u00e2metro send_data \u00e9 um array de elementos do tipo datatype que cada processo deseja reduzir. O recv_data s\u00f3 \u00e9 relevante no processo com rank root. A matriz recv_data cont\u00e9m o resultado reduzido e tem um tamanho de sizeof(datatype) * count. O par\u00e2metro op \u00e9 a opera\u00e7\u00e3o que voc\u00ea deseja aplicar aos seus dados. O MPI cont\u00e9m um conjunto de opera\u00e7\u00f5es de redu\u00e7\u00e3o comuns que podem ser usadas. Embora as opera\u00e7\u00f5es de redu\u00e7\u00e3o personalizadas possam ser definidas, isso est\u00e1 al\u00e9m do escopo desta aula. As opera\u00e7\u00f5es de redu\u00e7\u00e3o definidas pela MPI incluem:</p> <ul> <li>MPI_MAX - Retorna o elemento m\u00e1ximo.</li> <li>MPI_MIN - Retorna o elemento m\u00ednimo.</li> <li>MPI_SUM - Soma os elementos.</li> <li>MPI_PROD - Multiplica todos os elementos.</li> <li>MPI_LAND - AND l\u00f3gico entre os elementos.</li> <li>MPI_LOR - OR l\u00f3gico entre os elementos.</li> <li>MPI_BAND - AND bit-a-bit dos elementos.</li> <li>MPI_BOR - OR bit-a-bit dos elementos.</li> <li>MPI_MAXLOC - Retorna o valor m\u00e1ximo e o rank do processo que o possui.</li> <li>MPI_MINLOC - Retorna o valor m\u00ednimo e o rank do processo que o possui.</li> </ul> <p>Abaixo est\u00e1 uma ilustra\u00e7\u00e3o do padr\u00e3o de comunica\u00e7\u00e3o do MPI_Reduce para o operador de soma:</p> <p></p> <p>Tamb\u00e9m \u00e9 \u00fatil ver o que acontece quando os processos cont\u00eam v\u00e1rios elementos. A ilustra\u00e7\u00e3o abaixo mostra a redu\u00e7\u00e3o de v\u00e1rios n\u00fameros por processo:</p> <p></p> <p>Cada um dos processos da ilustra\u00e7\u00e3o acima tem dois elementos. A soma resultante ocorre por elemento. Em outras palavras, em vez de somar todos os elementos de todas as matrizes em um \u00fanico elemento, o i-\u00e9simo elemento de cada matriz \u00e9 somado ao i-\u00e9simo elemento na matriz de resultados do processo 0.</p>"},{"location":"aulas/20%20-%20Broadcasting-mpi/","title":"20 - COMUNICA\u00c7\u00c3O COLETIVA E BROADCASTING","text":"<p>Nas aulas passadas, examinamos a comunica\u00e7\u00e3o ponto a ponto, que \u00e9 a comunica\u00e7\u00e3o entre dois processos. Nesta aula, estudaremos os mecanismos de comunica\u00e7\u00e3o coletiva em MPI. A comunica\u00e7\u00e3o coletiva \u00e9 um m\u00e9todo de comunica\u00e7\u00e3o que envolve a participa\u00e7\u00e3o de todos os processos em um comunicador.</p> <p>Broadcasting Dica: Fa\u00e7a uma c\u00f3pia do notebook para a sua conta do Colab, no menu File (ou Arquivo), op\u00e7\u00e3o Save a Copy in Drive (Salvar uma c\u00f3pia no Drive). </p>"},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/","title":"MPI AULA3","text":"<pre><code>!apt install simgrid\n</code></pre> <pre>\n<code>Reading package lists... Done\nBuilding dependency tree       \nReading state information... Done\nNote, selecting 'libsimgrid-dev' instead of 'simgrid'\nThe following additional packages will be installed:\n  libsimgrid3.24 lua5.1 simgrid-java\nSuggested packages:\n  java-virtual-machine\nThe following NEW packages will be installed:\n  libsimgrid-dev libsimgrid3.24 lua5.1 simgrid-java\n0 upgraded, 4 newly installed, 0 to remove and 24 not upgraded.\nNeed to get 1,644 kB of archives.\nAfter this operation, 5,797 kB of additional disk space will be used.\nGet:1 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid3.24 amd64 3.24+dfsg-3 [1,328 kB]\nGet:2 http://archive.ubuntu.com/ubuntu focal/universe amd64 lua5.1 amd64 5.1.5-8.1build4 [94.6 kB]\nGet:3 http://archive.ubuntu.com/ubuntu focal/universe amd64 simgrid-java amd64 3.24+dfsg-3 [76.5 kB]\nGet:4 http://archive.ubuntu.com/ubuntu focal/universe amd64 libsimgrid-dev amd64 3.24+dfsg-3 [145 kB]\nFetched 1,644 kB in 1s (1,369 kB/s)\nSelecting previously unselected package libsimgrid3.24.\n(Reading database ... 122531 files and directories currently installed.)\nPreparing to unpack .../libsimgrid3.24_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid3.24 (3.24+dfsg-3) ...\nSelecting previously unselected package lua5.1.\nPreparing to unpack .../lua5.1_5.1.5-8.1build4_amd64.deb ...\nUnpacking lua5.1 (5.1.5-8.1build4) ...\nSelecting previously unselected package simgrid-java.\nPreparing to unpack .../simgrid-java_3.24+dfsg-3_amd64.deb ...\nUnpacking simgrid-java (3.24+dfsg-3) ...\nSelecting previously unselected package libsimgrid-dev.\nPreparing to unpack .../libsimgrid-dev_3.24+dfsg-3_amd64.deb ...\nUnpacking libsimgrid-dev (3.24+dfsg-3) ...\nSetting up libsimgrid3.24 (3.24+dfsg-3) ...\nSetting up lua5.1 (5.1.5-8.1build4) ...\nupdate-alternatives: using /usr/bin/lua5.1 to provide /usr/bin/lua (lua-interpreter) in auto mode\nupdate-alternatives: using /usr/bin/luac5.1 to provide /usr/bin/luac (lua-compiler) in auto mode\nSetting up simgrid-java (3.24+dfsg-3) ...\nSetting up libsimgrid-dev (3.24+dfsg-3) ...\nProcessing triggers for man-db (2.9.1-1) ...\nProcessing triggers for libc-bin (2.31-0ubuntu9.9) ...\n</code>\n</pre> <pre><code>!git clone https://framagit.org/simgrid/simgrid-template-smpi.git\n</code></pre> <pre>\n<code>Cloning into 'simgrid-template-smpi'...\nremote: Enumerating objects: 482, done.\nremote: Counting objects: 100% (482/482), done.\nremote: Compressing objects: 100% (338/338), done.\nremote: Total 482 (delta 180), reused 435 (delta 139), pack-reused 0\nReceiving objects: 100% (482/482), 967.66 KiB | 1.48 MiB/s, done.\nResolving deltas: 100% (180/180), done.\n</code>\n</pre> <p>Uma das coisas a lembrar sobre a comunica\u00e7\u00e3o coletiva \u00e9 que ela implica um ponto de sincroniza\u00e7\u00e3o entre os processos. Isso significa que todos os processos devem atingir um ponto em seu c\u00f3digo antes que possam come\u00e7ar a executar novamente.</p> <p>Antes de entrar em detalhes sobre as rotinas de comunica\u00e7\u00e3o coletiva, vamos examinar a sincroniza\u00e7\u00e3o com mais detalhes. Acontece que o MPI possui uma fun\u00e7\u00e3o especial dedicada \u00e0 sincroniza\u00e7\u00e3o de processos:</p> <p>MPI_Barrier(MPI_Comm communicator)</p> <p>O nome da fun\u00e7\u00e3o \u00e9 bastante descritivo - a fun\u00e7\u00e3o forma uma barreira e nenhum processo no comunicador pode ultrapassar a barreira at\u00e9 que todos chamem a fun\u00e7\u00e3o. Imagine que o eixo horizontal representa a execu\u00e7\u00e3o do programa e os c\u00edrculos representam diferentes processos:</p> <p></p> <p>O processo zero primeiro chama MPI_Barrier no primeiro instante (T 1). Enquanto o processo zero est\u00e1 parado na barreira, o processo um e tr\u00eas eventualmente o fazem (T 2). Quando o processo dois finalmente chega \u00e0 barreira (T 3), todos os processos iniciam a execu\u00e7\u00e3o novamente (T 4).</p> <p>Lembre-se sempre de que todas as chamadas coletivas que voc\u00ea fizer s\u00e3o sincronizadas. Em outras palavras, se voc\u00ea n\u00e3o conseguir concluir com \u00eaxito um MPI_Barrier, tamb\u00e9m n\u00e3o poder\u00e1 concluir com \u00eaxito nenhuma chamada coletiva. Se voc\u00ea tentar chamar MPI_Barrier ou outras rotinas coletivas sem garantir que todos os processos no comunicador tamb\u00e9m o chamem, seu programa ficar\u00e1 ocioso. Isso pode ser muito confuso para iniciantes, ent\u00e3o tome cuidado!</p> <p></p> <p>Neste exemplo, o processo zero \u00e9 o processo-raiz e possui a c\u00f3pia inicial dos dados. Todos os outros processos recebem a c\u00f3pia dos dados.</p> <p>Em MPI, a transmiss\u00e3o pode ser realizada usando MPI_Bcast. O prot\u00f3tipo da fun\u00e7\u00e3o \u00e9 mostrado a seguir:</p> <p>MPI_Bcast(     void* data,     int count,     MPI_Datatype datatype,     int root,     MPI_Comm communicator)</p> <p>Embora o processo raiz e os processos receptores executem tarefas diferentes, todos eles chamam a mesma fun\u00e7\u00e3o MPI_Bcast. Quando o processo raiz (no nosso exemplo era o processo zero) chamar MPI_Bcast, a vari\u00e1vel de dados ser\u00e1 enviada para todos os outros processos. Quando todos os processos receptores chamarem MPI_Bcast, a vari\u00e1vel data ser\u00e1 preenchida com os dados do processo raiz.</p> <p>A transmiss\u00e3o pode ser implementada com as primitivas MPI_Send e MPI_Recv, conforme mostrado no programa abaixo:</p> <pre><code>%%writefile mybcast.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n\nvoid my_bcast(void* data, int count, MPI_Datatype datatype, int root,\n              MPI_Comm communicator) {\n  int world_rank;\n  MPI_Comm_rank(communicator, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(communicator, &amp;amp;world_size);\n\n  if (world_rank == root) {\n    // If we are the root process, send our data to everyone\n    int i;\n    for (i = 0; i &amp;lt; world_size; i++) {\n      if (i != world_rank) {\n        MPI_Send(data, count, datatype, i, 0, communicator);\n      }\n    }\n  } else {\n    // If we are a receiver process, receive the data from the root\n    MPI_Recv(data, count, datatype, root, 0, communicator, MPI_STATUS_IGNORE);\n  }\n}\n\nint main(int argc, char** argv) {\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n\n  int data;\n  if (world_rank == 0) {\n    data = 100;\n    printf(\"Process 0 broadcasting data %d\\n\", data);\n    my_bcast(&amp;amp;data, 1, MPI_INT, 0, MPI_COMM_WORLD);\n  } else {\n    my_bcast(&amp;amp;data, 1, MPI_INT, 0, MPI_COMM_WORLD);\n    printf(\"Process %d received data %d from root process\\n\", world_rank, data);\n  }\n\n  MPI_Finalize();\n}\n</code></pre> <pre>\n<code>Writing mybcast.c\n</code>\n</pre> <pre><code>!smpicc mybcast.c -o mybcast\n</code></pre> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./mybcast\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nProcess 0 broadcasting data 100\nProcess 15 received data 100 from root process\nProcess 14 received data 100 from root process\nProcess 13 received data 100 from root process\nProcess 12 received data 100 from root process\nProcess 11 received data 100 from root process\nProcess 10 received data 100 from root process\nProcess 9 received data 100 from root process\nProcess 8 received data 100 from root process\nProcess 7 received data 100 from root process\nProcess 6 received data 100 from root process\nProcess 5 received data 100 from root process\nProcess 4 received data 100 from root process\nProcess 3 received data 100 from root process\nProcess 2 received data 100 from root process\nProcess 1 received data 100 from root process\n</code>\n</pre> <p>Acredite ou n\u00e3o, nossa fun\u00e7\u00e3o \u00e9 realmente muito ineficiente! Imagine que cada processo tenha apenas um link de rede de entrada/sa\u00edda. Nossa fun\u00e7\u00e3o \u00e9 usar apenas um link de rede do processo zero para enviar todos os dados. Uma implementa\u00e7\u00e3o mais inteligente \u00e9 um algoritmo de comunica\u00e7\u00e3o baseado em \u00e1rvore que pode usar mais links de rede dispon\u00edveis de uma s\u00f3 vez. Por exemplo:</p> <p></p> <p>O processo zero come\u00e7a com os dados e os envia para o processo um. Semelhante ao nosso exemplo anterior, o processo zero tamb\u00e9m envia os dados para o processo dois no segundo est\u00e1gio. A diferen\u00e7a com este exemplo \u00e9 que o processo um agora est\u00e1 ajudando o processo raiz encaminhando os dados para o processo tr\u00eas. Durante o segundo est\u00e1gio, duas conex\u00f5es de rede est\u00e3o sendo utilizadas por vez. A utiliza\u00e7\u00e3o da rede dobra em cada est\u00e1gio subseq\u00fcente da \u00e1rvore de comunica\u00e7\u00e3o at\u00e9 que todos os processos tenham recebido os dados.</p> <p>A implementa\u00e7\u00e3o do MPI_Bcast utiliza um algoritmo de transmiss\u00e3o em \u00e1rvore semelhante para uma boa utiliza\u00e7\u00e3o da rede. Abaixo temos o c\u00f3digo anterior comparado com a chamada de MPI_Bcast:</p> <pre><code>%%writefile mpibcast.c\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;mpi.h&gt;\n#include &lt;assert.h&gt;\n\nvoid my_bcast(void* data, int count, MPI_Datatype datatype, int root,\n              MPI_Comm communicator) {\n  int world_rank;\n  MPI_Comm_rank(communicator, &amp;amp;world_rank);\n  int world_size;\n  MPI_Comm_size(communicator, &amp;amp;world_size);\n\n  if (world_rank == root) {\n    // If we are the root process, send our data to everyone\n    int i;\n    for (i = 0; i &amp;lt; world_size; i++) {\n      if (i != world_rank) {\n        MPI_Send(data, count, datatype, i, 0, communicator);\n      }\n    }\n  } else {\n    // If we are a receiver process, receive the data from the root\n    MPI_Recv(data, count, datatype, root, 0, communicator, MPI_STATUS_IGNORE);\n  }\n}\n\nint main(int argc, char** argv) {\n  if (argc != 3) {\n    fprintf(stderr, \"Usage: compare_bcast num_elements num_trials\\n\");\n    exit(1);\n  }\n\n  int num_elements = atoi(argv[1]);\n  int num_trials = atoi(argv[2]);\n\n  MPI_Init(NULL, NULL);\n\n  int world_rank;\n  MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;world_rank);\n\n  double total_my_bcast_time = 0.0;\n  double total_mpi_bcast_time = 0.0;\n  int i;\n  int* data = (int*)malloc(sizeof(int) * num_elements);\n  assert(data != NULL);\n\n  for (i = 0; i &amp;lt; num_trials; i++) {\n    // Time my_bcast\n    // Synchronize before starting timing\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_my_bcast_time -= MPI_Wtime();\n    my_bcast(data, num_elements, MPI_INT, 0, MPI_COMM_WORLD);\n    // Synchronize again before obtaining final time\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_my_bcast_time += MPI_Wtime();\n\n    // Time MPI_Bcast\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_mpi_bcast_time -= MPI_Wtime();\n    MPI_Bcast(data, num_elements, MPI_INT, 0, MPI_COMM_WORLD);\n    MPI_Barrier(MPI_COMM_WORLD);\n    total_mpi_bcast_time += MPI_Wtime();\n  }\n\n  // Print off timing information\n  if (world_rank == 0) {\n    printf(\"Data size = %d, Trials = %d\\n\", num_elements * (int)sizeof(int),\n           num_trials);\n    printf(\"Avg my_bcast time = %lf\\n\", total_my_bcast_time / num_trials);\n    printf(\"Avg MPI_Bcast time = %lf\\n\", total_mpi_bcast_time / num_trials);\n  }\n\n  free(data);\n  MPI_Finalize();\n}\n</code></pre> <pre>\n<code>Writing mpibcast.c\n</code>\n</pre> <pre><code>!smpicc mpibcast.c -o mpibcast\n</code></pre> <p>Vamos, agora, rodar um experimento comparativo entre a nossa implementa\u00e7\u00e3o de transmiss\u00e3o e a do MPI, enviando 10 vezes um vetor de 100000 n\u00fameros do processo-mestre para os processos-escravos:</p> <pre><code>!smpirun -np 16 -platform simgrid-template-smpi/cluster_crossbar.xml -hostfile simgrid-template-smpi/cluster_hostfile ./mpibcast 100000 10\n</code></pre> <pre>\n<code>[0.000000] [xbt_cfg/INFO] Configuration change: Set 'smpi/privatization' to '1'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'surf/precision' to '1e-9'\n[0.000000] [xbt_cfg/INFO] Configuration change: Set 'network/model' to 'SMPI'\n[0.000000] [smpi_kernel/INFO] You did not set the power of the host running the simulation.  The timings will certainly not be accurate.  Use the option \"--cfg=smpi/host-speed:&lt;flops&gt;\" to set its value.  Check https://simgrid.org/doc/latest/Configuring_SimGrid.html#automatic-benchmarking-of-smpi-code for more information.\nData size = 400000, Trials = 10\nAvg my_bcast time = 0.068692\nAvg MPI_Bcast time = 0.018464\n</code>\n</pre> <pre><code>#COLOQUE SUA IMPLEMENTA\u00c7\u00c3O AQUI\n</code></pre> <pre><code>%%writefile pi.c\n\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;mpi.h&gt;\n\n/* We define pi here so we can check and see how accurate our computation is. */\n#define PI 3.141592653589793238462643\n\nint main(int argc, char **argv) {\n    MPI_Init(&amp;amp;argc, &amp;amp;argv);\n\n    int processes, myid;\n    MPI_Comm_size(MPI_COMM_WORLD, &amp;amp;processes);\n    MPI_Comm_rank(MPI_COMM_WORLD, &amp;amp;myid);\n\n\n    int intervals;\n    if (myid == 0) {\n        printf(\"Number of intervals: \");\n        fflush(stdout);\n        scanf(\"%d\", &amp;amp;intervals);\n    }\n\n    double time1 = MPI_Wtime();\n\n    MPI_Bcast(**********************************************************);\n\n    int count = intervals / processes;\n    int start = count * myid;\n    int end = count * myid + count;\n\n    int i;\n    double subtotal, total = 0;\n    for (i = start; i &amp;lt; end; ++i) {\n        subtotal += pow(-1, i) / (2 * i + 1);\n    }\n\n    MPI_Reduce(***********************************************************);\n\n    double time2 = MPI_Wtime();\n\n    if (myid == 0) {\n        total = total * 4;\n        printf(\"Result:   %.10lf\\n\", total);\n        printf(\"Accuracy: %.10lf\\n\", PI - total);\n        printf(\"Time:     %.10lf\\n\", time2 - time1);\n    }\n\n    MPI_Finalize();\n}\n</code></pre> <pre><code># PROPONHA SUA IMPLEMENTA\u00c7\u00c3O AQUI\n</code></pre>"},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/#message-passing-interface-aula-3","title":"MESSAGE PASSING INTERFACE (AULA 3)","text":""},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/#comunicacao-de-grupo-em-mpi","title":"COMUNICA\u00c7\u00c3O DE GRUPO EM MPI","text":"<p>Nas aulas passadas, examinamos a comunica\u00e7\u00e3o ponto a ponto, que \u00e9 a comunica\u00e7\u00e3o entre dois processos. Nesta aula, estudaremos os mecanismos de comunica\u00e7\u00e3o coletiva em MPI. A comunica\u00e7\u00e3o coletiva \u00e9 um m\u00e9todo de comunica\u00e7\u00e3o que envolve a participa\u00e7\u00e3o de todos os processos em um comunicador.</p> <p>Novamente, vamos reinstalar o simgrid e fazer o download do modelos de clusters:</p>"},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/#broadcasting-transmissao-em-mpi","title":"BROADCASTING (TRANSMISS\u00c3O) EM MPI","text":"<p>Uma transmiss\u00e3o \u00e9 uma das t\u00e9cnicas padr\u00e3o de comunica\u00e7\u00e3o coletiva. Durante uma transmiss\u00e3o, um processo envia os mesmos dados para todos os processos em um comunicador. Um dos principais usos da transmiss\u00e3o \u00e9 enviar a entrada do usu\u00e1rio para um programa paralelo ou enviar par\u00e2metros de configura\u00e7\u00e3o para todos os processos.</p> <p>O padr\u00e3o de comunica\u00e7\u00e3o de uma transmiss\u00e3o \u00e9 da seguinte forma:</p>"},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/#exercicio-1","title":"EXERC\u00cdCIO 1","text":"<p>Varie o n\u00famero de processadores, trials e n\u00fameros de elementos do c\u00f3digo anterior e compare os resultados.</p>"},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/#exercicio-2","title":"EXERC\u00cdCIO 2","text":"<p>Considere o c\u00f3digo abaixo, que produz uma aproxima\u00e7\u00e3o de PI usando as primitivas MPI_Bcast e MPI_Reduce. Neste c\u00f3digo:</p> <ul> <li>o mestre l\u00ea o n\u00famero de intervalos e o envia a todos os escravos</li> <li>os escravos calculam as suas aproxima\u00e7\u00f5es para PI usando a F\u00f3rmula de Leibiniz (subtotal)</li> <li>o mestre reduz o resultado usando uma soma dos subtotais</li> </ul> <p>Com base nesta descri\u00e7\u00e3o, complete (em ****) o c\u00f3digo fornecido:</p>"},{"location":"aulas/20%20-%20Broadcasting-mpi/MPI_AULA3/#exercicio-3","title":"EXERC\u00cdCIO 3","text":"<p>Ap\u00f3s o estudo de todas as primitivas de MPI realizadas at\u00e9 aqui, proponha o esquema de uma implementa\u00e7\u00e3o para resolver o problema da mochila.</p> <p>DESAFIO: implemente o esquema em MPI.</p>"},{"location":"aulas/21-SLURM/","title":"CLUSTERS - SLURM","text":""},{"location":"aulas/MPI/","title":"MPI","text":""},{"location":"aulas/MPI-OpenMP/","title":"MPI e OpenMP","text":""},{"location":"projetos/","title":"Projeto da disciplina","text":"<p>O projeto da nossa disciplina est\u00e1 dispon\u00edvel nesse link</p>"},{"location":"projetos/exaustiva/","title":"Busca Exaustiva para Alinhamento de Sequencias","text":"<p>A busca exaustiva, conforme vista aula, gera todas as solu\u00e7\u00f5es vi\u00e1veis para um problema e, de acordo com um crit\u00e9rio de otimalidade, elege uma solu\u00e7\u00e3o \u00f3tima para o problema. Especificamente para o problema de alinhamento de sequencias, ele pode ser especificado da seguinte forma:</p> <pre><code>ALGORITMO BUSCA EXAUSTIVA\nEntrada: Duas sequencias de DNA a e b\n        Pesos wmat, wmis e wgap para match, mismatch e gap respectivamente\nSa\u00edda: Score de um alinhamento das sequencias\n      Subsequencias alinhadas\n\n1. Gerar todas as subsequencias a\u00b4 e b\u00b4 n\u00e3o-nulas de a e b, respectivamente.\n2. Calcular os alinhamentos de cada par de subsequencias (a\u00b4, b\u00b4) com os pesos wmat, wmis e wgap\n3. Devolver o score m\u00e1ximo m entre os scores do passo (2) e as subsequencias associadas a ele\n</code></pre> <p>Observe que, no passo (2), as subsequencias podem n\u00e3o ter o mesmo tamanho. Assim, n\u00e3o ser\u00e1 poss\u00edvel calcular diretamente um score simples. Podemos usar, por exemplo:</p> <ul> <li> a estrat\u00e9gia vista no primeiro projeto (Alinhamento Local de Smith-Waterman) para comparar duas subsequencias          <li> um truncamento da subsequencia maior pelo tamanho da subsequencia menor e calcular o score simples entre as duas subsequencias resultantes          <li> o Alinhamento Local de Smith-Waterman quando as subsequencias forem de tamanhos diferentes e, quando forem de tamanho igual, a estrat\u00e9gia aleat\u00f3ria do Projeto II.                    <p>A partir desta descri\u00e7\u00e3o, nosso terceiro projeto ter\u00e1 duas tarefas:</p> <ul> <li> Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo utilizando o algoritmo acima, assim como as subsequencias associadas a ele.    <li> Implementar duas estrat\u00e9gias diferentes para calcular os alinhamentos entre os pares de subsequencias do passo (2).  No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python. Como se trata de uma busca exaustiva, recomenda-se come\u00e7ar a testar com tamanhos pequenos e      ir aumentando gradativamente at\u00e9 atingir o tamanho m\u00e1ximo que a sua plataforma ainda consiga executar."},{"location":"projetos/gpu/","title":"Paralelismo com GPU","text":"<p>Esta etapa do projeto consiste em resolver nosso problema por meio da biblioteca Thrust. Vamos come\u00e7ar revendo a formaliza\u00e7\u00e3o de nosso problema:</p> <p>Entrada:</p> <p>Um inteiro N representando o n\u00famero de filmes dispon\u00edveis para assistir. Tr\u00eas vetores H, F e C de tamanho N, onde H[i] \u00e9 a hora de in\u00edcio, F[i] \u00e9 a hora de t\u00e9rmino e C[i] \u00e9 a categoria do i-\u00e9simo filme. Um inteiro M representando o n\u00famero de categorias. Um vetor L de tamanho M, onde L[j] \u00e9 o n\u00famero m\u00e1ximo de filmes que podem ser assistidos na categoria j.</p> <p>Sa\u00edda:</p> <p>Um inteiro representando o n\u00famero m\u00e1ximo de filmes que podem ser assistidos de acordo com as restri\u00e7\u00f5es de hor\u00e1rios e n\u00famero m\u00e1ximo por categoria.</p> <p>Para resolver esse problema utilizando a biblioteca thrust, podemos utilizar um algoritmo de programa\u00e7\u00e3o din\u00e2mica para construir a solu\u00e7\u00e3o de forma eficiente. O algoritmo consiste em criar uma matriz dp de tamanho (N+1) x (M+1) para armazenar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos at\u00e9 o filme i e a categoria j.</p> <p>Segue abaixo um pseudo-c\u00f3digo (incompleto) para resolver o problema</p> <pre><code>// Carregar os dados do arquivo de entrada na mem\u00f3ria da GPU\nthrust::device_vector&lt;int&gt; start_times(N);\nthrust::device_vector&lt;int&gt; end_times(N);\nthrust::device_vector&lt;int&gt; categories(N);\n\n// Ler os dados do arquivo de entrada\n// ...\n\n// Criar a matriz de programa\u00e7\u00e3o din\u00e2mica\nthrust::device_vector&lt;int&gt; dp((N+1) * (M+1), 0);\n\n// Inicializar a primeira linha da matriz com zeros\nthrust::fill(dp.begin(), dp.begin() + M + 1, 0);\n\n// Preencher a matriz com as solu\u00e7\u00f5es para subproblemas menores\nfor (int i = 1; i &lt;= N; i++) {\n  for (int j = 1; j &lt;= M; j++) {\n    // Encontrar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos at\u00e9 o filme i e categoria j\n    int max_count = 0;\n    for (int k = 0; k &lt; i; k++) {\n      if (categories[k] == j &amp;&amp; end_times[k] &lt;= start_times[i] &amp;&amp; dp[(k*(M+1)) + j-1] + 1 &lt;= L[j-1]) {\n        max_count = max(max_count, dp[(k*(M+1)) + j-1] + 1);\n      } else {\n        max_count = max(max_count, dp[(k*(M+1)) + j]);\n      }\n    }\n    dp[(i*(M+1)) + j] = max_count;\n  }\n}\n\n// Encontrar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos\nint max_count = 0;\nfor (int j = 1; j &lt;= M; j++) {\n  max_count = max(max_count, dp[(N*(M+1)) + j]);\n}\n\n// Escrever o resultado no arquivo de sa\u00edda\n// ...\n</code></pre> <p>A ideia do algoritmo \u00e9 criar uma matriz dp de tamanho (N+1) x (M+1) para armazenar o n\u00famero m\u00e1ximo de filmes que podem ser assistidos at\u00e9 o filme i e a categoria j. O algoritmo preenche a matriz com as solu\u00e7\u00f5es para subproblemas menores, at\u00e9 chegar na solu\u00e7\u00e3o do problema original.</p> <p>Para cada c\u00e9lula (i,j) da matriz dp, o algoritmo verifica se \u00e9 poss\u00edvel adicionar o filme i \u00e0 categoria j, respeitando as restri\u00e7\u00f5es de hor\u00e1rio e limite m\u00e1ximo de filmes por categoria. Em seguida, o algoritmo verifica se \u00e9 melhor adicionar o filme i \u00e0 categoria j ou manter a solu\u00e7\u00e3o anterior sem o filme i. O n\u00famero m\u00e1ximo de filmes que podem ser assistidos \u00e9 o valor da c\u00e9lula (N, j) da matriz dp, onde j \u00e9 a categoria que maximiza o n\u00famero de filmes assistidos.</p> <p>Sua tarefa \u00e9 realizar essa implementa\u00e7\u00e3o em C++ com a Thrust e comparar o desempenho frente as demais implementa\u00e7\u00f5es. </p>"},{"location":"projetos/heuristico/","title":"Heur\u00edstica Gulosa","text":"<p>A primeira implementa\u00e7\u00e3o da heur\u00edstica para nosso projeto consiste em uma implementa\u00e7\u00e3o gulosa (Greedy).</p> <p>Implemente uma vers\u00e3o gulosa que ordena os filmes por hora de fim crescente e escolhe aqueles que come\u00e7am primeiro e n\u00e3o conflitam com os filmes j\u00e1 escolhidos, al\u00e9m de verificar se h\u00e1 vagas dispon\u00edveis na categoria do filme.</p>"},{"location":"projetos/local/","title":"Aleatoriedade","text":"<p>Como vimos em aula, aleatoriedade \u00e9 uma estrat\u00e9gia bastante comum para constru\u00e7\u00e3o de algoritmos de busca local, podendo ser usada de forma isolada ou de forma complementar a outra estrat\u00e9gia de varredura de um espa\u00e7o de solu\u00e7\u00f5es. </p> <p>Essa implementa\u00e7\u00e3o consiste na adapta\u00e7\u00e3o da heur\u00edstica gulosa de nosso projeto. A proposta \u00e9 que voc\u00ea modifique a sua heur\u00edstica gulosa de modo que ao longo da sele\u00e7\u00e3o de um filme voc\u00ea tenha 25% de chance de pegar outro filme qualquer que respeite o hor\u00e1rio. Isso far\u00e1 com que sua heur\u00edstica tenha um pouco mais de exploration e possamos ter alguns resultados melhores. </p> <p>Importante: \u00e9 essencial que voc\u00ea guarde todos os inputs usados ao longo do projeto, para que possa comparar o desempenho de seus algoritmos conforme mudamos a heur\u00edstica. Ou seja, todas as heur\u00edsticas devem ser submetidas aos mesmos arquivos de input. O seu resultado deve ser comparado sob duas perspectivas, no m\u00ednimo: (i) tempo de execu\u00e7\u00e3o em fun\u00e7\u00e3o do aumento de filmes e de categorias e (ii) tempo de tela (isto \u00e9, ser\u00e1 que estamos conseguindo ocupar bem as 24h do dia assitindo filmes?).</p>"},{"location":"projetos/openmp/","title":"Paralelismo com OpenMP","text":"<p>At\u00e9 agora experimentamos heur\u00edsticas que buscaram resolver o nosso problema em um tempo razo\u00e1vel, sem garantias de otimalidade. \u00c9 chegado o momento de incorporar o paralelismo de tarefas em nossas alternativas de resolu\u00e7\u00e3o.</p> <p>Para isso, voc\u00ea deve modificar a vers\u00e3o exaustiva de sua implementa\u00e7\u00e3o. Voc\u00ea pode fazer uso da diretiva <code>#pragma omp parallel for</code> para distribuir as itera\u00e7\u00f5es de um loop entre as threads dispon\u00edveis. Dentro do loop, voc\u00ea pode fazer a verifica\u00e7\u00e3o de cada filme e, caso ele esteja dentro das restri\u00e7\u00f5es de hor\u00e1rio e categoria, incrementar uma vari\u00e1vel compartilhada <code>count</code>. Observe que por ser uma vari\u00e1vel compartilhada, voc\u00ea precisa preservar essa regi\u00e3o cr\u00edtica entre as threads. </p> <p>Vale ressaltar que o uso do OpenMP n\u00e3o necessariamente ir\u00e1 garantir um desempenho melhor, pois a paraleliza\u00e7\u00e3o tem um overhead que pode acabar diminuindo a performance do programa em alguns casos. \u00c9 importante fazer testes para verificar se a utiliza\u00e7\u00e3o do OpenMP \u00e9 realmente ben\u00e9fica para o problema em quest\u00e3o.</p>"},{"location":"projetos/relatorio_parcial/","title":"Relat\u00f3rio Parcial","text":"<p>O relat\u00f3rio parcial \u00e9 a entrega intermedi\u00e1ria do projeto, a qual deve ser feita pelo blackboard at\u00e9 a data da prova intermedi\u00e1ria.</p> <p>Seu relat\u00f3rio dever\u00e1 conter as implementa\u00e7\u00f5es gulosa e aleat\u00f3ria. </p> <p>O que voc\u00ea dever\u00e1 fazer:</p> <ul> <li> <p>No blackboard, voc\u00ea deve fazer upload de todos os c\u00f3digos-fonte, arquivos de input, arquivos de output para cada heur\u00edtica. Caso opte por enviar um link do github com o reposit\u00f3rio completo, tamb\u00e9m poder\u00e1 faze-lo, desde que garanta que teremos acesso aos arquivos no seu reposit\u00f3rio;</p> </li> <li> <p>Voc\u00ea deve elaborar um relat\u00f3rio parcial contendo as seguintes se\u00e7\u00f5es:</p> <ul> <li> <p>Para cada heur\u00edstica voc\u00ea deve explicar como implementou a heur\u00edstica (detalhe como voc\u00ea tratou o input, qual a l\u00f3gica do seu output, quais invariantes existem em suas heur\u00edsticas), apresentar (i) o c\u00f3digo-fonte comentado, (ii) fazer considera\u00e7\u00f5es sobre o profiling (valgrind) do c\u00f3digo-fonte (use apenas 1 arquivo de input para isso, n\u00e3o h\u00e1 necessidade de fazer esse profiling para v\u00e1rios inputs), (iii) o resultado compartivo entre as heur\u00edsticas quando voc\u00ea varia o input (o input deve variar na quantidade de filmes e de categorias).</p> </li> <li> <p>Seu relat\u00f3rio deve ser gr\u00e1ficos e tabelas que subsidem as suas considera\u00e7\u00f5es</p> </li> <li> <p>\u00c9 permitido criar um programa em python ou outra linguagem que automatize a gera\u00e7\u00e3o de seus resultados, isto \u00e9, que execute seus c\u00f3digos C++ em fun\u00e7\u00e3o dos diferentes inputs.</p> </li> </ul> </li> </ul> <p>Preferencialmente o relat\u00f3rio deve ser apresentado em formato html. </p>"},{"location":"projetos/2021-2/","title":"Alinhamento de Sequencias de DNA","text":"<p>Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es.</p> <p>O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch). Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade:</p> <p></p> <p>Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch). Assim, teremos o seguinte n\u00edvel de similaridade:</p> <p>23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7</p> <p>Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma:</p> <pre><code>Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, \nencontrar o alinhamento que maximize o n\u00edvel de similaridade. \n</code></pre> <p>Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. </p> <p>Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros <code>n</code> e <code>m</code>, onde <code>n</code> \u00e9 o tamanho da primeira sequencia e, <code>m</code>, o tamanho da segunda. Assuma <code>n \u2264 200</code> e <code>m \u2264 200</code>. A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda.</p> <pre><code>5 7\nAT-CC\nTTTCCAA\n</code></pre> <p>A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade.</p> <p><pre><code>2\n</code></pre> Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o c\u00f3digo python abaixo para gerar inst\u00e2ncias aleat\u00f3rias para seus testes.</p> <pre><code>import random\nn = 10 # tamanho da primeira sequ\u00eancia\nm = 40 # tamanho da segunda sequ\u00eancia\nfile = 'dna.seq' # nome do arquivo a ser gerado\nf = open(file, 'w')\nseq=[str(n)+'\\n',\n     str(m)+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=n))+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=m))]\nf.writelines(seq)\nf.close()\nprint(''.join(seq))\n</code></pre> <p>Um poss\u00edvel output para este c\u00f3digo acima \u00e9:</p> <pre><code>10\n40\nTGGCGAT--C\nAGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A\n</code></pre>"},{"location":"projetos/2021-2/#estrategias-a-serem-estudadas-e-correcao-automatica","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica","text":"<p>Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior.</p> <ol> <li>Solu\u00e7\u00e3o Heur\u00edstica (18/03)</li> <li>Busca Local (01/04)</li> <li>Busca Exaustiva (15/04)</li> <li>Relat\u00f3rio Preliminar (29/04)</li> <li>Paralelismo Multicore (13/05)</li> <li>Paralelismo GPU (27/05)</li> <li>Relat\u00f3rio Final (03/06)</li> </ol>"},{"location":"projetos/2021-2/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.</p>"},{"location":"projetos/2021-2/#conceito-d","title":"Conceito D","text":"<p>Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final).</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2021-2/#conceito-c","title":"Conceito C","text":"<p>Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida.</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2021-2/#conceito-c_1","title":"Conceito C+","text":"<p>Al\u00e9m do j\u00e1 validado no conceito C, os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.</p>"},{"location":"projetos/2021-2/#conceitos-avancados","title":"Conceitos avan\u00e7ados","text":"<p>A partir do  conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.</p>"},{"location":"projetos/2021-2/busca-exaustiva/","title":"Solu\u00e7\u00e3o Busca exaustiva - Branch and Bound","text":"<p>Fa\u00e7a agora uma implementa\u00e7\u00e3o de busca exaustiva para o problema do min-set-cover. Assuma inicialmente que todos os subconjuntos s\u00e3o necess\u00e1rios. Para cada subconjunto da solu\u00e7\u00e3o, remova ele a solu\u00e7\u00e3o em quest\u00e3o e verifique se a propriedade de cobertura \u00e9 mantida. Fa\u00e7a isso para todos os elementos na ordem do vetor de solu\u00e7\u00f5es, enquanto a propriedade for v\u00e1lida. Se a propriedade ficar inv\u00e1lida, voc\u00ea deve interromper essa linha de processamento, executando ent\u00e3o uma nova estrutura de possibilidades em que considera esse conjunto vital para a continuidade do problema. </p> <p>Para auxiliar na sua implementa\u00e7\u00e3o, voc\u00ea pode se basear no pseudoc\u00f3digo abaixo. Assuma que custos \u00e9 um vetor unit\u00e1rio de cardinalidade igual ao vetor que armazena os subconjuntos. H\u00e1 um programa Python disponibilizado neste link para que voc\u00ea possa simular a implementa\u00e7\u00e3o desse pseudoc\u00f3digo. </p> <p>Avalie: H\u00e1 garantia de que o resultado \u00f3timo \u00e9 obtido? Justifique. </p> <p></p>"},{"location":"projetos/2021-2/busca-local/","title":"Solu\u00e7\u00e3o Busca local","text":"<p>A busca local consiste em uma metaheur\u00edstica usada para resolver problemas de otimiza\u00e7\u00e3o computacionalmente dif\u00edceis. Esse tipo de algoritmo percorre o espa\u00e7o de busca movendo-se iterativamente de uma solu\u00e7\u00e3o candidata para outra, seguindo um caminho atrav\u00e9s da rela\u00e7\u00e3o de vizinhan\u00e7a, at\u00e9 que uma solu\u00e7\u00e3o considerada boa o suficiente seja encontrada ou um limite de tempo decorrido. Normalmente todo candidato possui mais de uma solu\u00e7\u00e3o de vizinho e a escolha entre elas \u00e9 feita com o aux\u00edlio de informa\u00e7\u00f5es locais e experi\u00eancia anterior.</p> <p>A solu\u00e7\u00e3o por busca local  tenta maximizar o n\u00famero de elementos com o m\u00ednimo de subconjuntos poss\u00edvel. Precisamos capturar esse crit\u00e9rio por meio de uma fun\u00e7\u00e3o de fitness. Uma maneira poss\u00edvel de fazer isso \u00e9 construir uma fun\u00e7\u00e3o de fitness calculando o n\u00famero de elementos capturados pelos subconjuntos de uma solu\u00e7\u00e3o candidata e, em seguida, dividindo-o pelo n\u00famero de subconjuntos que cont\u00e9m. Essa fun\u00e7\u00e3o de pontua\u00e7\u00e3o favorecer\u00e1 as solu\u00e7\u00f5es que acumulam a maioria dos elementos do universo U com o m\u00ednimo de subconjuntos.</p> <p>Para isso, implemente as seguintes altera\u00e7\u00f5es em seu projeto:</p> <ol> <li>Gerar uma solu\u00e7\u00e3o aleat\u00f3ria para o problema do min-set-cover;</li> <li>Percorra novamente os conjuntos os elementos da sua solu\u00e7\u00e3o e, de maneira rand\u00f4mica, troque at\u00e9 r (r entre 1 e 3) elementos da sua solu\u00e7\u00e3o por subconjuntos que ficaram de fora da solu\u00e7\u00e3o. </li> <li>Se a solu\u00e7\u00e3o tiver melhor escore, mantenha ela. </li> </ol> <p>Para verificar o desempenho, construa um cen\u00e1rio com ao menos 200 elementos e 80 subconjuntos, de at\u00e9 40 elementos cada.  Fa\u00e7a tr\u00eas varia\u00e7\u00f5es desse cen\u00e1rio (elementos, subconjuntos, n\u00famero de elementos em subconjuntos) e avalie o desempenho e a efetividade em encontrar uma solu\u00e7\u00e3o \u00f3tima.</p> <p>Para a entrega, usaremos o site codePost, voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.</p>"},{"location":"projetos/2021-2/heuristico/","title":"Solu\u00e7\u00e3o heur\u00edstica","text":"<p>Um dos melhores estrat\u00e9gias para resolu\u00e7\u00e3o do problema min-set-cover \u00e9 a estrat\u00e9gia gulosa. O algoritmo guloso encontra uma solu\u00e7\u00e3o para o problema de cobertura de conjunto escolhendo iterativamente um conjunto que cobre o maior n\u00famero poss\u00edvel de vari\u00e1veis descobertas restantes.</p> <p>Sua tarefa: implemente a estrat\u00e9gia gulosa para o problema do min-set-cover. A cada itera\u00e7\u00e3o, o algoritmo deve selecionar o subconjunto de F que ir\u00e1 cobrir o maior n\u00famero de elementos de U que estavam descobertos.</p> <p>Veja abaixo um pseudo-c\u00f3digo da estrat\u00e9gia gulosa que voc\u00ea deve implementar.</p> <p></p> <p>Fa\u00e7a testes para diversos tipos de entradas, e foque principalmente em uma grande quantidade de elementos e subconjuntos (n &gt; 250).</p> <p>Voc\u00ea deve entregar, al\u00e9m de c\u00f3digo-fonte e todas as entradas e sa\u00eddas geradas para o seu programa, um arquivo contendo o resultado do programa <code>verify</code> ( que voc\u00ea implementou ) e comentar sobre o n\u00famero de vezes em que voc\u00ea conseguiu encontrar uma solu\u00e7\u00e3o para o problema. Comente tamb\u00e9m sobre o tempo de execu\u00e7\u00e3o de sua implementa\u00e7\u00e3o. </p> <p>Para a entrega, usaremos o site codePost, voc\u00ea recebeu na sala de aula o link para criar sua conta. A submiss\u00e3o ser\u00e1 feita unicamente por ele. Caso tenha alguma d\u00favida, entre em contato.</p>"},{"location":"projetos/2021-2/paralelismo-gpu/","title":"Paralelismo em GPU","text":"<p>Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela em GPU do algoritmo de busca local.</p>"},{"location":"projetos/2021-2/paralelismo-gpu/#compilacao-do-programa","title":"Compila\u00e7\u00e3o do programa","text":"<p>Voc\u00ea dever\u00e1 colocar o c\u00f3digo de seu programa em um arquivo com extens\u00e3o .cu na pasta da busca local. Este programa ser\u00e1 compilado com <code>nvcc -O3</code>. </p> <p>Para a entrega, usaremos o site codePost.</p> <p>\u2192</p>"},{"location":"projetos/2021-2/paralelismo-multicore/","title":"Paralelismo multi-core","text":"<p>Seu trabalho nesta atividade ser\u00e1 criar uma implementa\u00e7\u00e3o paralela do algoritmo de busca local.</p>"},{"location":"projetos/2021-2/paralelismo-multicore/#compilacao-do-programa","title":"Compila\u00e7\u00e3o do programa","text":"<p>Seu programa multi-core dever\u00e1 ser gerado a partir do mesmo c\u00f3digo fonte do sequencial. Ou seja, compilar com <code>-fopenmp</code> habilita o programa paralelo. Compilar sem essa flag obtem os resultados sequenciais. Caso seu programa use as chamadas do OpenMP para c\u00f3digos auxiliares (aloca\u00e7\u00e3o de mem\u00f3ria, etc), voc\u00ea pode checar se seu programa foi compilado com esta flag seguindo o exemplo abaixo.</p> <pre><code>#ifdef _OPENMP\n    // c\u00f3digo espec\u00edfico para multi-core aqui\n#else\n    // c\u00f3digo espec\u00edfico para sequencia aqui\n#endif\n</code></pre> <p>Para a entrega, usaremos o site codePost.</p>"},{"location":"projetos/2021-2/relatorio-1/","title":"Relat\u00f3rio - v1","text":"<p>Nesta primeira parte do relat\u00f3rio iremos analisar as implementa\u00e7\u00f5es j\u00e1 criadas com rela\u00e7\u00e3o a sua velocidade e qualidade da solu\u00e7\u00e3o. Os objetivos deste relat\u00f3rio s\u00e3o </p> <ul> <li>criar entradas de tamanho adequado para os prop\u00f3sitos dos testes</li> <li>estudar o efeito do n\u00famero de pessoas e do n\u00famero de objetos nas medidas de interesse (tempo e qualidade da solu\u00e7\u00e3o)</li> <li>comparar o desempenho dos algoritmos implementados at\u00e9 o momento em rela\u00e7\u00e3o a essas duas medidas.</li> </ul> <p>Seu trabalhou dever\u00e1 ser entregue como um arquivo PDF chamado relatorio-intermediario.pdf na pasta relatorios do reposit\u00f3rio. Ele poder\u00e1 ser gerado a partir de um Jupyter notebook (como feito na aula 01) ou usando a ferramenta pweave (recomendado). A rubrica de avalia\u00e7\u00e3o est\u00e1 dispon\u00edvel abaixo e tamb\u00e9m neste link.</p> <p>Data de entrega: 31/10/2021, pelo blackboard.</p> <p></p>"},{"location":"projetos/2022-1/","title":"Alinhamento de Sequencias de DNA","text":"<p>Em Bioinform\u00e1tica, o problema de alinhamento de sequ\u00eancias de DNA consiste no processo de comparar duas ou mais sequ\u00eancias de bases de forma a se observar seu n\u00edvel de similaridade. Trata-se de um problema extremamente importante no contexto atual, pois permite comparar sequencias virais de SARS-COV2 em bancos de dados gen\u00f4micos para detec\u00e7\u00e3o de novas muta\u00e7\u00f5es.</p> <p>O n\u00edvel de similaridade pode ser calculado com base em acertos (match) e erros (gap e mismatch). Os acertos contribuem com sinal positivo (+) para o n\u00edvel de similaridade e, os erros, com sinal negativo (-). Abaixo temos um exemplo de c\u00e1lculo do n\u00edvel similaridade:</p> <p></p> <p>Vamos associar a pontua\u00e7\u00e3o +1 (match) e as penalidades -1 (gap) e -4 (mismatch). Assim, teremos o seguinte n\u00edvel de similaridade:</p> <p>23 matches x (+1) + 4 gaps x (-1) + 3 mismatches x (-4) = 23-4-12 = 7</p> <p>Neste contexto, o problema de alinhamento de sequencias de DNA pode ser colocado da seguinte forma:</p> <pre><code>Dadas duas sequencias de DNA, com as bases A,T,G,C e - para indicar gap, \nencontrar o alinhamento que maximize o n\u00edvel de similaridade. \n</code></pre> <p>Neste projeto, seu objetivo ser\u00e1 construir programas para encontrar este alinhamento de n\u00edvel m\u00e1ximo de similaridade, utilizando v\u00e1rias estrat\u00e9gias. </p> <p>Cada um dos seus programas tomar\u00e1 como entrada a seguinte estrutura: a primeira linha cont\u00e9m dois n\u00fameros <code>n</code> e <code>m</code>, onde <code>n</code> \u00e9 o tamanho da primeira sequencia e, <code>m</code>, o tamanho da segunda. Assuma <code>n \u2264 200</code> e <code>m \u2264 200</code>. A segunda linha cont\u00e9m as bases da primeira sequencia e, a terceira linha, as bases da segunda.</p> <pre><code>5 7\nAT-CC\nTTTCCAA\n</code></pre> <p>A sa\u00edda deve ser uma linha com um n\u00famero inteiro indicando o n\u00edvel m\u00e1ximo de similaridade.</p> <p><pre><code>2\n</code></pre> Neste caso, este n\u00edvel m\u00e1ximo de similaridade pode ser associado ao alinhamento T-CC/TTCC (1-1+1+1=2) ou a CC/CC(1+1=2). Voc\u00ea pode usar o notebook SequenceGenerator.ipynb para gerar inst\u00e2ncias aleat\u00f3rias para seus testes.</p>"},{"location":"projetos/2022-1/#estrategias-a-serem-estudadas-e-correcao-automatica","title":"Estrat\u00e9gias a serem estudadas e corre\u00e7\u00e3o autom\u00e1tica","text":"<p>Para cada estrat\u00e9gia que vamos estudar, implementaremos um programa correspondente no projeto. Veja abaixo as datas de entrega e descri\u00e7\u00f5es de cada estrat\u00e9gia a ser implementada. Em geral, o enunciado de uma parte \u00e9 liberado ap\u00f3s a data de entrega da parte anterior.</p> <ol> <li>Solu\u00e7\u00e3o Heur\u00edstica (18/03)</li> <li>Busca Local(01/04)</li> <li>Busca Exaustiva(15/04)</li> <li>Relat\u00f3rio Preliminar (29/04)</li> <li>Paralelismo Multicore (13/05)</li> <li>Paralelismo GPU (27/05)</li> <li>Relat\u00f3rio Final (03/06)</li> </ol>"},{"location":"projetos/2022-1/#avaliacao","title":"Avalia\u00e7\u00e3o","text":"<p>O projeto ser\u00e1 avaliado usando rubricas para as entregas b\u00e1sicas. As rubricas de avalia\u00e7\u00e3o dos relat\u00f3rios estar\u00e3o descritas em suas p\u00e1ginas de entrega.</p>"},{"location":"projetos/2022-1/#conceito-d","title":"Conceito D","text":"<p>Algum dos seguintes itens n\u00e3o foi entregue corretamente ou possui problemas s\u00e9rios (no caso do relat\u00f3rio final).</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2022-1/#conceito-c","title":"Conceito C","text":"<p>Todas as atividades abaixo foram validadas pelo corretor e (no caso do relat\u00f3rio final) alcan\u00e7aram qualidade m\u00ednima exigida.</p> <ol> <li>Solu\u00e7\u00e3o heur\u00edstica</li> <li>Busca local</li> <li>Busca exaustiva</li> <li>Busca local paralela (CPU)</li> <li>Busca local paralela (GPU)</li> <li>Relat\u00f3rio preliminar</li> <li>Relat\u00f3rio final</li> </ol>"},{"location":"projetos/2022-1/#conceito-c_1","title":"Conceito C+","text":"<p>Al\u00e9m do j\u00e1 validado no conceito C, os relat\u00f3rios entregues n\u00e3o tinham nenhum ponto em desenvolvimento ou insatisfat\u00f3rio na rubrica do relat\u00f3rio.</p>"},{"location":"projetos/2022-1/#conceitos-avancados","title":"Conceitos avan\u00e7ados","text":"<p>A partir do  conceito C+ cada atividade avan\u00e7ada vale meio conceito. Elas ser\u00e3o listadas aqui conforme o semestre avan\u00e7a e ser\u00e3o testadas pela checagem de resultados dispon\u00edvel no reposit\u00f3rio de entregas.</p>"},{"location":"projetos/2022-1/SequenceGenerator/","title":"SequenceGenerator","text":"<p>GERADOR DE INST\u00c2NCIAS PARA COMPARA\u00c7\u00c3O DE SEQUENCIAS DE DNA</p> <p>Para usar este gerador, voc\u00ea deve fornecer tr\u00eas par\u00e2metros:</p> <p>n = tamanho da primeira sequencia </p> <p>m = tamanho da segunda inst\u00e2ncia </p> <p>file = nome do arquivo da inst\u00e2ncia a ser gerada</p> <pre><code>import random\nn = 10\nm = 40\nfile = 'dna.seq'\nf = open(file, 'w')\nseq=[str(n)+'\\n',\n     str(m)+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=n))+'\\n',\n     ''.join(random.choices(['A','T','C','G','-'],k=m))]\nf.writelines(seq)\nf.close()\nprint(''.join(seq))\n</code></pre> <pre>\n<code>10\n40\nTGGCGAT--C\nAGC-TCTCTTC--ATT--CAC-TACACCGACA-CGC-G-A\n</code>\n</pre>"},{"location":"projetos/2022-1/heuristico/","title":"Heur\u00edstica de Alinhamento Local de Smith-Waterman","text":"<p>Um algoritmo ing\u00eanuo para fazer o alinhamento local de duas sequencias de DNA poderia ser:</p> <ol> <li>Gere todas as subsequ\u00eancias, de tamanho 1 at\u00e9 o tamanho total de cada sequ\u00eancia</li> <li>Compare todos os pares de subsequencias, sempre escolhendo uma subsequencia de um DNA e do outro DNA, calculado seus scores</li> <li>Escolha uma que produza o score m\u00e1ximo</li> </ol> <p>Nao \u00e9 dif\u00edcil ver que este algoritmo ing\u00eanuo pode demorar muito tempo para executar quando aumentamos o tamanho das sequencias de DNA.</p> <p>Uma heur\u00edstica sequencial bastante interessante para reduzir o tempo de obten\u00e7\u00e3o dos alinhamentos foi proposta por Smith e Waterman (1981), utilizando programa\u00e7\u00e3o din\u00e2mica. Abaixo, temos a descri\u00e7\u00e3o do algoritmo desta estrat\u00e9gia:</p> <pre>\nALGORITMO SMITH-WATERMAN\nEntrada: Duas sequencias de DNA a[i] e b[j], de tamanhos n e m respectivamente\nSa\u00edda: score m\u00e1ximo de alinhamento \n\n1. Inicializar H[i,0]=0, 0\u2264i\u2264n\n2. Inicializar H[0,j]=0, 0\u2264j\u2264m\n3. Para cada 1\u2264i\u2264n e 1\u2264j\u2264m:\n4.     Calcular diagonal = H[i-1,j-1] + w(a[i],b[j]), onde w(a[i],b[j])=2 se houve match, \n                           w(a[i],b[j])= -1 se houve mismatch e  \n                           w(a[i],b[j])= -1 se houve gap\n5.     Calcular dele\u00e7\u00e3o  = H[i-1,j] - 1\n6.     Calcular inser\u00e7\u00e3o = H[i,j-1] - 1\n7.     Calcular H[i,j]=m\u00e1ximo (0, diagonal, dele\u00e7\u00e3o, inser\u00e7\u00e3o)\n9. Retornar o m\u00e1ximo de H[_,_]\n</pre> <p>Os passos diagonal, dele\u00e7\u00e3o e inser\u00e7\u00e3o s\u00e3o chamados, respectivamente, de salto em diagonal, salto de cima para baixo e salto da esquerda para a direita, e representam movimenta\u00e7\u00f5es para obten\u00e7\u00e3o do alinhamento local \u00f3timo. </p> <p>No link abaixo, \u00e9 poss\u00edvel simular este algoritmo para diversos valores de pesos:</p> <p>http://rna.informatik.uni-freiburg.de/Teaching/index.jsp?toolName=Smith-Waterman</p> <p>Abaixo temos um exemplo da matriz H calculada para as sequ\u00eancias AGCACACA e ACACACTA:</p> <p></p> <p>Para obter o alinhamento local \u00f3timo, come\u00e7amos com o maior valor na matriz (i,j). Ent\u00e3o, n\u00f3s vamos para tr\u00e1s para uma das posi\u00e7\u00f5es (i-1,j), (i,j-1) ou (i-1,j-1), dependendo da dire\u00e7\u00e3o de movimento usado para construir a matriz. Mantemos o processo at\u00e9 chegar a um c\u00e9lula da matriz com valor zero, ou o valor na posi\u00e7\u00e3o (0,0).</p> <p>No exemplo, o valor mais alto corresponde \u00e0 c\u00e9lula na posi\u00e7\u00e3o (8,8). A caminhada de volta corresponde a (8,8), (7,7), (7,6), (6,5), (5,4), (4,3), (3,2), (2,1), (1,1), e (0,0),</p> <p>Uma vez que tenhamos terminado, reconstruimos o alinhamento da seguinte forma: Come\u00e7ando com o \u00faltimo valor, chegamos a (i,j) usando o caminho previamente calculado. Um salto na diagonal implica que h\u00e1 um alinhamento (ou uma correspond\u00eancia ou uma n\u00e3o correspond\u00eancia). Um salto de cima para baixo implica que h\u00e1 uma dele\u00e7\u00e3o. Um salto da esquerda para a direita implica que h\u00e1 uma inser\u00e7\u00e3o. Assim, para a reconstru\u00e7\u00e3o, \u00e9 importante guardar durante a montagem da tabela H qual o tipo de salto foi utilizado.</p> <p>Para o exemplo das sequencias acima, obtemos o seguinte alinhamento local \u00f3timo (em rela\u00e7\u00e3o aos pesos dados para match, mismatch e gap):</p> <pre>\nSequ\u00eancia 1 = A-CACACTA\nSequ\u00eancia 2 = AGCACAC-A\n</pre> <p>A partir desta descri\u00e7\u00e3o, nosso primeiro projeto ter\u00e1 duas tarefas:</p> <ul> <li> Implementar um programa C++ para ler um arquivo contendo os tamanhos de duas sequencias de DNA, seguidos das duas sequencias, uma por linha. Calcular o score m\u00e1ximo de alinhamento local usando a heur\u00edstica de Smith-Waterman. As informa\u00e7\u00f5es para reconstru\u00e7\u00e3o dever\u00e3o ser armazenadas no formato de struct.   <li> a partir do score m\u00e1ximo, reconstruir e exibir o alinhamento local \u00f3timo das duas sequencias.  <p>No diret\u00f3rio do projeto, h\u00e1 um gerador de entradas disponibilizado como um notebook Python.</p> <p>Para quem estiver interessado no artigo original da heur\u00edstica de Smith-Waterman, basta consultar o link http://arep.med.harvard.edu/pdf/Smith81.pdf.</p>"}]}